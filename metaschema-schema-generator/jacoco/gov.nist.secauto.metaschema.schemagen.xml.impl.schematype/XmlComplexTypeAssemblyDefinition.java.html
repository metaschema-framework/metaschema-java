<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlComplexTypeAssemblyDefinition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema XML and JSON Schema Generator</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.schemagen.xml.impl.schematype</a> &gt; <span class="el_source">XmlComplexTypeAssemblyDefinition.java</span></div><h1>XmlComplexTypeAssemblyDefinition.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.schemagen.xml.impl.schematype;

import gov.nist.secauto.metaschema.core.datatype.markup.MarkupDataTypeProvider;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IChoiceGroupInstance;
import gov.nist.secauto.metaschema.core.model.IChoiceInstance;
import gov.nist.secauto.metaschema.core.model.IFieldInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.IFlagInstance;
import gov.nist.secauto.metaschema.core.model.IModelInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.INamedModelInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.INamedModelInstanceGrouped;
import gov.nist.secauto.metaschema.core.model.XmlGroupAsBehavior;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.schemagen.SchemaGenerationException;
import gov.nist.secauto.metaschema.schemagen.xml.XmlSchemaGenerator;
import gov.nist.secauto.metaschema.schemagen.xml.impl.DocumentationGenerator;
import gov.nist.secauto.metaschema.schemagen.xml.impl.XmlGenerationState;

import java.util.Collection;

import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;

import edu.umd.cs.findbugs.annotations.NonNull;

<span class="fc" id="L31">public class XmlComplexTypeAssemblyDefinition</span>
    extends AbstractXmlComplexType&lt;IAssemblyDefinition&gt; {

  public XmlComplexTypeAssemblyDefinition(
      @NonNull QName qname,
      @NonNull IAssemblyDefinition definition) {
<span class="fc" id="L37">    super(qname, definition);</span>
<span class="fc" id="L38">  }</span>

  @Override
  protected void generateTypeBody(XmlGenerationState state) throws XMLStreamException {
<span class="fc" id="L42">    IAssemblyDefinition definition = getDefinition();</span>

<span class="fc" id="L44">    Collection&lt;? extends IModelInstanceAbsolute&gt; modelInstances = definition.getModelInstances();</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">    if (!modelInstances.isEmpty()) {</span>
<span class="fc" id="L46">      state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;sequence&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">      for (IModelInstanceAbsolute modelInstance : modelInstances) {</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">        assert modelInstance != null;</span>
<span class="fc" id="L49">        generateModelInstance(modelInstance, state);</span>
<span class="fc" id="L50">      }</span>
<span class="fc" id="L51">      state.writeEndElement();</span>
    }

<span class="fc" id="L54">    Collection&lt;? extends IFlagInstance&gt; flagInstances = definition.getFlagInstances();</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">    if (!flagInstances.isEmpty()) {</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">      for (IFlagInstance flagInstance : flagInstances) {</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        assert flagInstance != null;</span>
<span class="fc" id="L58">        generateFlagInstance(flagInstance, state);</span>
<span class="fc" id="L59">      }</span>
    }
<span class="fc" id="L61">  }</span>

  protected void generateModelInstance( // NOPMD acceptable complexity
      @NonNull IModelInstanceAbsolute modelInstance,
      @NonNull XmlGenerationState state)
      throws XMLStreamException {

<span class="fc" id="L68">    boolean grouped = false;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    if (XmlGroupAsBehavior.GROUPED.equals(modelInstance.getXmlGroupAsBehavior())) {</span>
      // handle grouping
<span class="fc" id="L71">      state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;element&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc" id="L73">      QName groupAsQName = ObjectUtils.requireNonNull(modelInstance.getEffectiveXmlGroupAsQName());</span>

<span class="pc bpc" id="L75" title="1 of 2 branches missed.">      if (state.getDefaultNS().equals(groupAsQName.getNamespaceURI())) {</span>
<span class="fc" id="L76">        state.writeAttribute(&quot;name&quot;, ObjectUtils.requireNonNull(groupAsQName.getLocalPart()));</span>
      } else {
<span class="nc" id="L78">        throw new SchemaGenerationException(</span>
<span class="nc" id="L79">            String.format(&quot;Attempt to create element '%s' on definition '%s' with different namespace&quot;, groupAsQName,</span>
<span class="nc" id="L80">                getDefinition().toCoordinates()));</span>
      }

<span class="pc bpc" id="L83" title="1 of 2 branches missed.">      if (modelInstance.getMinOccurs() == 0) {</span>
        // this is an optional instance group
<span class="fc" id="L85">        state.writeAttribute(&quot;minOccurs&quot;, &quot;0&quot;);</span>
      }

      // now generate the child elements of the group
<span class="fc" id="L89">      state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;complexType&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>
<span class="fc" id="L90">      state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;sequence&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

      // mark that we need to close these elements
<span class="fc" id="L93">      grouped = true;</span>
    }

<span class="pc bpc" id="L96" title="1 of 5 branches missed.">    switch (modelInstance.getModelType()) {</span>
    case ASSEMBLY:
<span class="fc" id="L98">      generateNamedModelInstance((INamedModelInstanceAbsolute) modelInstance, grouped, state);</span>
<span class="fc" id="L99">      break;</span>
    case FIELD: {
<span class="fc" id="L101">      IFieldInstanceAbsolute fieldInstance = (IFieldInstanceAbsolute) modelInstance;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      if (fieldInstance.isEffectiveValueWrappedInXml()) {</span>
<span class="fc" id="L103">        generateNamedModelInstance(fieldInstance, grouped, state);</span>
      } else {
<span class="fc" id="L105">        generateUnwrappedFieldInstance(fieldInstance, grouped, state);</span>
      }
<span class="fc" id="L107">      break;</span>
    }
    case CHOICE:
<span class="fc" id="L110">      generateChoiceModelInstance((IChoiceInstance) modelInstance, state);</span>
<span class="fc" id="L111">      break;</span>
    case CHOICE_GROUP:
<span class="fc" id="L113">      generateChoiceGroupInstance((IChoiceGroupInstance) modelInstance, state);</span>
<span class="fc" id="L114">      break;</span>
    default:
<span class="nc" id="L116">      throw new UnsupportedOperationException(modelInstance.getModelType().toString());</span>
    }

<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (grouped) {</span>
<span class="fc" id="L120">      state.writeEndElement(); // xs:sequence</span>
<span class="fc" id="L121">      state.writeEndElement(); // xs:complexType</span>
<span class="fc" id="L122">      state.writeEndElement(); // xs:element</span>
    }
<span class="fc" id="L124">  }</span>

  protected void generateNamedModelInstance(
      @NonNull INamedModelInstanceAbsolute modelInstance,
      boolean grouped,
      @NonNull XmlGenerationState state) throws XMLStreamException {
<span class="fc" id="L130">    state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;element&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc" id="L132">    state.writeAttribute(&quot;name&quot;, modelInstance.getEffectiveName());</span>

    // state.generateElementNameOrRef(modelInstance);

<span class="fc bfc" id="L136" title="All 4 branches covered.">    if (!grouped &amp;&amp; modelInstance.getMinOccurs() != 1) {</span>
<span class="fc" id="L137">      state.writeAttribute(&quot;minOccurs&quot;, ObjectUtils.notNull(Integer.toString(modelInstance.getMinOccurs())));</span>
    }

<span class="fc bfc" id="L140" title="All 2 branches covered.">    if (modelInstance.getMaxOccurs() != 1) {</span>
<span class="fc" id="L141">      state.writeAttribute(&quot;maxOccurs&quot;,</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">          modelInstance.getMaxOccurs() == -1 ? &quot;unbounded&quot;</span>
<span class="fc" id="L143">              : ObjectUtils.notNull(Integer.toString(modelInstance.getMaxOccurs())));</span>
    }

<span class="fc" id="L146">    IXmlType type = state.getXmlForDefinition(modelInstance.getDefinition());</span>
<span class="fc bfc" id="L147" title="All 4 branches covered.">    if (type.isGeneratedType(state) &amp;&amp; type.isInline(state)) {</span>
<span class="fc" id="L148">      DocumentationGenerator.generateDocumentation(modelInstance, state);</span>
<span class="fc" id="L149">      type.generate(state);</span>
    } else {
<span class="fc" id="L151">      state.writeAttribute(&quot;type&quot;, type.getTypeReference());</span>
<span class="fc" id="L152">      DocumentationGenerator.generateDocumentation(modelInstance, state);</span>
    }
<span class="fc" id="L154">    state.writeEndElement(); // xs:element</span>
<span class="fc" id="L155">  }</span>

  protected static void generateUnwrappedFieldInstance(
      @NonNull IFieldInstanceAbsolute fieldInstance,
      boolean grouped,
      @NonNull XmlGenerationState state) throws XMLStreamException {

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">    if (!MarkupDataTypeProvider.MARKUP_MULTILINE.equals(fieldInstance.getDefinition().getJavaTypeAdapter())) {</span>
<span class="nc" id="L163">      throw new IllegalStateException();</span>
    }

<span class="fc" id="L166">    state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;group&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc" id="L168">    state.writeAttribute(&quot;ref&quot;, &quot;blockElementGroup&quot;);</span>

    // minOccurs=1 is the schema default
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">    if (!grouped &amp;&amp; fieldInstance.getMinOccurs() != 1) {</span>
<span class="fc" id="L172">      state.writeAttribute(&quot;minOccurs&quot;, ObjectUtils.notNull(Integer.toString(fieldInstance.getMinOccurs())));</span>
    }

    // if (fieldInstance.getMaxOccurs() != 1) {
    // state.writeAttribute(&quot;maxOccurs&quot;,
    // fieldInstance.getMaxOccurs() == -1 ? &quot;unbounded&quot;
    // : ObjectUtils.notNull(Integer.toString(fieldInstance.getMaxOccurs())));
    // }

    // unwrapped fields always have a max-occurance of 1. Since the markup multiline
    // is unbounded, this
    // value is unbounded.
<span class="fc" id="L184">    state.writeAttribute(&quot;maxOccurs&quot;, &quot;unbounded&quot;);</span>

<span class="fc" id="L186">    DocumentationGenerator.generateDocumentation(fieldInstance, state);</span>

<span class="fc" id="L188">    state.writeEndElement(); // xs:group</span>
<span class="fc" id="L189">  }</span>

  protected void generateChoiceModelInstance(
      @NonNull IChoiceInstance choice,
      @NonNull XmlGenerationState state) throws XMLStreamException {
<span class="fc" id="L194">    state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;choice&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">    for (IModelInstanceAbsolute instance : choice.getModelInstances()) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">      assert instance != null;</span>

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">      if (instance instanceof IChoiceInstance) {</span>
<span class="nc" id="L200">        generateChoiceModelInstance((IChoiceInstance) instance, state);</span>
      } else {
<span class="fc" id="L202">        generateModelInstance(instance, state);</span>
      }
<span class="fc" id="L204">    }</span>

<span class="fc" id="L206">    state.writeEndElement(); // xs:choice</span>
<span class="fc" id="L207">  }</span>

  private void generateChoiceGroupInstance(IChoiceGroupInstance choiceGroup, XmlGenerationState state)
      throws XMLStreamException {
<span class="fc" id="L211">    state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;choice&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc" id="L213">    int min = choiceGroup.getMinOccurs();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (min != 1) {</span>
<span class="fc" id="L215">      state.writeAttribute(&quot;minOccurs&quot;, ObjectUtils.notNull(Integer.toString(min)));</span>
    }

<span class="fc" id="L218">    int max = choiceGroup.getMaxOccurs();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (max &lt; 0) {</span>
<span class="fc" id="L220">      state.writeAttribute(&quot;maxOccurs&quot;, &quot;unbounded&quot;);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    } else if (max &gt; 1) {</span>
<span class="nc" id="L222">      state.writeAttribute(&quot;maxOccurs&quot;, ObjectUtils.notNull(Integer.toString(max)));</span>
    }

<span class="fc bfc" id="L225" title="All 2 branches covered.">    for (INamedModelInstanceGrouped instance : choiceGroup.getNamedModelInstances()) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">      assert instance != null;</span>

<span class="fc" id="L228">      generateGroupedNamedModelInstance(instance, state);</span>
<span class="fc" id="L229">    }</span>

<span class="fc" id="L231">    state.writeEndElement(); // xs:choice</span>
<span class="fc" id="L232">  }</span>

  protected void generateGroupedNamedModelInstance(
      @NonNull INamedModelInstanceGrouped instance,
      @NonNull XmlGenerationState state) throws XMLStreamException {
<span class="fc" id="L237">    state.writeStartElement(XmlSchemaGenerator.PREFIX_XML_SCHEMA, &quot;element&quot;, XmlSchemaGenerator.NS_XML_SCHEMA);</span>

<span class="fc" id="L239">    state.writeAttribute(&quot;name&quot;, instance.getEffectiveName());</span>

    // state.generateElementNameOrRef(modelInstance);

<span class="fc" id="L243">    IXmlType type = state.getXmlForDefinition(instance.getDefinition());</span>
<span class="pc bpc" id="L244" title="1 of 4 branches missed.">    if (type.isGeneratedType(state) &amp;&amp; type.isInline(state)) {</span>
<span class="fc" id="L245">      DocumentationGenerator.generateDocumentation(instance, state);</span>
<span class="fc" id="L246">      type.generate(state);</span>
    } else {
<span class="fc" id="L248">      state.writeAttribute(&quot;type&quot;, type.getTypeReference());</span>
<span class="fc" id="L249">      DocumentationGenerator.generateDocumentation(instance, state);</span>
    }
<span class="fc" id="L251">    state.writeEndElement(); // xs:element</span>
<span class="fc" id="L252">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>