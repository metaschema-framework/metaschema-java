<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperationFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.function</a> &gt; <span class="el_source">OperationFunctions.java</span></div><h1>OperationFunctions.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.function; // NOPMD - intentional

import gov.nist.secauto.metaschema.core.metapath.InvalidTypeMetapathException;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IAnyAtomicItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IBase64BinaryItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IBooleanItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IDateItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IDateTimeItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IDayTimeDurationItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IDecimalItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IDurationItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IIntegerItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.INumericItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IYearMonthDurationItem;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Duration;
import java.time.Period;
import java.time.ZonedDateTime;
import java.time.temporal.TemporalAmount;
import java.util.Set;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

public final class OperationFunctions { // NOPMD - intentional
  @NonNull
<span class="fc" id="L35">  public static final Set&lt;Class&lt;? extends IAnyAtomicItem&gt;&gt; AGGREGATE_MATH_TYPES = ObjectUtils.notNull(Set.of(</span>
      IDayTimeDurationItem.class,
      IYearMonthDurationItem.class,
      INumericItem.class));

  private OperationFunctions() {
    // disable
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-yearMonthDuration-to-date&quot;&gt;op:add-yearMonthDuration-to-date&lt;/a&gt;.
   *
   * @param instant
   *          a point in time
   * @param duration
   *          the duration to add
   * @return the result of adding the duration to the date
   */
  @NonNull
  public static IDateItem opAddYearMonthDurationToDate(@NonNull IDateItem instant,
      @NonNull IYearMonthDurationItem duration) {
<span class="nc" id="L57">    return addDurationToDate(instant.asZonedDateTime(), duration.asPeriod());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-dayTimeDuration-to-date&quot;&gt;op:add-dayTimeDuration-to-date&lt;/a&gt;.
   *
   * @param instant
   *          a point in time
   * @param duration
   *          the duration to add
   * @return the result of adding the duration to the date
   */
  @NonNull
  public static IDateItem opAddDayTimeDurationToDate(@NonNull IDateItem instant,
      @NonNull IDayTimeDurationItem duration) {
<span class="nc" id="L73">    return addDurationToDate(instant.asZonedDateTime(), duration.asDuration());</span>
  }

  @NonNull
  private static IDateItem addDurationToDate(@NonNull ZonedDateTime dateTime, @NonNull TemporalAmount duration) {
    ZonedDateTime result;
    try {
<span class="nc" id="L80">      result = dateTime.plus(duration);</span>
<span class="nc" id="L81">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L82">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="nc" id="L83">    }</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    assert result != null;</span>
<span class="nc" id="L85">    return IDateItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-yearMonthDurations&quot;&gt;op:add-yearMonthDurations&lt;/a&gt;.
   *
   * @param arg1
   *          the first duration
   * @param arg2
   *          the second duration
   * @return the sum of two duration values
   */
  @NonNull
  public static IYearMonthDurationItem opAddYearMonthDurations(
      @NonNull IYearMonthDurationItem arg1,
      @NonNull IYearMonthDurationItem arg2) {
<span class="fc" id="L102">    Period duration1 = arg1.asPeriod();</span>
<span class="fc" id="L103">    Period duration2 = arg2.asPeriod();</span>

    Period result;
    try {
<span class="fc" id="L107">      result = duration1.plus(duration2);</span>
<span class="nc" id="L108">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L109">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="fc" id="L110">    }</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    assert result != null;</span>
<span class="fc" id="L112">    return IYearMonthDurationItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-dayTimeDurations&quot;&gt;op:add-dayTimeDurations&lt;/a&gt;.
   *
   * @param arg1
   *          the first duration
   * @param arg2
   *          the second duration
   * @return the sum of two duration values
   */
  @NonNull
  public static IDayTimeDurationItem opAddDayTimeDurations(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull IDayTimeDurationItem arg2) {
<span class="fc" id="L129">    Duration duration1 = arg1.asDuration();</span>
<span class="fc" id="L130">    Duration duration2 = arg2.asDuration();</span>

    Duration result;
    try {
<span class="fc" id="L134">      result = duration1.plus(duration2);</span>
<span class="nc" id="L135">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L136">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="fc" id="L137">    }</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    assert result != null;</span>
<span class="fc" id="L139">    return IDayTimeDurationItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-yearMonthDuration-to-dateTime&quot;&gt;op:add-yearMonthDuration-to-dateTime&lt;/a&gt;.
   *
   * @param instant
   *          a point in time
   * @param duration
   *          the duration to add
   * @return the result of adding the duration to the date
   */
  @NonNull
  public static IDateTimeItem opAddYearMonthDurationToDateTime(
      @NonNull IDateTimeItem instant,
      @NonNull IYearMonthDurationItem duration) {
    ZonedDateTime result;
    try {
<span class="nc" id="L158">      result = instant.asZonedDateTime().plus(duration.asPeriod());</span>
<span class="nc" id="L159">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L160">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="nc" id="L161">    }</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">    assert result != null;</span>
<span class="nc" id="L163">    return IDateTimeItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-add-dayTimeDuration-to-dateTime&quot;&gt;op:add-dayTimeDuration-to-dateTime&lt;/a&gt;.
   *
   * @param instant
   *          a point in time
   * @param duration
   *          the duration to add
   * @return the result of adding the duration to the date
   */
  @NonNull
  public static IDateTimeItem opAddDayTimeDurationToDateTime(
      @NonNull IDateTimeItem instant,
      @NonNull IDayTimeDurationItem duration) {
    ZonedDateTime result;
    try {
<span class="nc" id="L182">      result = instant.asZonedDateTime().plus(duration.asDuration());</span>
<span class="nc" id="L183">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L184">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="nc" id="L185">    }</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    assert result != null;</span>
<span class="nc" id="L187">    return IDateTimeItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dates&quot;&gt;op:subtract-dates&lt;/a&gt;.
   *
   * @param date1
   *          the first point in time
   * @param date2
   *          the second point in time
   * @return the elapsed time between the starting instant and ending instant
   */
  @NonNull
  public static IDayTimeDurationItem opSubtractDates(@NonNull IDateItem date1, @NonNull IDateItem date2) {
<span class="nc" id="L202">    return between(date1.asZonedDateTime(), date2.asZonedDateTime());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-yearMonthDuration-from-date&quot;&gt;op:subtract-yearMonthDuration-from-date&lt;/a&gt;.
   *
   * @param date
   *          a point in time
   * @param duration
   *          the duration to subtract
   * @return the result of subtracting the duration from the date
   */
  @NonNull
  public static IDateItem opSubtractYearMonthDurationFromDate(
      @NonNull IDateItem date,
      @NonNull IYearMonthDurationItem duration) {
<span class="nc" id="L219">    return subtractDurationFromDate(date.asZonedDateTime(), duration.asPeriod());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dayTimeDuration-from-date&quot;&gt;op:subtract-dayTimeDuration-from-date&lt;/a&gt;.
   *
   * @param date
   *          a point in time
   * @param duration
   *          the duration to subtract
   * @return the result of subtracting the duration from the date
   */
  @NonNull
  public static IDateItem opSubtractDayTimeDurationFromDate(
      @NonNull IDateItem date,
      @NonNull IDayTimeDurationItem duration) {
<span class="nc" id="L236">    return subtractDurationFromDate(date.asZonedDateTime(), duration.asDuration());</span>
  }

  @NonNull
  private static IDateItem subtractDurationFromDate(
      @NonNull ZonedDateTime dateTime,
      @NonNull TemporalAmount duration) {
    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L245">    ZonedDateTime result = dateTime.minus(duration);</span>
<span class="nc" id="L246">    return IDateItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-yearMonthDurations&quot;&gt;op:subtract-yearMonthDurations&lt;/a&gt;.
   *
   * @param arg1
   *          the first duration
   * @param arg2
   *          the second duration
   * @return the result of subtracting the second duration from the first
   */
  @NonNull
  public static IYearMonthDurationItem opSubtractYearMonthDurations(
      @NonNull IYearMonthDurationItem arg1,
      @NonNull IYearMonthDurationItem arg2) {
<span class="nc" id="L263">    Period duration1 = arg1.asPeriod();</span>
<span class="nc" id="L264">    Period duration2 = arg2.asPeriod();</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L268">    Period duration = duration1.minus(duration2);</span>
<span class="nc" id="L269">    return IYearMonthDurationItem.valueOf(duration);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dayTimeDurations&quot;&gt;op:subtract-dayTimeDurations&lt;/a&gt;.
   *
   * @param arg1
   *          the first duration
   * @param arg2
   *          the second duration
   * @return the result of subtracting the second duration from the first
   */
  @NonNull
  public static IDayTimeDurationItem opSubtractDayTimeDurations(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull IDayTimeDurationItem arg2) {
<span class="nc" id="L286">    Duration duration1 = arg1.asDuration();</span>
<span class="nc" id="L287">    Duration duration2 = arg2.asDuration();</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L291">    Duration duration = duration1.minus(duration2);</span>
<span class="nc" id="L292">    return IDayTimeDurationItem.valueOf(duration);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dateTimes&quot;&gt;op:subtract-dateTimes&lt;/a&gt;.
   *
   * @param time1
   *          the first point in time
   * @param time2
   *          the second point in time
   * @return the duration the occurred between the two points in time
   */
  @NonNull
  public static IDayTimeDurationItem opSubtractDateTimes(@NonNull IDateTimeItem time1, @NonNull IDateTimeItem time2) {
<span class="nc" id="L307">    return between(time1.asZonedDateTime(), time2.asZonedDateTime());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dateTimes&quot;&gt;op:subtract-dateTimes&lt;/a&gt;.
   *
   * @param time1
   *          the first point in time
   * @param time2
   *          the second point in time
   * @return the duration the occurred between the two points in time
   */
  @NonNull
  private static IDayTimeDurationItem between(@NonNull ZonedDateTime time1, @NonNull ZonedDateTime time2) {
    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L324">    Duration between = Duration.between(time1, time2);</span>
<span class="nc" id="L325">    return IDayTimeDurationItem.valueOf(between);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-yearMonthDuration-from-dateTime&quot;&gt;op:subtract-yearMonthDuration-from-dateTime&lt;/a&gt;.
   *
   * @param moment
   *          a point in time
   * @param duration
   *          the duration to subtract
   * @return the result of subtracting the duration from a point in time
   */
  @NonNull
  public static IDateTimeItem opSubtractYearMonthDurationFromDateTime(
      @NonNull IDateTimeItem moment,
      @NonNull IYearMonthDurationItem duration) {
    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L344">    ZonedDateTime dateTime = moment.asZonedDateTime().minus(duration.asPeriod());</span>
<span class="nc" id="L345">    return IDateTimeItem.valueOf(dateTime);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-subtract-dayTimeDuration-from-dateTime&quot;&gt;op:subtract-dayTimeDuration-from-dateTime&lt;/a&gt;.
   *
   * @param moment
   *          a point in time
   * @param duration
   *          the duration to subtract
   * @return the result of subtracting the duration from a point in time
   */
  @NonNull
  public static IDateTimeItem opSubtractDayTimeDurationFromDateTime(
      @NonNull IDateTimeItem moment,
      @NonNull IDayTimeDurationItem duration) {

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L365">    ZonedDateTime dateTime = moment.asZonedDateTime().plus(duration.asDuration());</span>
<span class="nc" id="L366">    return IDateTimeItem.valueOf(dateTime);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-multiply-yearMonthDuration&quot;&gt;op:multiply-yearMonthDuration&lt;/a&gt;.
   *
   * @param arg1
   *          the duration value
   * @param arg2
   *          the number to multiply by
   * @return the result of multiplying a {@link IYearMonthDurationItem} by a
   *         number
   */
  @NonNull
  public static IYearMonthDurationItem opMultiplyYearMonthDuration(
      @NonNull IYearMonthDurationItem arg1,
      @NonNull INumericItem arg2) {
    int arg2Int;
    try {
<span class="nc" id="L386">      arg2Int = FunctionUtils.asInteger(arg2.round());</span>
<span class="nc" id="L387">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L388">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="nc" id="L389">    }</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L393">    Period period = arg1.asPeriod().multipliedBy(arg2Int);</span>
<span class="nc" id="L394">    return IYearMonthDurationItem.valueOf(period);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-multiply-dayTimeDuration&quot;&gt;op:multiply-dayTimeDuration&lt;/a&gt;.
   *
   * @param arg1
   *          the duration value
   * @param arg2
   *          the number to multiply by
   * @return the result of multiplying a {@link IDayTimeDurationItem} by a number
   */
  @NonNull
  public static IDayTimeDurationItem opMultiplyDayTimeDuration(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull INumericItem arg2) {
    long arg2Long;
    try {
<span class="nc" id="L413">      arg2Long = FunctionUtils.asLong(arg2.round());</span>
<span class="nc" id="L414">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L415">      throw new ArithmeticFunctionException(ArithmeticFunctionException.OVERFLOW_UNDERFLOW_ERROR, ex);</span>
<span class="nc" id="L416">    }</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L420">    Duration duration = arg1.asDuration().multipliedBy(arg2Long);</span>
<span class="nc" id="L421">    return IDayTimeDurationItem.valueOf(duration);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-divide-yearMonthDuration&quot;&gt;op:divide-yearMonthDuration&lt;/a&gt;.
   *
   * @param arg1
   *          the duration value
   * @param arg2
   *          the number to divide by
   * @return the result of dividing a {@link IYearMonthDurationItem} by a number
   */
  @NonNull
  public static IYearMonthDurationItem opDivideYearMonthDuration(
      @NonNull IYearMonthDurationItem arg1,
      @NonNull INumericItem arg2) {
<span class="fc" id="L438">    IIntegerItem totalMonths = IIntegerItem.valueOf(arg1.asPeriod().toTotalMonths());</span>
<span class="fc" id="L439">    IIntegerItem result = opNumericIntegerDivide(totalMonths, arg2);</span>
    int months;
    try {
<span class="fc" id="L442">      months = FunctionUtils.asInteger(result.asInteger());</span>
<span class="nc" id="L443">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L444">      throw new DateTimeFunctionException(DateTimeFunctionException.DURATION_OVERFLOW_UNDERFLOW_ERROR,</span>
          &quot;Overflow/underflow in duration operation.&quot;, ex);
<span class="fc" id="L446">    }</span>
<span class="fc" id="L447">    int years = months / 12;</span>
<span class="fc" id="L448">    months = months % 12;</span>
<span class="fc" id="L449">    return IYearMonthDurationItem.valueOf(years, months);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-divide-dayTimeDuration&quot;&gt;op:divide-dayTimeDuration&lt;/a&gt;.
   *
   * @param arg1
   *          the duration value
   * @param arg2
   *          the number to divide by
   * @return the result of dividing a {@link IDayTimeDurationItem} by a number
   */
  @NonNull
  public static IDayTimeDurationItem opDivideDayTimeDuration(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull INumericItem arg2) {
    try {
      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L469">      Duration duration = arg1.asDuration().dividedBy(FunctionUtils.asLong(arg2.round()));</span>
<span class="fc" id="L470">      return IDayTimeDurationItem.valueOf(duration);</span>
<span class="nc" id="L471">    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L472">      throw new ArithmeticFunctionException(ArithmeticFunctionException.DIVISION_BY_ZERO, &quot;Division by zero&quot;, ex);</span>
    }
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-divide-dayTimeDuration-by-dayTimeDuration&quot;&gt;op:divide-dayTimeDuration-by-dayTimeDuration&lt;/a&gt;.
   *
   * @param arg1
   *          the first duration value
   * @param arg2
   *          the second duration value
   * @return the ratio of two {@link IDayTimeDurationItem} values, as a decimal
   *         number
   */
  @NonNull
  public static IDecimalItem opDivideDayTimeDurationByDayTimeDuration(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull IDayTimeDurationItem arg2) {
<span class="nc" id="L491">    return IDecimalItem.cast(</span>
<span class="nc" id="L492">        opNumericDivide(</span>
<span class="nc" id="L493">            IDecimalItem.valueOf(arg1.asSeconds()),</span>
<span class="nc" id="L494">            IDecimalItem.valueOf(arg2.asSeconds())));</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-date-equal&quot;&gt;op:date-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is the same instant in time as the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateEqual(@NonNull IDateItem arg1, @NonNull IDateItem arg2) {
<span class="nc" id="L510">    return IBooleanItem.valueOf(arg1.asZonedDateTime().equals(arg2.asZonedDateTime()));</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-dateTime-equal&quot;&gt;op:dateTime-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is the same instant in time as the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateTimeEqual(@NonNull IDateTimeItem arg1, @NonNull IDateTimeItem arg2) {
<span class="nc" id="L526">    return IBooleanItem.valueOf(arg1.asZonedDateTime().equals(arg2.asZonedDateTime()));</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-duration-equal&quot;&gt;op:duration-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is the same duration as the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDurationEqual(@NonNull IDurationItem arg1, @NonNull IDurationItem arg2) {
<span class="nc bnc" id="L542" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.compareTo(arg2) == 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-base64Binary-equal&quot;&gt;op:base64Binary-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is equal to the second, or
   *         {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBase64BinaryEqual(@NonNull IBase64BinaryItem arg1, @NonNull IBase64BinaryItem arg2) {
<span class="nc" id="L558">    return IBooleanItem.valueOf(arg1.asByteBuffer().equals(arg2.asByteBuffer()));</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-date-greater-than&quot;&gt;op:date-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a later instant in time than
   *         the second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateGreaterThan(@NonNull IDateItem arg1, @NonNull IDateItem arg2) {
<span class="nc bnc" id="L574" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.asZonedDateTime().compareTo(arg2.asZonedDateTime()) &gt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-dateTime-greater-than&quot;&gt;op:dateTime-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a later instant in time than
   *         the second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateTimeGreaterThan(@NonNull IDateTimeItem arg1, @NonNull IDateTimeItem arg2) {
<span class="nc bnc" id="L590" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.asZonedDateTime().compareTo(arg2.asZonedDateTime()) &gt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-yearMonthDuration-greater-than&quot;&gt;op:yearMonthDuration-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a longer duration than the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opYearMonthDurationGreaterThan(
      @NonNull IYearMonthDurationItem arg1,
      @NonNull IYearMonthDurationItem arg2) {
<span class="nc" id="L608">    Period p1 = arg1.asPeriod();</span>
<span class="nc" id="L609">    Period p2 = arg2.asPeriod();</span>

    // this is only an approximation
<span class="nc bnc" id="L612" title="All 2 branches missed.">    return IBooleanItem.valueOf(p1.toTotalMonths() &gt; p2.toTotalMonths());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-dayTimeDuration-greater-than&quot;&gt;op:dayTimeDuration-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a longer duration than the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDayTimeDurationGreaterThan(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull IDayTimeDurationItem arg2) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.compareTo(arg2) &gt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-base64Binary-greater-than&quot;&gt;op:base64Binary-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is greater than the second, or
   *         {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBase64BinaryGreaterThan(
      @NonNull IBase64BinaryItem arg1,
      @NonNull IBase64BinaryItem arg2) {
<span class="nc bnc" id="L648" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.compareTo(arg2) &gt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-date-less-than&quot;&gt;op:date-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is an earlier instant in time than
   *         the second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateLessThan(
      @NonNull IDateItem arg1,
      @NonNull IDateItem arg2) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.asZonedDateTime().compareTo(arg2.asZonedDateTime()) &lt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-dateTime-less-than&quot;&gt;op:dateTime-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is an earlier instant in time than
   *         the second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDateTimeLessThan(
      @NonNull IDateTimeItem arg1,
      @NonNull IDateTimeItem arg2) {
<span class="nc bnc" id="L684" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.asZonedDateTime().compareTo(arg2.asZonedDateTime()) &lt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-yearMonthDuration-less-than&quot;&gt;op:yearMonthDuration-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a shorter duration than the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opYearMonthDurationLessThan(@NonNull IYearMonthDurationItem arg1,
      @NonNull IYearMonthDurationItem arg2) {
<span class="nc" id="L701">    Period p1 = arg1.asPeriod();</span>
<span class="nc" id="L702">    Period p2 = arg2.asPeriod();</span>

    // this is only an approximation
<span class="nc bnc" id="L705" title="All 2 branches missed.">    return IBooleanItem.valueOf(p1.toTotalMonths() &lt; p2.toTotalMonths());</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-dayTimeDuration-less-than&quot;&gt;op:dayTimeDuration-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is a shorter duration than the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opDayTimeDurationLessThan(
      @NonNull IDayTimeDurationItem arg1,
      @NonNull IDayTimeDurationItem arg2) {
<span class="nc bnc" id="L723" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.compareTo(arg2) &lt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-base64Binary-less-than&quot;&gt;op:base64Binary-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first value
   * @param arg2
   *          the second value
   * @return {@code true} if the first argument is less than the second, or
   *         {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBase64BinaryLessThan(
      @NonNull IBase64BinaryItem arg1,
      @NonNull IBase64BinaryItem arg2) {
<span class="nc bnc" id="L741" title="All 2 branches missed.">    return IBooleanItem.valueOf(arg1.compareTo(arg2) &lt; 0);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-add&quot;&gt;op:numeric-add&lt;/a&gt;.
   *
   * @param left
   *          the first number
   * @param right
   *          the second number
   * @return the result of adding the second number to the first number
   */
  @NonNull
  public static INumericItem opNumericAdd(@NonNull INumericItem left, @NonNull INumericItem right) {
    INumericItem retval;
<span class="pc bpc" id="L757" title="3 of 4 branches missed.">    if (left instanceof IIntegerItem || right instanceof IIntegerItem) {</span>
      // create an integer result
<span class="fc" id="L759">      BigInteger integerLeft = left.asInteger();</span>
<span class="fc" id="L760">      BigInteger integerRight = right.asInteger();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L764">      BigInteger result = integerLeft.add(integerRight);</span>
<span class="fc" id="L765">      retval = IIntegerItem.valueOf(result);</span>
<span class="fc" id="L766">    } else {</span>
      // create a decimal result
<span class="nc" id="L768">      BigDecimal decimalLeft = left.asDecimal();</span>
<span class="nc" id="L769">      BigDecimal decimalRight = right.asDecimal();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L773">      BigDecimal result = decimalLeft.add(decimalRight, FunctionUtils.MATH_CONTEXT);</span>
<span class="nc" id="L774">      retval = IDecimalItem.valueOf(result);</span>
    }
<span class="fc" id="L776">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-subtract&quot;&gt;op:numeric-subtract&lt;/a&gt;.
   *
   * @param left
   *          the first number
   * @param right
   *          the second number
   * @return the result of subtracting the second number from the first number
   */
  @NonNull
  public static INumericItem opNumericSubtract(@NonNull INumericItem left, @NonNull INumericItem right) {
    INumericItem retval;
<span class="nc bnc" id="L792" title="All 4 branches missed.">    if (left instanceof IIntegerItem || right instanceof IIntegerItem) {</span>
      // create an integer result
<span class="nc" id="L794">      BigInteger integerLeft = left.asInteger();</span>
<span class="nc" id="L795">      BigInteger integerRight = right.asInteger();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L799">      BigInteger result = integerLeft.subtract(integerRight);</span>
<span class="nc" id="L800">      retval = IIntegerItem.valueOf(result);</span>
<span class="nc" id="L801">    } else {</span>
      // create a decimal result
<span class="nc" id="L803">      BigDecimal decimalLeft = left.asDecimal();</span>
<span class="nc" id="L804">      BigDecimal decimalRight = right.asDecimal();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L808">      BigDecimal result = decimalLeft.subtract(decimalRight, FunctionUtils.MATH_CONTEXT);</span>
<span class="nc" id="L809">      retval = IDecimalItem.valueOf(result);</span>
    }
<span class="nc" id="L811">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-multiply&quot;&gt;op:numeric-multiply&lt;/a&gt;.
   *
   * @param left
   *          the first number
   * @param right
   *          the second number
   * @return the result of multiplying the first number by the second number
   */
  @NonNull
  public static INumericItem opNumericMultiply(@NonNull INumericItem left, @NonNull INumericItem right) {
    INumericItem retval;
<span class="nc bnc" id="L827" title="All 4 branches missed.">    if (left instanceof IIntegerItem || right instanceof IIntegerItem) {</span>
      // create an integer result
      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L831">      BigInteger result = left.asInteger().multiply(right.asInteger());</span>
<span class="nc" id="L832">      retval = IIntegerItem.valueOf(result);</span>
<span class="nc" id="L833">    } else {</span>
      // create a decimal result
<span class="nc" id="L835">      BigDecimal decimalLeft = left.asDecimal();</span>
<span class="nc" id="L836">      BigDecimal decimalRight = right.asDecimal();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L840">      BigDecimal result = decimalLeft.multiply(decimalRight, FunctionUtils.MATH_CONTEXT);</span>
<span class="nc" id="L841">      retval = IDecimalItem.valueOf(result);</span>
    }
<span class="nc" id="L843">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-divide&quot;&gt;op:numeric-divide&lt;/a&gt;.
   *
   * @param dividend
   *          the number to be divided
   * @param divisor
   *          the number to divide by
   * @return the quotient
   */
  @NonNull
  public static IDecimalItem opNumericDivide(@NonNull INumericItem dividend, @NonNull INumericItem divisor) {
    // create a decimal result
<span class="fc" id="L859">    BigDecimal decimalDivisor = divisor.asDecimal();</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">    if (BigDecimal.ZERO.equals(decimalDivisor)) {</span>
<span class="nc" id="L862">      throw new ArithmeticFunctionException(ArithmeticFunctionException.DIVISION_BY_ZERO,</span>
          ArithmeticFunctionException.DIVISION_BY_ZERO_MESSAGE);
    }

<span class="fc" id="L866">    BigDecimal decimalDividend = dividend.asDecimal();</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="fc" id="L870">    BigDecimal result = decimalDividend.divide(decimalDivisor, FunctionUtils.MATH_CONTEXT);</span>
<span class="fc" id="L871">    return IDecimalItem.valueOf(result);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-integer-divide&quot;&gt;op:numeric-integer-divide&lt;/a&gt;.
   *
   * @param dividend
   *          the number to be divided
   * @param divisor
   *          the number to divide by
   * @return the quotient
   */
  @NonNull
  public static IIntegerItem opNumericIntegerDivide(@NonNull INumericItem dividend, @NonNull INumericItem divisor) {
    IIntegerItem retval;
<span class="pc bpc" id="L887" title="1 of 4 branches missed.">    if (dividend instanceof IIntegerItem || divisor instanceof IIntegerItem) {</span>
      // create an integer result
<span class="fc" id="L889">      BigInteger integerDivisor = divisor.asInteger();</span>

<span class="pc bpc" id="L891" title="1 of 2 branches missed.">      if (BigInteger.ZERO.equals(integerDivisor)) {</span>
<span class="nc" id="L892">        throw new ArithmeticFunctionException(ArithmeticFunctionException.DIVISION_BY_ZERO,</span>
            ArithmeticFunctionException.DIVISION_BY_ZERO_MESSAGE);
      }

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L898">      BigInteger result = dividend.asInteger().divide(integerDivisor);</span>
<span class="fc" id="L899">      retval = IIntegerItem.valueOf(result);</span>
<span class="fc" id="L900">    } else {</span>
      // create a decimal result
<span class="nc" id="L902">      BigDecimal decimalDivisor = divisor.asDecimal();</span>

<span class="nc bnc" id="L904" title="All 2 branches missed.">      if (BigDecimal.ZERO.equals(decimalDivisor)) {</span>
<span class="nc" id="L905">        throw new ArithmeticFunctionException(ArithmeticFunctionException.DIVISION_BY_ZERO,</span>
            ArithmeticFunctionException.DIVISION_BY_ZERO_MESSAGE);
      }

<span class="nc" id="L909">      BigDecimal decimalDividend = dividend.asDecimal();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L913">      BigInteger result</span>
<span class="nc" id="L914">          = decimalDividend.divideToIntegralValue(decimalDivisor, FunctionUtils.MATH_CONTEXT).toBigInteger();</span>
<span class="nc" id="L915">      retval = IIntegerItem.valueOf(result);</span>
    }
<span class="fc" id="L917">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-mod&quot;&gt;op:numeric-mod&lt;/a&gt;.
   *
   * @param dividend
   *          the number to be divided
   * @param divisor
   *          the number to divide by
   * @return the remainder
   */
  @NonNull
  public static INumericItem opNumericMod(@NonNull INumericItem dividend, @NonNull INumericItem divisor) {
<span class="fc" id="L932">    BigDecimal decimalDivisor = divisor.asDecimal();</span>

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">    if (BigDecimal.ZERO.equals(decimalDivisor)) {</span>
<span class="nc" id="L935">      throw new ArithmeticFunctionException(ArithmeticFunctionException.DIVISION_BY_ZERO,</span>
          ArithmeticFunctionException.DIVISION_BY_ZERO_MESSAGE);
    }

<span class="fc" id="L939">    BigDecimal decimalDividend = dividend.asDecimal();</span>

    INumericItem retval;
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">    if (BigDecimal.ZERO.equals(decimalDividend)) {</span>
<span class="nc" id="L943">      retval = dividend;</span>
    } else {
      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L947">      BigDecimal result = decimalDividend.remainder(decimalDivisor, FunctionUtils.MATH_CONTEXT);</span>
<span class="fc" id="L948">      retval = IDecimalItem.valueOf(result);</span>
    }
<span class="fc" id="L950">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-unary-minus&quot;&gt;op:numeric-unary-minus&lt;/a&gt;.
   *
   * @param item
   *          the number whose sign is to be reversed
   * @return the number with a reversed sign
   */
  @NonNull
  public static INumericItem opNumericUnaryMinus(@NonNull INumericItem item) {
    INumericItem retval;
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">    if (item instanceof IIntegerItem) {</span>
      // create a decimal result
<span class="fc" id="L966">      BigInteger integer = item.asInteger();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L970">      BigInteger result = integer.negate();</span>
<span class="fc" id="L971">      retval = IIntegerItem.valueOf(result);</span>
<span class="pc bnc" id="L972" title="All 2 branches missed.">    } else if (item instanceof IDecimalItem) {</span>
      // create a decimal result
<span class="nc" id="L974">      BigDecimal decimal = item.asDecimal();</span>

      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="nc" id="L978">      BigDecimal result = decimal.negate(FunctionUtils.MATH_CONTEXT);</span>
<span class="nc" id="L979">      retval = IDecimalItem.valueOf(result);</span>
<span class="nc" id="L980">    } else {</span>
<span class="nc" id="L981">      throw new InvalidTypeMetapathException(item);</span>
    }
<span class="fc" id="L983">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-equal&quot;&gt;op:numeric-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first number to check for equality
   * @param arg2
   *          the second number to check for equality
   * @return {@code true} if the numbers are numerically equal or {@code false}
   *         otherwise
   */
  @NonNull
  public static IBooleanItem opNumericEqual(@Nullable INumericItem arg1, @Nullable INumericItem arg2) {
    IBooleanItem retval;
<span class="pc bpc" id="L1000" title="2 of 4 branches missed.">    if (arg1 == null || arg2 == null) {</span>
<span class="nc" id="L1001">      retval = IBooleanItem.FALSE;</span>
<span class="pc bpc" id="L1002" title="3 of 4 branches missed.">    } else if (arg1 instanceof IIntegerItem || arg2 instanceof IIntegerItem) {</span>
<span class="fc" id="L1003">      retval = IBooleanItem.valueOf(arg1.asInteger().equals(arg2.asInteger()));</span>
    } else {
<span class="nc" id="L1005">      retval = IBooleanItem.valueOf(arg1.asDecimal().equals(arg2.asDecimal()));</span>
    }
<span class="fc" id="L1007">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-greater-than&quot;&gt;op:numeric-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first number to check
   * @param arg2
   *          the second number to check
   * @return {@code true} if the first number is greater than or equal to the
   *         second, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opNumericGreaterThan(@Nullable INumericItem arg1, @Nullable INumericItem arg2) {
    IBooleanItem retval;
<span class="nc bnc" id="L1024" title="All 4 branches missed.">    if (arg1 == null || arg2 == null) {</span>
<span class="nc" id="L1025">      retval = IBooleanItem.FALSE;</span>
<span class="nc bnc" id="L1026" title="All 4 branches missed.">    } else if (arg1 instanceof IIntegerItem || arg2 instanceof IIntegerItem) {</span>
<span class="nc" id="L1027">      int result = arg1.asInteger().compareTo(arg2.asInteger());</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">      retval = IBooleanItem.valueOf(result &gt; 0);</span>
<span class="nc" id="L1029">    } else {</span>
<span class="nc" id="L1030">      int result = arg1.asDecimal().compareTo(arg2.asDecimal());</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">      retval = IBooleanItem.valueOf(result &gt; 0);</span>
    }
<span class="nc" id="L1033">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-numeric-less-than&quot;&gt;op:numeric-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first number to check
   * @param arg2
   *          the second number to check
   * @return {@code true} if the first number is less than or equal to the second,
   *         or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opNumericLessThan(@Nullable INumericItem arg1, @Nullable INumericItem arg2) {
    IBooleanItem retval;
<span class="nc bnc" id="L1050" title="All 4 branches missed.">    if (arg1 == null || arg2 == null) {</span>
<span class="nc" id="L1051">      retval = IBooleanItem.FALSE;</span>
<span class="nc bnc" id="L1052" title="All 4 branches missed.">    } else if (arg1 instanceof IIntegerItem || arg2 instanceof IIntegerItem) {</span>
<span class="nc" id="L1053">      int result = arg1.asInteger().compareTo(arg2.asInteger());</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">      retval = IBooleanItem.valueOf(result &lt; 0);</span>
<span class="nc" id="L1055">    } else {</span>
<span class="nc" id="L1056">      int result = arg1.asDecimal().compareTo(arg2.asDecimal());</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">      retval = IBooleanItem.valueOf(result &lt; 0);</span>
    }
<span class="nc" id="L1059">    return retval;</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-boolean-equal&quot;&gt;op:boolean-equal&lt;/a&gt;.
   *
   * @param arg1
   *          the first boolean to check
   * @param arg2
   *          the second boolean to check
   * @return {@code true} if the first boolean is equal to the second, or
   *         {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBooleanEqual(@Nullable IBooleanItem arg1, @Nullable IBooleanItem arg2) {
<span class="pc bpc" id="L1075" title="1 of 4 branches missed.">    boolean left = arg1 != null &amp;&amp; arg1.toBoolean();</span>
<span class="pc bpc" id="L1076" title="1 of 4 branches missed.">    boolean right = arg2 != null &amp;&amp; arg2.toBoolean();</span>

<span class="fc bfc" id="L1078" title="All 2 branches covered.">    return IBooleanItem.valueOf(left == right);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-boolean-greater-than&quot;&gt;op:boolean-greater-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first boolean to check
   * @param arg2
   *          the second boolean to check
   * @return {@code true} if the first argument is {@link IBooleanItem#TRUE} and
   *         the second is {@link IBooleanItem#FALSE}, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBooleanGreaterThan(@Nullable IBooleanItem arg1, @Nullable IBooleanItem arg2) {
<span class="pc bpc" id="L1094" title="2 of 4 branches missed.">    boolean left = arg1 != null &amp;&amp; arg1.toBoolean();</span>
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">    boolean right = arg2 != null &amp;&amp; arg2.toBoolean();</span>

<span class="pc bpc" id="L1097" title="2 of 4 branches missed.">    return IBooleanItem.valueOf(left &amp;&amp; !right);</span>
  }

  /**
   * Based on XPath 3.1 &lt;a href=
   * &quot;https://www.w3.org/TR/xpath-functions-31/#func-boolean-less-than&quot;&gt;op:boolean-less-than&lt;/a&gt;.
   *
   * @param arg1
   *          the first boolean to check
   * @param arg2
   *          the second boolean to check
   * @return {@code true} if the first argument is {@link IBooleanItem#FALSE} and
   *         the second is {@link IBooleanItem#TRUE}, or {@code false} otherwise
   */
  @NonNull
  public static IBooleanItem opBooleanLessThan(@Nullable IBooleanItem arg1, @Nullable IBooleanItem arg2) {
<span class="pc bpc" id="L1113" title="2 of 4 branches missed.">    boolean left = arg1 != null &amp;&amp; arg1.toBoolean();</span>
<span class="pc bpc" id="L1114" title="2 of 4 branches missed.">    boolean right = arg2 != null &amp;&amp; arg2.toBoolean();</span>

<span class="pc bpc" id="L1116" title="3 of 4 branches missed.">    return IBooleanItem.valueOf(!left &amp;&amp; right);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>