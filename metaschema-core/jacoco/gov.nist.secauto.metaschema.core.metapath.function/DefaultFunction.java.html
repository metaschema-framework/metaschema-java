<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultFunction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.function</a> &gt; <span class="el_source">DefaultFunction.java</span></div><h1>DefaultFunction.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.function;

import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.DynamicMetapathException;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.InvalidTypeMetapathException;
import gov.nist.secauto.metaschema.core.metapath.MetapathException;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnData;
import gov.nist.secauto.metaschema.core.metapath.item.IItem;
import gov.nist.secauto.metaschema.core.metapath.item.TypeSystem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IAnyAtomicItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IAnyUriItem;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IStringItem;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Provides a concrete implementation of a function call executor.
 */
<span class="fc" id="L35">public class DefaultFunction</span>
    extends AbstractFunction {
  // private static final Logger logger =
  // LogManager.getLogger(AbstractFunction.class);

  @NonNull
  private final Set&lt;FunctionProperty&gt; properties;
  @NonNull
  private final ISequenceType result;
  @NonNull
  private final IFunctionExecutor handler;

  /**
   * Construct a new function signature.
   *
   * @param name
   *          the name of the function
   * @param properties
   *          the characteristics of the function
   * @param arguments
   *          the argument signatures or an empty list
   * @param result
   *          the type of the result
   * @param handler
   *          the handler to call to execute the function
   */
  @SuppressWarnings({ &quot;null&quot;, &quot;PMD.LooseCoupling&quot; })
  DefaultFunction(
      @NonNull String name,
      @NonNull String namespace,
      @NonNull EnumSet&lt;FunctionProperty&gt; properties,
      @NonNull List&lt;IArgument&gt; arguments,
      @NonNull ISequenceType result,
      @NonNull IFunctionExecutor handler) {
<span class="fc" id="L69">    super(name, namespace, arguments);</span>
<span class="fc" id="L70">    this.properties = Collections.unmodifiableSet(properties);</span>
<span class="fc" id="L71">    this.result = result;</span>
<span class="fc" id="L72">    this.handler = handler;</span>
<span class="fc" id="L73">  }</span>

  @Override
  public Set&lt;FunctionProperty&gt; getProperties() {
<span class="fc" id="L77">    return properties;</span>
  }

  @Override
  public ISequenceType getResult() {
<span class="fc" id="L82">    return result;</span>
  }

  /**
   * Converts arguments in an attempt to align with the function's signature.
   *
   * @param function
   *          the function
   * @param parameters
   *          the argument parameters
   * @return the converted argument list
   */
  @NonNull
  public static List&lt;ISequence&lt;?&gt;&gt; convertArguments(
      @NonNull IFunction function,
      @NonNull List&lt;? extends ISequence&lt;?&gt;&gt; parameters) {
<span class="fc" id="L98">    @NonNull List&lt;ISequence&lt;?&gt;&gt; retval = new ArrayList&lt;&gt;(parameters.size());</span>

<span class="fc" id="L100">    Iterator&lt;IArgument&gt; argumentIterator = function.getArguments().iterator();</span>
<span class="fc" id="L101">    IArgument argument = null;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">    for (ISequence&lt;?&gt; parameter : parameters) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">      if (argumentIterator.hasNext()) {</span>
<span class="fc" id="L104">        argument = argumentIterator.next();</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">      } else if (!function.isArityUnbounded()) {</span>
<span class="nc" id="L106">        throw new InvalidTypeMetapathException(</span>
            null,
<span class="nc" id="L108">            String.format(&quot;argument signature doesn't match '%s'&quot;, function.toSignature()));</span>
      }

<span class="pc bpc" id="L111" title="1 of 2 branches missed.">      assert argument != null;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">      assert parameter != null;</span>

<span class="fc" id="L114">      retval.add(convertArgument(argument, parameter));</span>
<span class="fc" id="L115">    }</span>
<span class="fc" id="L116">    return retval;</span>
  }

  @NonNull
  private static ISequence&lt;?&gt; convertArgument(
      @NonNull IArgument argument,
      @NonNull ISequence&lt;?&gt; parameter) {
    // apply occurrence
<span class="fc" id="L124">    ISequence&lt;?&gt; retval = argument.getSequenceType().getOccurrence().getSequenceHandler().handle(parameter);</span>

    // apply function conversion and type promotion to the parameter
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (!retval.isEmpty()) {</span>
<span class="fc" id="L128">      retval = convertSequence(argument, retval);</span>

      // verify resulting values
<span class="fc" id="L131">      Class&lt;? extends IItem&gt; argumentClass = argument.getSequenceType().getType();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">      for (IItem item : retval.getValue()) {</span>
<span class="fc" id="L133">        Class&lt;? extends IItem&gt; itemClass = item.getClass();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (!argumentClass.isAssignableFrom(itemClass)) {</span>
<span class="nc" id="L135">          throw new InvalidTypeMetapathException(</span>
              item,
<span class="nc" id="L137">              String.format(&quot;The type '%s' is not a subtype of '%s'&quot;,</span>
<span class="nc" id="L138">                  TypeSystem.getName(itemClass),</span>
<span class="nc" id="L139">                  TypeSystem.getName(argumentClass)));</span>
        }
<span class="fc" id="L141">      }</span>
    }
<span class="fc" id="L143">    return retval;</span>
  }

  /**
   * Based on XPath 3.1
   * &lt;a href=&quot;https://www.w3.org/TR/xpath-31/#dt-function-conversion&quot;&gt;function
   * conversion&lt;/a&gt; rules.
   *
   * @param argument
   *          the function argument signature details
   * @param sequence
   *          the sequence to convert
   * @return the converted sequence
   */
  @NonNull
  protected static ISequence&lt;?&gt; convertSequence(@NonNull IArgument argument, @NonNull ISequence&lt;?&gt; sequence) {
<span class="fc" id="L159">    ISequenceType requiredSequenceType = argument.getSequenceType();</span>
<span class="fc" id="L160">    Class&lt;? extends IItem&gt; requiredSequenceTypeClass = requiredSequenceType.getType();</span>

<span class="fc" id="L162">    Stream&lt;? extends IItem&gt; stream = sequence.safeStream();</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (IAnyAtomicItem.class.isAssignableFrom(requiredSequenceTypeClass)) {</span>
<span class="fc" id="L165">      Stream&lt;? extends IAnyAtomicItem&gt; atomicStream = stream.flatMap(FnData::atomize);</span>

      // if (IUntypedAtomicItem.class.isInstance(item)) { // NOPMD
      // // TODO: apply cast to atomic type
      // }

<span class="fc bfc" id="L171" title="All 2 branches covered.">      if (IStringItem.class.equals(requiredSequenceTypeClass)) {</span>
        // promote URIs to strings if a string is required
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        atomicStream = atomicStream.map(item -&gt; IAnyUriItem.class.isInstance(item) ? IStringItem.cast(item) : item);</span>
      }

<span class="fc" id="L176">      stream = atomicStream;</span>
    }

<span class="fc" id="L179">    stream = stream.peek(item -&gt; {</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">      if (!requiredSequenceTypeClass.isInstance(item)) {</span>
<span class="nc" id="L181">        throw new InvalidTypeMetapathException(</span>
            item,
<span class="nc" id="L183">            String.format(&quot;The type '%s' is not a subtype of '%s'&quot;,</span>
<span class="nc" id="L184">                item.getClass().getName(),</span>
<span class="nc" id="L185">                requiredSequenceTypeClass.getName()));</span>
      }
<span class="fc" id="L187">    });</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    assert stream != null;</span>

<span class="fc" id="L190">    return ISequence.of(stream);</span>
  }

  private IItem getContextItem(@NonNull ISequence&lt;?&gt; focus) {
<span class="fc" id="L194">    IItem contextItem = null;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (isFocusDepenent()) {</span>
<span class="fc" id="L196">      contextItem = focus.getFirstItem(true);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (contextItem == null) {</span>
<span class="fc" id="L198">        throw new DynamicMetapathException(DynamicMetapathException.DYNAMIC_CONTEXT_ABSENT, &quot;The context is empty&quot;);</span>
      }
    }
<span class="fc" id="L201">    return contextItem;</span>
  }

  @Override
  public ISequence&lt;?&gt; execute(
      @NonNull List&lt;? extends ISequence&lt;?&gt;&gt; arguments,
      @NonNull DynamicContext dynamicContext,
      @NonNull ISequence&lt;?&gt; focus) {

    try {
<span class="fc" id="L211">      IItem contextItem = getContextItem(focus);</span>

<span class="fc" id="L213">      List&lt;ISequence&lt;?&gt;&gt; convertedArguments = convertArguments(this, arguments);</span>

<span class="fc" id="L215">      CallingContext callingContext = null;</span>
<span class="fc" id="L216">      ISequence&lt;?&gt; result = null;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (isDeterministic()) {</span>
        // check cache
<span class="fc" id="L219">        callingContext = new CallingContext(convertedArguments, contextItem);</span>
        // TODO: implement something like computeIfAbsent
        // attempt to get the result from the cache
<span class="fc" id="L222">        result = dynamicContext.getCachedResult(callingContext);</span>
      }

<span class="fc bfc" id="L225" title="All 2 branches covered.">      if (result == null) {</span>
<span class="fc" id="L226">        result = handler.execute(this, convertedArguments, dynamicContext, contextItem);</span>

<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (callingContext != null) {</span>
          // add result to cache
<span class="fc" id="L230">          dynamicContext.cacheResult(callingContext, result);</span>
        }
      }

      // logger.info(String.format(&quot;Executed function '%s' with arguments '%s'
      // producing result '%s'&quot;,
      // toSignature(), convertedArguments.toString(), result.asList().toString()));
<span class="fc" id="L237">      return result;</span>
<span class="fc" id="L238">    } catch (MetapathException ex) {</span>
<span class="fc" id="L239">      throw new MetapathException(String.format(&quot;Unable to execute function '%s'&quot;, toSignature()), ex);</span>
    }
  }

  @Override
  public int hashCode() {
<span class="fc" id="L245">    return Objects.hash(getQName(), getArguments(), handler, properties, result);</span>
  }

  @Override
  public boolean equals(Object obj) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">    if (this == obj) {</span>
<span class="fc" id="L251">      return true; // NOPMD - readability</span>
    }
<span class="nc bnc" id="L253" title="All 4 branches missed.">    if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L254">      return false; // NOPMD - readability</span>
    }
<span class="nc" id="L256">    DefaultFunction other = (DefaultFunction) obj;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    return Objects.equals(getQName(), other.getQName())</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        &amp;&amp; Objects.equals(getArguments(), other.getArguments())</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        &amp;&amp; Objects.equals(handler, other.handler)</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        &amp;&amp; Objects.equals(properties, other.properties)</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        &amp;&amp; Objects.equals(result, other.result);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L266">    return toSignature();</span>
  }

  public final class CallingContext {
    @Nullable
    private final IItem contextItem;
    @NonNull
    private final List&lt;ISequence&lt;?&gt;&gt; arguments;

    /**
     * Set up the execution context for this function.
     *
     * @param arguments
     *          the function arguments
     * @param contextItem
     *          the current node context
     */
<span class="fc" id="L283">    private CallingContext(@NonNull List&lt;ISequence&lt;?&gt;&gt; arguments, @Nullable IItem contextItem) {</span>
<span class="fc" id="L284">      this.contextItem = contextItem;</span>
<span class="fc" id="L285">      this.arguments = arguments;</span>
<span class="fc" id="L286">    }</span>

    /**
     * Get the function instance associated with the calling context.
     *
     * @return the function instance
     */
    @NonNull
    public DefaultFunction getFunction() {
<span class="fc" id="L295">      return DefaultFunction.this;</span>
    }

    /**
     * Get the node item focus associated with the calling context.
     *
     * @return the function instance
     */
    @Nullable
    public IItem getContextItem() {
<span class="nc" id="L305">      return contextItem;</span>
    }

    /**
     * Get the arguments associated with the calling context.
     *
     * @return the arguments
     */
    @NonNull
    public List&lt;ISequence&lt;?&gt;&gt; getArguments() {
<span class="nc" id="L315">      return arguments;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L320">      final int prime = 31;</span>
<span class="fc" id="L321">      int result = 1;</span>
<span class="fc" id="L322">      result = prime * result + getFunction().hashCode();</span>
<span class="fc" id="L323">      return prime * result + Objects.hash(contextItem, arguments);</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">      if (this == obj) {</span>
<span class="nc" id="L329">        return true; // NOPMD - readability</span>
      }
<span class="pc bpc" id="L331" title="2 of 4 branches missed.">      if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L332">        return false; // NOPMD - readability</span>
      }
<span class="fc" id="L334">      CallingContext other = (CallingContext) obj;</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">      if (!getFunction().equals(other.getFunction())) {</span>
<span class="nc" id="L336">        return false; // NOPMD - readability</span>
      }
<span class="pc bpc" id="L338" title="2 of 4 branches missed.">      return Objects.equals(arguments, other.arguments) &amp;&amp; Objects.equals(contextItem, other.contextItem);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>