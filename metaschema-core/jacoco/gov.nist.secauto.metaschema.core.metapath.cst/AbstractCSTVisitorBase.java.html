<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCSTVisitorBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.cst</a> &gt; <span class="el_source">AbstractCSTVisitorBase.java</span></div><h1>AbstractCSTVisitorBase.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.cst;

import gov.nist.secauto.metaschema.core.metapath.StaticContext;
import gov.nist.secauto.metaschema.core.metapath.StaticMetapathException;
import gov.nist.secauto.metaschema.core.metapath.antlr.AbstractAstVisitor;
import gov.nist.secauto.metaschema.core.metapath.antlr.Metapath10.EqnameContext;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

@SuppressWarnings({
    &quot;PMD.CouplingBetweenObjects&quot;
})
<span class="fc" id="L34">public abstract class AbstractCSTVisitorBase</span>
    extends AbstractAstVisitor&lt;IExpression&gt; {

<span class="fc" id="L37">  private static final Pattern QUALIFIED_NAME_PATTERN = Pattern.compile(&quot;^Q\\{([^}]*)\\}(.+)$&quot;);</span>

  /**
   * Get the QName for an
   * &lt;a href=&quot;https://www.w3.org/TR/xpath-31/#dt-expanded-qname&quot;&gt;expanded
   * QName&lt;/a&gt;.
   *
   * @param eqname
   *          the expanded QName
   * @param context
   *          the Metapath evaluation static context
   * @param requireNamespace
   *          if {@code true} require the resulting QName to have a namespace, or
   *          {@code false} otherwise
   * @return the QName
   * @throws StaticMetapathException
   *           if the expanded QName prefix is not bound or if the resulting
   *           namespace is invalid
   */
  @SuppressWarnings({ &quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.CognitiveComplexity&quot; })
  @NonNull
  static QName toQName(@NonNull EqnameContext eqname, @NonNull StaticContext context, boolean requireNamespace) {
    String namespaceUri;
    String localName;
    TerminalNode node;
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if ((node = eqname.URIQualifiedName()) != null) {</span>
      // BracedURILiteral - Q{uri}name -
      // https://www.w3.org/TR/xpath-31/#doc-xpath31-BracedURILiteral
<span class="nc" id="L65">      Matcher matcher = QUALIFIED_NAME_PATTERN.matcher(node.getText());</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      if (matcher.matches()) {</span>
<span class="nc" id="L67">        namespaceUri = matcher.group(1);</span>
<span class="nc" id="L68">        localName = matcher.group(2);</span>
      } else {
        // the syntax should always match above, since ANTLR is parsing it
<span class="nc" id="L71">        throw new IllegalStateException();</span>
      }
<span class="nc" id="L73">    } else {</span>
      String prefix;
<span class="nc" id="L75">      String[] tokens = eqname.getText().split(&quot;:&quot;, 2);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      if (tokens.length == 2) {</span>
        // lexical QName with prefix - prefix:name
        // https://www.w3.org/TR/xpath-31/#dt-qname
<span class="nc" id="L79">        prefix = ObjectUtils.notNull(tokens[0]);</span>
<span class="nc" id="L80">        localName = tokens[1];</span>
      } else {
        // lexical QName without prefix - name
        // https://www.w3.org/TR/xpath-31/#dt-qname
<span class="nc" id="L84">        prefix = &quot;&quot;;</span>
<span class="nc" id="L85">        localName = tokens[0];</span>
      }
<span class="nc" id="L87">      namespaceUri = context.lookupNamespaceForPrefix(prefix);</span>
<span class="nc bnc" id="L88" title="All 4 branches missed.">      if (namespaceUri == null &amp;&amp; requireNamespace) {</span>
<span class="nc" id="L89">        throw new StaticMetapathException(</span>
            StaticMetapathException.PREFIX_NOT_EXPANDABLE,
<span class="nc" id="L91">            String.format(&quot;The static context does not have a namespace URI configured for prefix '%s'.&quot;, prefix));</span>
      }
    }

    QName retval;
<span class="nc bnc" id="L96" title="All 2 branches missed.">    if (namespaceUri == null) {</span>
<span class="nc" id="L97">      retval = new QName(localName);</span>
    } else {
<span class="nc bnc" id="L99" title="All 2 branches missed.">      if (&quot;http://www.w3.org/2000/xmlns/&quot;.equals(namespaceUri)) {</span>
<span class="nc" id="L100">        throw new StaticMetapathException(StaticMetapathException.NAMESPACE_MISUSE,</span>
            &quot;The namespace of an expanded QName cannot be: http://www.w3.org/2000/xmlns/&quot;);
      }
<span class="nc" id="L103">      retval = new QName(namespaceUri, localName);</span>
    }
<span class="nc" id="L105">    return retval;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  @NonNull
  public IExpression visit(ParseTree tree) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">    assert tree != null;</span>
<span class="fc" id="L113">    return super.visit(tree);</span>
  }

  /**
   * Parse the provided context as an n-ary phrase.
   *
   * @param &lt;CONTEXT&gt;
   *          the Java type of the antlr context to parse
   * @param &lt;T&gt;
   *          the Java type of the child expressions produced by this parser
   * @param &lt;R&gt;
   *          the Java type of the outer expression produced by the parser
   * @param context
   *          the antlr context to parse
   * @param startIndex
   *          the child index to start parsing on
   * @param step
   *          the increment to advance while parsing child expressions
   * @param parser
   *          a binary function used to produce child expressions
   * @param supplier
   *          a function used to produce the other expression
   * @return the outer expression or {@code null} if no children exist to parse
   */
  @Nullable
  protected &lt;CONTEXT extends ParserRuleContext, T extends IExpression, R extends IExpression&gt;
      R nairyToCollection(
          @NonNull CONTEXT context,
          int startIndex,
          int step,
          @NonNull BiFunction&lt;CONTEXT, Integer, T&gt; parser,
          @NonNull Function&lt;List&lt;T&gt;, R&gt; supplier) {
<span class="fc" id="L145">    int numChildren = context.getChildCount();</span>

<span class="fc" id="L147">    R retval = null;</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (startIndex &lt; numChildren) {</span>
<span class="fc" id="L149">      List&lt;T&gt; children = new ArrayList&lt;&gt;((numChildren - startIndex) / step);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      for (int idx = startIndex; idx &lt; numChildren; idx += step) {</span>
<span class="fc" id="L151">        T result = parser.apply(context, idx);</span>
<span class="fc" id="L152">        children.add(result);</span>
      }
<span class="fc" id="L154">      retval = supplier.apply(children);</span>
    }
<span class="fc" id="L156">    return retval;</span>
  }

  /**
   * Parse the provided context as an n-ary phrase, which will be one of the
   * following.
   * &lt;ol&gt;
   * &lt;li&gt;A single &lt;code&gt;expr&lt;/code&gt; for which that expr will be returned&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;left (operator right)*&lt;/code&gt; for which a collection of the left
   * and right members will be returned based on what is provided by the
   * supplier.&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @param &lt;CONTEXT&gt;
   *          the context type to parse
   * @param &lt;NODE&gt;
   *          the type of expression
   * @param context
   *          the context instance
   * @param supplier
   *          a supplier that will instantiate an expression based on the provided
   *          parsed collection
   * @return the left expression or the supplied expression for a collection
   */
  @NonNull
  protected &lt;CONTEXT extends ParserRuleContext, NODE extends IExpression&gt; IExpression
      handleNAiryCollection(
          @NonNull CONTEXT context,
          @NonNull Function&lt;List&lt;NODE&gt;, IExpression&gt; supplier) {
<span class="fc" id="L185">    return handleNAiryCollection(context, 1, 2, (ctx, idx) -&gt; {</span>
      // skip operator, since we know what it is
<span class="fc" id="L187">      ParseTree tree = ctx.getChild(idx + 1);</span>
      @SuppressWarnings({ &quot;unchecked&quot;, &quot;null&quot; })
      @NonNull
<span class="fc" id="L190">      NODE node = (NODE) tree.accept(this);</span>
<span class="fc" id="L191">      return node;</span>
    }, supplier);
  }

  /**
   * Parse the provided context as an n-ary phrase, which will be one of the
   * following.
   * &lt;ol&gt;
   * &lt;li&gt;&lt;code&gt;expr&lt;/code&gt; for which the expr will be returned.&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;left&lt;/code&gt; plus a number of additional recurring tokens as defined
   * by the &lt;em&gt;step&lt;/em&gt;.&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;p&gt;
   * In the second case, the supplier will be used to generate an expression from
   * the collection of tuples.
   *
   * @param &lt;CONTEXT&gt;
   *          the context type to parse
   * @param &lt;EXPRESSION&gt;
   *          the child expression type
   * @param context
   *          the context instance
   * @param startIndex
   *          the starting context child position
   * @param step
   *          the amount to advance the loop over the context children
   * @param parser
   *          a binary function used to parse the context children
   * @param supplier
   *          a supplier that will instantiate an expression based on the provided
   *          collection
   * @return the left expression or the supplied expression for a collection
   */
  @NonNull
  protected &lt;CONTEXT extends ParserRuleContext, EXPRESSION extends IExpression&gt; IExpression
      handleNAiryCollection(
          @NonNull CONTEXT context,
          int startIndex,
          int step,
          @NonNull BiFunction&lt;CONTEXT, Integer, EXPRESSION&gt; parser,
          @NonNull Function&lt;List&lt;EXPRESSION&gt;, IExpression&gt; supplier) {
<span class="fc" id="L232">    int numChildren = context.getChildCount();</span>

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    if (numChildren == 0) {</span>
<span class="nc" id="L235">      throw new IllegalStateException(&quot;there should always be a child expression&quot;);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    } else if (startIndex &gt; numChildren) {</span>
<span class="nc" id="L237">      throw new IllegalStateException(&quot;Start index is out of bounds&quot;);</span>
    }

<span class="fc" id="L240">    ParseTree leftTree = context.getChild(0);</span>
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;null&quot; })
    @NonNull
<span class="fc" id="L243">    EXPRESSION leftResult = (EXPRESSION) leftTree.accept(this);</span>

    IExpression retval;
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (numChildren == 1) {</span>
<span class="nc" id="L247">      retval = leftResult;</span>
    } else {
<span class="fc" id="L249">      List&lt;EXPRESSION&gt; children = new ArrayList&lt;&gt;(numChildren - 1 / step);</span>
<span class="fc" id="L250">      children.add(leftResult);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">      for (int i = startIndex; i &lt; numChildren; i = i + step) {</span>
<span class="fc" id="L252">        EXPRESSION result = parser.apply(context, i);</span>
<span class="fc" id="L253">        children.add(result);</span>
      }
<span class="fc" id="L255">      IExpression result = ObjectUtils.notNull(supplier.apply(children));</span>
<span class="fc" id="L256">      retval = result;</span>
    }
<span class="fc" id="L258">    return retval;</span>
  }

  /**
   * Parse the provided context as a simple n-ary phrase, which will be one of the
   * following.
   * &lt;ol&gt;
   * &lt;li&gt;&lt;code&gt;expr&lt;/code&gt; for which the expr will be returned&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;left (operator right)*&lt;/code&gt; for which a collection of the left
   * and right members will be returned based on what is provided by the supplier.
   * &lt;/ol&gt;
   * &lt;p&gt;
   * In the second case, the supplier will be used to generate an expression from
   * the collection of tuples.
   *
   * @param &lt;CONTEXT&gt;
   *          the context type to parse
   * @param context
   *          the context instance
   * @param startingIndex
   *          the index of the first child expression, which must be a
   *          non-negative value that is less than the number of children
   * @param step
   *          the amount to advance the loop over the context children
   * @param parser
   *          a trinary function used to parse the context children and supply a
   *          result
   * @return the left expression or the supplied expression
   */
  protected &lt;CONTEXT extends ParserRuleContext&gt; IExpression handleGroupedNAiry(
      @NonNull CONTEXT context,
      int startingIndex,
      int step,
      @NonNull ITriFunction&lt;CONTEXT, Integer, IExpression, IExpression&gt; parser) {
<span class="fc" id="L292">    int numChildren = context.getChildCount();</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">    if (startingIndex &gt;= numChildren) {</span>
<span class="nc" id="L294">      throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L295">          String.format(&quot;The starting index '%d' exceeds the child count '%d'&quot;,</span>
<span class="nc" id="L296">              startingIndex,</span>
<span class="nc" id="L297">              numChildren));</span>
    }

<span class="fc" id="L300">    IExpression retval = null;</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    if (numChildren &gt; 0) {</span>
<span class="fc" id="L302">      ParseTree leftTree = context.getChild(startingIndex);</span>
<span class="fc" id="L303">      retval = ObjectUtils.notNull(leftTree.accept(this));</span>

<span class="fc bfc" id="L305" title="All 2 branches covered.">      for (int i = startingIndex + 1; i &lt; numChildren; i = i + step) {</span>
<span class="fc" id="L306">        retval = parser.apply(context, i, retval);</span>
      }
    }
<span class="fc" id="L309">    return retval;</span>
  }

  @FunctionalInterface
  interface ITriFunction&lt;T, U, V, R&gt; {

    R apply(T argT, U argU, V argV);

    default &lt;W&gt; ITriFunction&lt;T, U, V, W&gt; andThen(Function&lt;? super R, ? extends W&gt; after) {
<span class="nc" id="L318">      Objects.requireNonNull(after);</span>
<span class="nc" id="L319">      return (T t, U u, V v) -&gt; after.apply(apply(t, u, v));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>