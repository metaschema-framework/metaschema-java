<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DynamicContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath</a> &gt; <span class="el_source">DynamicContext.java</span></div><h1>DynamicContext.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath;

import com.github.benmanes.caffeine.cache.Caffeine;

import gov.nist.secauto.metaschema.core.configuration.DefaultConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IMutableConfiguration;
import gov.nist.secauto.metaschema.core.metapath.function.DefaultFunction.CallingContext;
import gov.nist.secauto.metaschema.core.metapath.function.IFunction.FunctionProperty;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDocumentNodeItem;
import gov.nist.secauto.metaschema.core.model.IUriResolver;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.io.IOException;
import java.net.URI;
import java.time.Clock;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

// TODO: add support for in-scope namespaces
/**
 * The implementation of a Metapath
 * &lt;a href=&quot;https://www.w3.org/TR/xpath-31/#eval_context&quot;&gt;dynamic context&lt;/a&gt;.
 */
<span class="fc" id="L40">public class DynamicContext { // NOPMD - intentional data class</span>
  @NonNull
  private final Map&lt;QName, ISequence&lt;?&gt;&gt; letVariableMap;
  @NonNull
  private final SharedState sharedState;

  /**
   * Construct a new dynamic context with a default static context.
   */
  public DynamicContext() {
<span class="fc" id="L50">    this(StaticContext.instance());</span>
<span class="fc" id="L51">  }</span>

  /**
   * Construct a new Metapath dynamic context using the provided static context.
   *
   * @param staticContext
   *          the Metapath static context
   */
<span class="fc" id="L59">  public DynamicContext(@NonNull StaticContext staticContext) {</span>
<span class="fc" id="L60">    this.letVariableMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L61">    this.sharedState = new SharedState(staticContext);</span>
<span class="fc" id="L62">  }</span>

<span class="fc" id="L64">  private DynamicContext(@NonNull DynamicContext context) {</span>
<span class="fc" id="L65">    this.letVariableMap = new ConcurrentHashMap&lt;&gt;(context.letVariableMap);</span>
<span class="fc" id="L66">    this.sharedState = context.sharedState;</span>
<span class="fc" id="L67">  }</span>

  private static class SharedState {
    @NonNull
    private final StaticContext staticContext;
    @NonNull
    private final ZoneId implicitTimeZone;
    @NonNull
    private final ZonedDateTime currentDateTime;
    @NonNull
    private final Map&lt;URI, IDocumentNodeItem&gt; availableDocuments;
    @NonNull
    private final Map&lt;CallingContext, ISequence&lt;?&gt;&gt; functionResultCache;
    @Nullable
    private CachingLoader documentLoader;
    @NonNull
    private final IMutableConfiguration&lt;MetapathEvaluationFeature&lt;?&gt;&gt; configuration;

<span class="fc" id="L85">    public SharedState(@NonNull StaticContext staticContext) {</span>
<span class="fc" id="L86">      this.staticContext = staticContext;</span>

<span class="fc" id="L88">      Clock clock = Clock.systemDefaultZone();</span>

<span class="fc" id="L90">      this.implicitTimeZone = ObjectUtils.notNull(clock.getZone());</span>
<span class="fc" id="L91">      this.currentDateTime = ObjectUtils.notNull(ZonedDateTime.now(clock));</span>
<span class="fc" id="L92">      this.availableDocuments = new HashMap&lt;&gt;();</span>
<span class="fc" id="L93">      this.functionResultCache = ObjectUtils.notNull(Caffeine.newBuilder()</span>
<span class="fc" id="L94">          .maximumSize(5000)</span>
<span class="fc" id="L95">          .expireAfterAccess(10, TimeUnit.MINUTES)</span>
<span class="fc" id="L96">          .&lt;CallingContext, ISequence&lt;?&gt;&gt;build().asMap());</span>
<span class="fc" id="L97">      this.configuration = new DefaultConfiguration&lt;&gt;();</span>
<span class="fc" id="L98">      this.configuration.enableFeature(MetapathEvaluationFeature.METAPATH_EVALUATE_PREDICATES);</span>
<span class="fc" id="L99">    }</span>
  }

  /**
   * Generate a new dynamic context that is a copy of this dynamic context.
   * &lt;p&gt;
   * This method can be used to create a new sub-context where changes can be made
   * without affecting this context. This is useful for setting information that
   * is only used in a limited evaluation sub-scope, such as for handling variable
   * assignment.
   *
   * @return a new dynamic context
   */
  @NonNull
  public DynamicContext subContext() {
<span class="fc" id="L114">    return new DynamicContext(this);</span>
  }

  /**
   * Get the static context associated with this dynamic context.
   *
   * @return the associated static context
   */
  @NonNull
  public StaticContext getStaticContext() {
<span class="fc" id="L124">    return sharedState.staticContext;</span>
  }

  /**
   * Get the default time zone used for evaluation.
   *
   * @return the time zone identifier object
   */
  @NonNull
  public ZoneId getImplicitTimeZone() {
<span class="nc" id="L134">    return sharedState.implicitTimeZone;</span>
  }

  /**
   * Get the current date and time.
   *
   * @return the current date and time
   */
  @NonNull
  public ZonedDateTime getCurrentDateTime() {
<span class="nc" id="L144">    return sharedState.currentDateTime;</span>
  }

  /**
   * Get the mapping of loaded documents from the document URI to the document
   * node.
   *
   * @return the map of document URIs to document nodes
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public Map&lt;URI, IDocumentNodeItem&gt; getAvailableDocuments() {
<span class="nc" id="L156">    return Collections.unmodifiableMap(sharedState.availableDocuments);</span>
  }

  /**
   * Get the document loader assigned to this dynamic context.
   *
   * @return the loader
   * @throws DynamicMetapathException
   *           with an error code
   *           {@link DynamicMetapathException#DYNAMIC_CONTEXT_ABSENT} if a
   *           document loader is not configured for this dynamic context
   */
  @NonNull
  public IDocumentLoader getDocumentLoader() {
<span class="nc" id="L170">    IDocumentLoader retval = sharedState.documentLoader;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (retval == null) {</span>
<span class="nc" id="L172">      throw new DynamicMetapathException(DynamicMetapathException.DYNAMIC_CONTEXT_ABSENT,</span>
          &quot;No document loader configured for the dynamic context.&quot;);
    }
<span class="nc" id="L175">    return retval;</span>
  }

  /**
   * Assign a document loader to this dynamic context.
   *
   * @param documentLoader
   *          the document loader to assign
   */
  public void setDocumentLoader(@NonNull IDocumentLoader documentLoader) {
<span class="nc" id="L185">    this.sharedState.documentLoader = new CachingLoader(documentLoader);</span>
<span class="nc" id="L186">  }</span>

  /**
   * Get the cached function call result for evaluating a function that has the
   * property {@link FunctionProperty#DETERMINISTIC}.
   *
   * @param callingContext
   *          the function calling context information that distinguishes the call
   *          from any other call
   * @return the cached result sequence for the function call
   */
  @Nullable
  public ISequence&lt;?&gt; getCachedResult(@NonNull CallingContext callingContext) {
<span class="fc" id="L199">    return sharedState.functionResultCache.get(callingContext);</span>
  }

  /**
   * Cache a function call result for a that has the property
   * {@link FunctionProperty#DETERMINISTIC}.
   *
   * @param callingContext
   *          the calling context information that distinguishes the call from any
   *          other call
   * @param result
   *          the function call result
   */
  public void cacheResult(@NonNull CallingContext callingContext, @NonNull ISequence&lt;?&gt; result) {
<span class="fc" id="L213">    ISequence&lt;?&gt; old = sharedState.functionResultCache.put(callingContext, result);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">    assert old == null;</span>
<span class="fc" id="L215">  }</span>

  /**
   * Used to disable the evaluation of predicate expressions during Metapath
   * evaluation.
   * &lt;p&gt;
   * This can be useful for determining the potential targets identified by a
   * Metapath expression as a partial evaluation, without evaluating that these
   * targets match the predicate.
   *
   * @return this dynamic context
   */
  @NonNull
  public DynamicContext disablePredicateEvaluation() {
<span class="fc" id="L229">    this.sharedState.configuration.disableFeature(MetapathEvaluationFeature.METAPATH_EVALUATE_PREDICATES);</span>
<span class="fc" id="L230">    return this;</span>
  }

  /**
   * Used to enable the evaluation of predicate expressions during Metapath
   * evaluation.
   * &lt;p&gt;
   * This is the default behavior if unchanged.
   *
   * @return this dynamic context
   */
  @NonNull
  public DynamicContext enablePredicateEvaluation() {
<span class="nc" id="L243">    this.sharedState.configuration.enableFeature(MetapathEvaluationFeature.METAPATH_EVALUATE_PREDICATES);</span>
<span class="nc" id="L244">    return this;</span>
  }

  /**
   * Get the Metapath evaluation configuration.
   *
   * @return the configuration
   */
  @NonNull
  public IConfiguration&lt;MetapathEvaluationFeature&lt;?&gt;&gt; getConfiguration() {
<span class="fc" id="L254">    return sharedState.configuration;</span>
  }

  /**
   * Get the sequence value assigned to a let variable with the provided qualified
   * name.
   *
   * @param name
   *          the variable qualified name
   * @return the non-null variable value
   * @throws MetapathException
   *           of the variable has not been assigned or if the variable value is
   *           {@code null}
   */
  @NonNull
  public ISequence&lt;?&gt; getVariableValue(@NonNull QName name) {
<span class="fc" id="L270">    ISequence&lt;?&gt; retval = letVariableMap.get(name);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (retval == null) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (!letVariableMap.containsKey(name)) {</span>
<span class="nc" id="L273">        throw new MetapathException(String.format(&quot;Variable '%s' not defined in context.&quot;, name));</span>
      }
<span class="nc" id="L275">      throw new MetapathException(String.format(&quot;Variable '%s' has null contents.&quot;, name));</span>
    }
<span class="fc" id="L277">    return retval;</span>
  }

  /**
   * Bind the variable {@code name} to the sequence {@code value}.
   *
   * @param name
   *          the name of the variable to bind
   * @param boundValue
   *          the value to bind to the variable
   * @return this dynamic context
   */
  @NonNull
  public DynamicContext bindVariableValue(@NonNull QName name, @NonNull ISequence&lt;?&gt; boundValue) {
<span class="fc" id="L291">    letVariableMap.put(name, boundValue);</span>
<span class="fc" id="L292">    return this;</span>
  }

  private class CachingLoader implements IDocumentLoader {
    @NonNull
    private final IDocumentLoader proxy;

<span class="nc" id="L299">    public CachingLoader(@NonNull IDocumentLoader proxy) {</span>
<span class="nc" id="L300">      this.proxy = proxy;</span>
<span class="nc" id="L301">    }</span>

    @Override
    public IUriResolver getUriResolver() {
<span class="nc" id="L305">      return new ContextUriResolver();</span>
    }

    @Override
    public void setUriResolver(@NonNull IUriResolver resolver) {
      // we delegate to the document loader proxy, so the resolver should be set there
<span class="nc" id="L311">      throw new UnsupportedOperationException(&quot;Set the resolver on the proxy&quot;);</span>
    }

    @NonNull
    protected IDocumentLoader getProxiedDocumentLoader() {
<span class="nc" id="L316">      return proxy;</span>
    }

    @Override
    public IDocumentNodeItem loadAsNodeItem(URI uri) throws IOException {
<span class="nc" id="L321">      IDocumentNodeItem retval = sharedState.availableDocuments.get(uri);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      if (retval == null) {</span>
<span class="nc" id="L323">        retval = getProxiedDocumentLoader().loadAsNodeItem(uri);</span>
<span class="nc" id="L324">        sharedState.availableDocuments.put(uri, retval);</span>
      }
<span class="nc" id="L326">      return retval;</span>
    }

<span class="nc" id="L329">    public class ContextUriResolver implements IUriResolver {</span>

      /**
       * {@inheritDoc}
       * &lt;p&gt;
       * This method first resolves the provided URI against the static context's base
       * URI.
       */
      @Override
      public URI resolve(URI uri) {
<span class="nc" id="L339">        URI baseUri = getStaticContext().getBaseUri();</span>

        URI resolvedUri;
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (baseUri == null) {</span>
<span class="nc" id="L343">          resolvedUri = uri;</span>
        } else {
<span class="nc" id="L345">          resolvedUri = ObjectUtils.notNull(baseUri.resolve(uri));</span>
        }

<span class="nc" id="L348">        IUriResolver resolver = getProxiedDocumentLoader().getUriResolver();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        return resolver == null ? resolvedUri : resolver.resolve(resolvedUri);</span>
      }
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>