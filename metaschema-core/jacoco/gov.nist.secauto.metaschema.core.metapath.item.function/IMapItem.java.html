<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMapItem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.item.function</a> &gt; <span class="el_source">IMapItem.java</span></div><h1>IMapItem.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.item.function;

import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ICollectionValue;
import gov.nist.secauto.metaschema.core.metapath.IPrintable;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.function.IArgument;
import gov.nist.secauto.metaschema.core.metapath.function.IFunction;
import gov.nist.secauto.metaschema.core.metapath.function.ISequenceType;
import gov.nist.secauto.metaschema.core.metapath.impl.AbstractArrayItem;
import gov.nist.secauto.metaschema.core.metapath.impl.AbstractMapItem;
import gov.nist.secauto.metaschema.core.metapath.impl.MapItemN;
import gov.nist.secauto.metaschema.core.metapath.item.IItem;
import gov.nist.secauto.metaschema.core.metapath.item.IItemVisitor;
import gov.nist.secauto.metaschema.core.metapath.item.atomic.IAnyAtomicItem;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;

/**
 * Represents a mapping of {@link IMapKey} keys to values.
 *
 * @param &lt;VALUE&gt;
 *          the value type
 */
public interface IMapItem&lt;VALUE extends ICollectionValue&gt;
    extends IFunction, IItem, Map&lt;IMapKey, VALUE&gt;, IPrintable {
  /**
   * Get an empty, immutable map item.
   *
   * @param &lt;V&gt;
   *          the value Java type
   * @return an immutable map item
   */
  @NonNull
  static &lt;V extends ICollectionValue&gt; IMapItem&lt;V&gt; empty() {
<span class="fc" id="L48">    return AbstractMapItem.empty();</span>
  }

  @Override
  default QName getQName() {
<span class="nc" id="L53">    return AbstractArrayItem.QNAME;</span>
  }

  @Override
  default Set&lt;FunctionProperty&gt; getProperties() {
<span class="nc" id="L58">    return AbstractArrayItem.PROPERTIES;</span>
  }

  @Override
  default boolean isDeterministic() {
<span class="nc" id="L63">    return true;</span>
  }

  @Override
  default boolean isContextDepenent() {
<span class="nc" id="L68">    return false;</span>
  }

  @Override
  default boolean isFocusDepenent() {
<span class="nc" id="L73">    return false;</span>
  }

  @Override
  default List&lt;IArgument&gt; getArguments() {
<span class="nc" id="L78">    return AbstractArrayItem.ARGUMENTS;</span>
  }

  @Override
  default int arity() {
<span class="nc" id="L83">    return 1;</span>
  }

  @Override
  default boolean isArityUnbounded() {
<span class="nc" id="L88">    return false;</span>
  }

  @Override
  default ISequenceType getResult() {
<span class="nc" id="L93">    return AbstractArrayItem.RESULT;</span>
  }

  @Override
  ISequence&lt;?&gt; execute(List&lt;? extends ISequence&lt;?&gt;&gt; arguments, DynamicContext dynamicContext, ISequence&lt;?&gt; focus);

  @Override
  default String toSignature() {
<span class="nc" id="L101">    return &quot;array()&quot;;</span>
  }

  @Override
  Map&lt;IMapKey, VALUE&gt; getValue();

  @Override
  default boolean hasValue() {
<span class="nc" id="L109">    return true;</span>
  }

  /**
   * Determine if this sequence is empty.
   *
   * @return {@code true} if the sequence contains no items, or {@code false}
   *         otherwise
   */
  @Override
  default boolean isEmpty() {
<span class="nc" id="L120">    return getValue().isEmpty();</span>
  }

  /**
   * Get the count of items in this sequence.
   *
   * @return the count of items
   */
  @Override
  default int size() {
<span class="nc" id="L130">    return getValue().size();</span>

  }

  @Override
  default ISequence&lt;IMapItem&lt;VALUE&gt;&gt; asSequence() {
<span class="fc" id="L136">    return ISequence.of(this);</span>
  }

  /**
   * Get a new, immutable map item that contains the items in the provided map.
   *
   * @param &lt;V&gt;
   *          the value Java type
   * @param map
   *          the map whose items are to be added to the new map
   * @return a map item containing the specified entries
   */
  @NonNull
  static &lt;V extends ICollectionValue&gt; IMapItem&lt;V&gt; ofCollection( // NOPMD - intentional
      @NonNull Map&lt;IMapKey, V&gt; map) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">    return map.isEmpty() ? empty() : new MapItemN&lt;&gt;(map);</span>
  }

  /**
   * Returns an unmodifiable map item containing zero mappings.
   *
   * @param &lt;V&gt;
   *          the value Java type
   * @return an empty {@code IMapItem}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;V extends ICollectionValue&gt; IMapItem&lt;V&gt; of() {
<span class="nc" id="L164">    return AbstractMapItem.empty();</span>
  }

  /**
   * Returns an unmodifiable map item containing a single mapping.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the mapping's key
   * @param v1
   *          the mapping's value
   * @return a map item containing the specified mapping
   * @throws NullPointerException
   *           if the key or the value is {@code null}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt; IMapItem&lt;V&gt; of(@NonNull K k1, @NonNull V v1) {
<span class="nc" id="L185">    return new MapItemN&lt;&gt;(entry(k1, v1));</span>
  }

  /**
   * Returns an unmodifiable map item containing two mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if the keys are duplicates
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt; IMapItem&lt;V&gt; of(
      @NonNull K k1, @NonNull V v1,
      @NonNull K k2, @NonNull V v2) {
<span class="nc" id="L214">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L215">        entry(k1, v1),</span>
<span class="nc" id="L216">        entry(k2, v2));</span>
  }

  /**
   * Returns an unmodifiable map item containing three mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3) {
<span class="nc" id="L251">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L252">        entry(k1, v1),</span>
<span class="nc" id="L253">        entry(k2, v2),</span>
<span class="nc" id="L254">        entry(k3, v3));</span>
  }

  /**
   * Returns an unmodifiable map item containing four mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3,
          @NonNull K k4, @NonNull V v4) {
<span class="nc" id="L294">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L295">        entry(k1, v1),</span>
<span class="nc" id="L296">        entry(k2, v2),</span>
<span class="nc" id="L297">        entry(k3, v3),</span>
<span class="nc" id="L298">        entry(k4, v4));</span>
  }

  /**
   * Returns an unmodifiable map item containing five mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3,
          @NonNull K k4, @NonNull V v4,
          @NonNull K k5, @NonNull V v5) {
<span class="nc" id="L343">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L344">        entry(k1, v1),</span>
<span class="nc" id="L345">        entry(k2, v2),</span>
<span class="nc" id="L346">        entry(k3, v3),</span>
<span class="nc" id="L347">        entry(k4, v4),</span>
<span class="nc" id="L348">        entry(k5, v5));</span>
  }

  /**
   * Returns an unmodifiable map item containing six mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @param k6
   *          the sixth mapping's key
   * @param v6
   *          the sixth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings({
      &quot;PMD.ExcessiveParameterList&quot;,
      &quot;PMD.ShortMethodName&quot;
  })
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3,
          @NonNull K k4, @NonNull V v4,
          @NonNull K k5, @NonNull V v5,
          @NonNull K k6, @NonNull V v6) {
<span class="nc" id="L401">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L402">        entry(k1, v1),</span>
<span class="nc" id="L403">        entry(k2, v2),</span>
<span class="nc" id="L404">        entry(k3, v3),</span>
<span class="nc" id="L405">        entry(k4, v4),</span>
<span class="nc" id="L406">        entry(k5, v5),</span>
<span class="nc" id="L407">        entry(k6, v6));</span>
  }

  /**
   * Returns an unmodifiable map item containing seven mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @param k6
   *          the sixth mapping's key
   * @param v6
   *          the sixth mapping's value
   * @param k7
   *          the seventh mapping's key
   * @param v7
   *          the seventh mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings({
      &quot;PMD.ExcessiveParameterList&quot;,
      &quot;PMD.ShortMethodName&quot;
  })
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt; IMapItem&lt;V&gt; of(
      @NonNull K k1, @NonNull V v1,
      @NonNull K k2, @NonNull V v2,
      @NonNull K k3, @NonNull V v3,
      @NonNull K k4, @NonNull V v4,
      @NonNull K k5, @NonNull V v5,
      @NonNull K k6, @NonNull V v6,
      @NonNull K k7, @NonNull V v7) {
<span class="nc" id="L464">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L465">        entry(k1, v1),</span>
<span class="nc" id="L466">        entry(k2, v2),</span>
<span class="nc" id="L467">        entry(k3, v3),</span>
<span class="nc" id="L468">        entry(k4, v4),</span>
<span class="nc" id="L469">        entry(k5, v5),</span>
<span class="nc" id="L470">        entry(k6, v6),</span>
<span class="nc" id="L471">        entry(k7, v7));</span>
  }

  /**
   * Returns an unmodifiable map item containing eight mappings. See
   * &lt;a href=&quot;#unmodifiable&quot;&gt;Unmodifiable Maps&lt;/a&gt; for details.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @param k6
   *          the sixth mapping's key
   * @param v6
   *          the sixth mapping's value
   * @param k7
   *          the seventh mapping's key
   * @param v7
   *          the seventh mapping's value
   * @param k8
   *          the eighth mapping's key
   * @param v8
   *          the eighth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings({
      &quot;PMD.ExcessiveParameterList&quot;,
      &quot;PMD.ShortMethodName&quot;
  })
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3,
          @NonNull K k4, @NonNull V v4,
          @NonNull K k5, @NonNull V v5,
          @NonNull K k6, @NonNull V v6,
          @NonNull K k7, @NonNull V v7,
          @NonNull K k8, @NonNull V v8) {
<span class="nc" id="L535">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L536">        entry(k1, v1),</span>
<span class="nc" id="L537">        entry(k2, v2),</span>
<span class="nc" id="L538">        entry(k3, v3),</span>
<span class="nc" id="L539">        entry(k4, v4),</span>
<span class="nc" id="L540">        entry(k5, v5),</span>
<span class="nc" id="L541">        entry(k6, v6),</span>
<span class="nc" id="L542">        entry(k7, v7),</span>
<span class="nc" id="L543">        entry(k8, v8));</span>
  }

  /**
   * Returns an unmodifiable map item containing nine mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @param k6
   *          the sixth mapping's key
   * @param v6
   *          the sixth mapping's value
   * @param k7
   *          the seventh mapping's key
   * @param v7
   *          the seventh mapping's value
   * @param k8
   *          the eighth mapping's key
   * @param v8
   *          the eighth mapping's value
   * @param k9
   *          the ninth mapping's key
   * @param v9
   *          the ninth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings({
      &quot;PMD.ExcessiveParameterList&quot;,
      &quot;PMD.ShortMethodName&quot;
  })
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; of(
          @NonNull K k1, @NonNull V v1,
          @NonNull K k2, @NonNull V v2,
          @NonNull K k3, @NonNull V v3,
          @NonNull K k4, @NonNull V v4,
          @NonNull K k5, @NonNull V v5,
          @NonNull K k6, @NonNull V v6,
          @NonNull K k7, @NonNull V v7,
          @NonNull K k8, @NonNull V v8,
          @NonNull K k9, @NonNull V v9) {
<span class="nc" id="L611">    return new MapItemN&lt;&gt;(entry(k1, v1), entry(k2, v2), entry(k3, v3), entry(k4, v4), entry(k5, v5), entry(k6, v6),</span>
<span class="nc" id="L612">        entry(k7, v7), entry(k8, v8), entry(k9, v9));</span>
  }

  /**
   * Returns an unmodifiable map item containing ten mappings.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param k1
   *          the first mapping's key
   * @param v1
   *          the first mapping's value
   * @param k2
   *          the second mapping's key
   * @param v2
   *          the second mapping's value
   * @param k3
   *          the third mapping's key
   * @param v3
   *          the third mapping's value
   * @param k4
   *          the fourth mapping's key
   * @param v4
   *          the fourth mapping's value
   * @param k5
   *          the fifth mapping's key
   * @param v5
   *          the fifth mapping's value
   * @param k6
   *          the sixth mapping's key
   * @param v6
   *          the sixth mapping's value
   * @param k7
   *          the seventh mapping's key
   * @param v7
   *          the seventh mapping's value
   * @param k8
   *          the eighth mapping's key
   * @param v8
   *          the eighth mapping's value
   * @param k9
   *          the ninth mapping's key
   * @param v9
   *          the ninth mapping's value
   * @param k10
   *          the tenth mapping's key
   * @param v10
   *          the tenth mapping's value
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any key or value is {@code null}
   */
  @SuppressWarnings({
      &quot;PMD.ExcessiveParameterList&quot;,
      &quot;PMD.ShortMethodName&quot;
  })
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt; IMapItem&lt;V&gt; of(
      @NonNull K k1, @NonNull V v1,
      @NonNull K k2, @NonNull V v2,
      @NonNull K k3, @NonNull V v3,
      @NonNull K k4, @NonNull V v4,
      @NonNull K k5, @NonNull V v5,
      @NonNull K k6, @NonNull V v6,
      @NonNull K k7, @NonNull V v7,
      @NonNull K k8, @NonNull V v8,
      @NonNull K k9, @NonNull V v9,
      @NonNull K k10, @NonNull V v10) {
<span class="nc" id="L684">    return new MapItemN&lt;&gt;(</span>
<span class="nc" id="L685">        entry(k1, v1),</span>
<span class="nc" id="L686">        entry(k2, v2),</span>
<span class="nc" id="L687">        entry(k3, v3),</span>
<span class="nc" id="L688">        entry(k4, v4),</span>
<span class="nc" id="L689">        entry(k5, v5),</span>
<span class="nc" id="L690">        entry(k6, v6),</span>
<span class="nc" id="L691">        entry(k7, v7),</span>
<span class="nc" id="L692">        entry(k8, v8),</span>
<span class="nc" id="L693">        entry(k9, v9),</span>
<span class="nc" id="L694">        entry(k10, v10));</span>
  }

  /**
   * Returns an unmodifiable map item containing keys and values extracted from
   * the given entries. The entries themselves are not stored in the map.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param entries
   *          {@code Map.Entry}s containing the keys and values from which the map
   *          is populated
   * @return a map item containing the specified mappings
   * @throws IllegalArgumentException
   *           if there are any duplicate keys
   * @throws NullPointerException
   *           if any entry, key, or value is {@code null}, or if the
   *           {@code entries} array is {@code null}
   */
  @SafeVarargs
  @SuppressWarnings(&quot;varargs&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; ofEntries(Map.Entry&lt;IMapKey, ? extends V&gt;... entries) {
<span class="fc bfc" id="L720" title="All 2 branches covered.">    return entries.length == 0 ? empty() : new MapItemN&lt;&gt;(entries);</span>
  }

  /**
   * Returns an unmodifiable {@link Entry} containing the given key and value.
   *
   * @param &lt;V&gt;
   *          the value's type
   * @param key
   *          the key
   * @param value
   *          the value
   * @return an {@code Map.Entry} containing the specified key and value
   * @throws NullPointerException
   *           if the key or value is {@code null}
   */
  @NonNull
  static &lt;V extends ICollectionValue&gt; Map.Entry&lt;IMapKey, V&gt; entry(@NonNull IAnyAtomicItem key, @NonNull V value) {
<span class="fc" id="L738">    return entry(key.asMapKey(), value);</span>
  }

  /**
   * Returns an unmodifiable {@link Entry} containing the given key and value.
   *
   * @param &lt;V&gt;
   *          the value's type
   * @param key
   *          the key
   * @param value
   *          the value
   * @return an {@code Map.Entry} containing the specified key and value
   * @throws NullPointerException
   *           if the key or value is {@code null}
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  static &lt;V extends ICollectionValue&gt; Map.Entry&lt;IMapKey, V&gt; entry(@NonNull IMapKey key, @NonNull V value) {
<span class="fc" id="L757">    return Map.entry(key, value);</span>
  }

  /**
   * Returns an unmodifiable Map item containing the entries of the given Map. The
   * given Map must not be null, and it must not contain any null keys or values.
   * If the given Map is subsequently modified, the returned Map will not reflect
   * such modifications.
   *
   * @param &lt;K&gt;
   *          the map item's key type
   * @param &lt;V&gt;
   *          the map item's value type
   * @param map
   *          a map item from which entries are drawn, must be non-null
   * @return a map item containing the entries of the given {@code Map}
   * @throws NullPointerException
   *           if map is null, or if it contains any null keys or values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @NonNull
  static &lt;K extends IAnyAtomicItem, V extends ICollectionValue&gt;
      IMapItem&lt;V&gt; copyOf(Map&lt;? extends IMapKey, ? extends V&gt; map) {
<span class="nc bnc" id="L780" title="All 2 branches missed.">    return map instanceof IMapItem</span>
<span class="nc" id="L781">        ? (IMapItem&lt;V&gt;) map</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        : map.isEmpty()</span>
<span class="nc" id="L783">            ? empty()</span>
<span class="nc" id="L784">            : new MapItemN&lt;&gt;(new LinkedHashMap&lt;&gt;(map));</span>
  }

  @Override
  default void accept(IItemVisitor visitor) {
<span class="nc" id="L789">    visitor.visit(this);</span>
<span class="nc" id="L790">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>