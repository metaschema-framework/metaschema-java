<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstraintXmlSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.xml.impl</a> &gt; <span class="el_source">ConstraintXmlSupport.java</span></div><h1>ConstraintXmlSupport.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.xml.impl;

import gov.nist.secauto.metaschema.core.MetaschemaConstants;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.metapath.MetapathException;
import gov.nist.secauto.metaschema.core.model.IAttributable;
import gov.nist.secauto.metaschema.core.model.ISource;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValue;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValuesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ICardinalityConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintVisitor;
import gov.nist.secauto.metaschema.core.model.constraint.IExpectConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexHasKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyField;
import gov.nist.secauto.metaschema.core.model.constraint.ILet;
import gov.nist.secauto.metaschema.core.model.constraint.IMatchesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IModelConstrained;
import gov.nist.secauto.metaschema.core.model.constraint.IUniqueConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IValueConstrained;
import gov.nist.secauto.metaschema.core.model.xml.XmlModuleConstants;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.AllowedValueType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.AllowedValuesType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.ConstraintLetType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.ConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.DefineAssemblyConstraintsType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.DefineFieldConstraintsType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.DefineFlagConstraintsType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.ExpectConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.IndexHasKeyConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.KeyConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.KeyConstraintType.KeyField;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.MatchesConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.PropertyType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.RemarksType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedAllowedValuesConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedExpectConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedHasCardinalityConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedIndexConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedIndexHasKeyConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedKeyConstraintType;
import gov.nist.secauto.metaschema.core.model.xml.xmlbeans.TargetedMatchesConstraintType;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.xmlbeans.XmlCursor;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.impl.values.XmlValueNotSupportedException;

import java.math.BigInteger;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import edu.umd.cs.findbugs.annotations.NonNull;

/**
 * Supports parsing constraints defined in an XMLBeans-based XML instance.
 */
@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public final class ConstraintXmlSupport {
  @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;)
  @NonNull
<span class="fc" id="L74">  private static final XmlObjectParser&lt;Pair&lt;ISource, IValueConstrained&gt;&gt; FLAG_PARSER</span>
<span class="fc" id="L75">      = new XmlObjectParser&lt;&gt;(ObjectUtils.notNull(</span>
<span class="fc" id="L76">          Map.ofEntries(</span>
<span class="fc" id="L77">              Map.entry(XmlModuleConstants.ALLOWED_VALUES_CONSTRAINT_QNAME, ConstraintXmlSupport::handleAllowedValues),</span>
<span class="fc" id="L78">              Map.entry(XmlModuleConstants.INDEX_HAS_KEY_CONSTRAINT_QNAME, ConstraintXmlSupport::handleIndexHasKey),</span>
<span class="fc" id="L79">              Map.entry(XmlModuleConstants.MATCHES_CONSTRAINT_QNAME, ConstraintXmlSupport::handleMatches),</span>
<span class="fc" id="L80">              Map.entry(XmlModuleConstants.EXPECT_CONSTRAINT_QNAME, ConstraintXmlSupport::handleExpect)))) {</span>

        @Override
        protected Handler&lt;Pair&lt;ISource, IValueConstrained&gt;&gt; identifyHandler(XmlCursor cursor, XmlObject obj) {
          Handler&lt;Pair&lt;ISource, IValueConstrained&gt;&gt; retval;
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">          if (obj instanceof AllowedValuesType) {</span>
<span class="fc" id="L86">            retval = ConstraintXmlSupport::handleAllowedValues;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">          } else if (obj instanceof IndexHasKeyConstraintType) {</span>
<span class="nc" id="L88">            retval = ConstraintXmlSupport::handleIndexHasKey;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">          } else if (obj instanceof MatchesConstraintType) {</span>
<span class="nc" id="L90">            retval = ConstraintXmlSupport::handleMatches;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          } else if (obj instanceof ExpectConstraintType) {</span>
<span class="nc" id="L92">            retval = ConstraintXmlSupport::handleExpect;</span>
          } else {
<span class="nc" id="L94">            retval = super.identifyHandler(cursor, obj);</span>
          }
<span class="fc" id="L96">          return retval;</span>
        }
      };

  @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;)
  @NonNull
  private static final XmlObjectParser&lt;Pair&lt;ISource,
<span class="fc" id="L103">      IValueConstrained&gt;&gt; FIELD_PARSER</span>
<span class="fc" id="L104">          = new XmlObjectParser&lt;&gt;(ObjectUtils.notNull(Map.ofEntries(</span>
<span class="fc" id="L105">              Map.entry(XmlModuleConstants.ALLOWED_VALUES_CONSTRAINT_QNAME,</span>
                  ConstraintXmlSupport::handleScopedAllowedValues),
<span class="fc" id="L107">              Map.entry(XmlModuleConstants.INDEX_HAS_KEY_CONSTRAINT_QNAME,</span>
                  ConstraintXmlSupport::handleScopedIndexHasKey),
<span class="fc" id="L109">              Map.entry(XmlModuleConstants.MATCHES_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedMatches),</span>
<span class="fc" id="L110">              Map.entry(XmlModuleConstants.EXPECT_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedExpect)))) {</span>

            @Override
            protected Handler&lt;Pair&lt;ISource, IValueConstrained&gt;&gt; identifyHandler(XmlCursor cursor, XmlObject obj) {
              Handler&lt;Pair&lt;ISource, IValueConstrained&gt;&gt; retval;
<span class="nc bnc" id="L115" title="All 2 branches missed.">              if (obj instanceof TargetedAllowedValuesConstraintType) {</span>
<span class="nc" id="L116">                retval = ConstraintXmlSupport::handleScopedAllowedValues;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">              } else if (obj instanceof TargetedIndexHasKeyConstraintType) {</span>
<span class="nc" id="L118">                retval = ConstraintXmlSupport::handleScopedIndexHasKey;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">              } else if (obj instanceof TargetedMatchesConstraintType) {</span>
<span class="nc" id="L120">                retval = ConstraintXmlSupport::handleScopedMatches;</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">              } else if (obj instanceof TargetedExpectConstraintType) {</span>
<span class="nc" id="L122">                retval = ConstraintXmlSupport::handleScopedExpect;</span>
              } else {
<span class="nc" id="L124">                retval = super.identifyHandler(cursor, obj);</span>
              }
<span class="nc" id="L126">              return retval;</span>
            }
          };

  @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;)
  @NonNull
  private static final XmlObjectParser&lt;Pair&lt;ISource,
<span class="fc" id="L133">      IModelConstrained&gt;&gt; ASSEMBLY_PARSER</span>
<span class="fc" id="L134">          = new XmlObjectParser&lt;&gt;(ObjectUtils.notNull(Map.ofEntries(</span>
<span class="fc" id="L135">              Map.entry(XmlModuleConstants.ALLOWED_VALUES_CONSTRAINT_QNAME,</span>
                  ConstraintXmlSupport::handleScopedAllowedValues),
<span class="fc" id="L137">              Map.entry(XmlModuleConstants.INDEX_HAS_KEY_CONSTRAINT_QNAME,</span>
                  ConstraintXmlSupport::handleScopedIndexHasKey),
<span class="fc" id="L139">              Map.entry(XmlModuleConstants.MATCHES_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedMatches),</span>
<span class="fc" id="L140">              Map.entry(XmlModuleConstants.EXPECT_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedExpect),</span>
<span class="fc" id="L141">              Map.entry(XmlModuleConstants.INDEX_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedIndex),</span>
<span class="fc" id="L142">              Map.entry(XmlModuleConstants.IS_UNIQUE_CONSTRAINT_QNAME, ConstraintXmlSupport::handleScopedIsUnique),</span>
<span class="fc" id="L143">              Map.entry(XmlModuleConstants.HAS_CARDINALITY_CONSTRAINT_QNAME,</span>
<span class="fc" id="L144">                  ConstraintXmlSupport::handleScopedHasCardinality)))) {</span>

            @Override
            protected Handler&lt;Pair&lt;ISource, IModelConstrained&gt;&gt; identifyHandler(XmlCursor cursor, XmlObject obj) {
              Handler&lt;Pair&lt;ISource, IModelConstrained&gt;&gt; retval;
<span class="fc bfc" id="L149" title="All 2 branches covered.">              if (obj instanceof TargetedAllowedValuesConstraintType) {</span>
<span class="fc" id="L150">                retval = ConstraintXmlSupport::handleScopedAllowedValues;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">              } else if (obj instanceof TargetedIndexHasKeyConstraintType) {</span>
<span class="nc" id="L152">                retval = ConstraintXmlSupport::handleScopedIndexHasKey;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">              } else if (obj instanceof TargetedMatchesConstraintType) {</span>
<span class="fc" id="L154">                retval = ConstraintXmlSupport::handleScopedMatches;</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">              } else if (obj instanceof TargetedExpectConstraintType) {</span>
<span class="fc" id="L156">                retval = ConstraintXmlSupport::handleScopedExpect;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">              } else if (obj instanceof TargetedIndexConstraintType) {</span>
<span class="nc" id="L158">                retval = ConstraintXmlSupport::handleScopedIndex;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">              } else if (obj instanceof TargetedKeyConstraintType) {</span>
<span class="nc" id="L160">                retval = ConstraintXmlSupport::handleScopedIsUnique;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">              } else if (obj instanceof TargetedHasCardinalityConstraintType) {</span>
<span class="nc" id="L162">                retval = ConstraintXmlSupport::handleScopedHasCardinality;</span>
              } else {
<span class="nc" id="L164">                retval = super.identifyHandler(cursor, obj);</span>
              }
<span class="fc" id="L166">              return retval;</span>
            }

          };

  private static void parseLets(
      @NonNull List&lt;ConstraintLetType&gt; letList,
      @NonNull IValueConstrained constraints,
      @NonNull ISource source) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">    for (ConstraintLetType xmlLet : letList) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      assert xmlLet != null;</span>
<span class="nc" id="L177">      ILet let = ModelFactory.newLet(xmlLet, source);</span>
<span class="nc" id="L178">      constraints.addLetExpression(let);</span>
<span class="nc" id="L179">    }</span>
<span class="fc" id="L180">  }</span>

  /**
   * Parse a set of constraints from the provided XMLBeans {@code xmlObject} and
   * apply them to the provided {@code constraints}.
   *
   * @param constraints
   *          the constraint collection to add the parsed constraints to
   * @param xmlObject
   *          the XMLBeans instance
   * @param source
   *          information about the source of the constraints
   */
  public static void parse(
      @NonNull IValueConstrained constraints,
      @NonNull DefineFlagConstraintsType xmlObject,
      @NonNull ISource source) {
<span class="fc" id="L197">    parseLets(ObjectUtils.notNull(xmlObject.getLetList()), constraints, source);</span>
<span class="fc" id="L198">    parse(</span>
        FLAG_PARSER,
        constraints,
        (XmlObject) xmlObject,
        source);
<span class="fc" id="L203">  }</span>

  /**
   * Parse a set of constraints from the provided XMLBeans {@code xmlObject} and
   * apply them to the provided {@code constraints}.
   *
   * @param constraints
   *          the constraint collection to add the parsed constraints to
   * @param xmlObject
   *          the XMLBeans instance
   * @param source
   *          information about the source of the constraints
   */
  public static void parse(
      @NonNull IValueConstrained constraints,
      @NonNull DefineFieldConstraintsType xmlObject,
      @NonNull ISource source) {
<span class="nc" id="L220">    parseLets(ObjectUtils.notNull(xmlObject.getLetList()), constraints, source);</span>
<span class="nc" id="L221">    parse(</span>
        FIELD_PARSER,
        constraints,
        (XmlObject) xmlObject,
        source);
<span class="nc" id="L226">  }</span>

  /**
   * Parse a set of constraints from the provided XMLBeans {@code xmlObject} and
   * apply them to the provided {@code constraints}.
   *
   * @param constraints
   *          the constraint collection to add the parsed constraints to
   * @param xmlObject
   *          the XMLBeans instance
   * @param source
   *          information about the source of the constraints
   */
  public static void parse(
      @NonNull IModelConstrained constraints,
      @NonNull DefineAssemblyConstraintsType xmlObject,
      @NonNull ISource source) {
<span class="fc" id="L243">    parseLets(ObjectUtils.notNull(xmlObject.getLetList()), constraints, source);</span>
<span class="fc" id="L244">    parse(</span>
        ASSEMBLY_PARSER,
        constraints,
        (XmlObject) xmlObject,
        source);
<span class="fc" id="L249">  }</span>

  private static &lt;T&gt; void parse(
      @NonNull XmlObjectParser&lt;Pair&lt;ISource, T&gt;&gt; parser,
      @NonNull T constraints,
      @NonNull XmlObject xmlObject,
      @NonNull ISource source) {
    try {
<span class="fc" id="L257">      parser.parse(xmlObject, Pair.of(source, constraints));</span>
<span class="nc" id="L258">    } catch (MetapathException | XmlValueNotSupportedException ex) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (ex.getCause() instanceof MetapathException) {</span>
<span class="nc" id="L260">        throw new MetapathException(</span>
<span class="nc" id="L261">            String.format(&quot;Unable to compile a Metapath in '%s'. %s&quot;,</span>
<span class="nc" id="L262">                source.getSource(),</span>
<span class="nc" id="L263">                ex.getLocalizedMessage()),</span>
            ex);
      }
<span class="nc" id="L266">      throw ex;</span>
<span class="fc" id="L267">    }</span>
<span class="fc" id="L268">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleAllowedValues(
      @NonNull XmlObject obj,
      Pair&lt;ISource, IValueConstrained&gt; state) {
<span class="fc" id="L274">    IAllowedValuesConstraint constraint = ModelFactory.newAllowedValuesConstraint(</span>
        (AllowedValuesType) obj,
<span class="fc" id="L276">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="fc" id="L277">    state.getRight().addConstraint(constraint);</span>
<span class="fc" id="L278">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedAllowedValues(
      @NonNull XmlObject obj,
      Pair&lt;ISource, ? extends IValueConstrained&gt; state) {
<span class="fc" id="L284">    IAllowedValuesConstraint constraint = ModelFactory.newAllowedValuesConstraint(</span>
        (TargetedAllowedValuesConstraintType) obj,
<span class="fc" id="L286">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="fc" id="L287">    state.getRight().addConstraint(constraint);</span>
<span class="fc" id="L288">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleMatches(
      @NonNull XmlObject obj,
      Pair&lt;ISource, IValueConstrained&gt; state) {
<span class="nc" id="L294">    IMatchesConstraint constraint = ModelFactory.newMatchesConstraint(</span>
        (MatchesConstraintType) obj,
<span class="nc" id="L296">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L297">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L298">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedMatches(
      @NonNull XmlObject obj,
      Pair&lt;ISource, ? extends IValueConstrained&gt; state) {
<span class="fc" id="L304">    IMatchesConstraint constraint = ModelFactory.newMatchesConstraint(</span>
        (TargetedMatchesConstraintType) obj,
<span class="fc" id="L306">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="fc" id="L307">    state.getRight().addConstraint(constraint);</span>
<span class="fc" id="L308">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleIndexHasKey(
      @NonNull XmlObject obj,
      Pair&lt;ISource, IValueConstrained&gt; state) {
<span class="nc" id="L314">    IIndexHasKeyConstraint constraint = ModelFactory.newIndexHasKeyConstraint(</span>
        (IndexHasKeyConstraintType) obj,
<span class="nc" id="L316">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L317">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L318">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedIndexHasKey(
      @NonNull XmlObject obj,
      Pair&lt;ISource, ? extends IValueConstrained&gt; state) {
<span class="nc" id="L324">    IIndexHasKeyConstraint constraint = ModelFactory.newIndexHasKeyConstraint(</span>
        (TargetedIndexHasKeyConstraintType) obj,
<span class="nc" id="L326">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L327">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L328">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleExpect(
      @NonNull XmlObject obj,
      Pair&lt;ISource, IValueConstrained&gt; state) {
<span class="nc" id="L334">    IExpectConstraint constraint = ModelFactory.newExpectConstraint(</span>
        (ExpectConstraintType) obj,
<span class="nc" id="L336">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L337">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L338">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedExpect(
      @NonNull XmlObject obj,
      Pair&lt;ISource, ? extends IValueConstrained&gt; state) {
<span class="fc" id="L344">    IExpectConstraint constraint = ModelFactory.newExpectConstraint(</span>
        (TargetedExpectConstraintType) obj,
<span class="fc" id="L346">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="fc" id="L347">    state.getRight().addConstraint(constraint);</span>
<span class="fc" id="L348">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedIndex(@NonNull XmlObject obj, Pair&lt;ISource, IModelConstrained&gt; state) {
<span class="nc" id="L352">    IIndexConstraint constraint = ModelFactory.newIndexConstraint(</span>
        (TargetedIndexConstraintType) obj,
<span class="nc" id="L354">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L355">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L356">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedIsUnique(@NonNull XmlObject obj, Pair&lt;ISource, IModelConstrained&gt; state) {
<span class="nc" id="L360">    IUniqueConstraint constraint = ModelFactory.newUniqueConstraint(</span>
        (TargetedKeyConstraintType) obj,
<span class="nc" id="L362">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L363">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L364">  }</span>

  @SuppressWarnings(&quot;PMD.UnusedPrivateMethod&quot;)
  private static void handleScopedHasCardinality(@NonNull XmlObject obj, Pair&lt;ISource, IModelConstrained&gt; state) {
<span class="nc" id="L368">    ICardinalityConstraint constraint = ModelFactory.newCardinalityConstraint(</span>
        (TargetedHasCardinalityConstraintType) obj,
<span class="nc" id="L370">        ObjectUtils.notNull(state.getLeft()));</span>
<span class="nc" id="L371">    state.getRight().addConstraint(constraint);</span>
<span class="nc" id="L372">  }</span>

  private ConstraintXmlSupport() {
    // disable construction
  }

<span class="nc" id="L378">  @SuppressWarnings(&quot;unused&quot;)</span>
  private static final class XmlbeanGeneratingVisitor
      implements IConstraintVisitor&lt;DefineAssemblyConstraintsType, Void&gt; {

    private static void applyCommonValues(@NonNull IConstraint constraint, @NonNull ConstraintType bean) {
<span class="nc" id="L383">      MarkupLine description = constraint.getDescription();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (description != null) {</span>
<span class="nc" id="L385">        bean.setDescription(MarkupStringConverter.toMarkupLineDatatype(description));</span>
      }
<span class="nc" id="L387">      String formalName = constraint.getFormalName();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if (formalName != null) {</span>
<span class="nc" id="L389">        bean.setFormalName(formalName);</span>
      }

<span class="nc" id="L392">      String id = constraint.getId();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (id != null) {</span>
<span class="nc" id="L394">        bean.setId(constraint.getId());</span>
      }

<span class="nc" id="L397">      IConstraint.Level level = constraint.getLevel();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      if (!IConstraint.DEFAULT_LEVEL.equals(level)) {</span>
<span class="nc" id="L399">        bean.setLevel(level);</span>
      }

<span class="nc bnc" id="L402" title="All 2 branches missed.">      for (Map.Entry&lt;IAttributable.Key, Set&lt;String&gt;&gt; entry : constraint.getProperties().entrySet()) {</span>
<span class="nc" id="L403">        IAttributable.Key key = entry.getKey();</span>
<span class="nc" id="L404">        Set&lt;String&gt; values = entry.getValue();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (String value : values) {</span>
<span class="nc" id="L406">          PropertyType prop = bean.addNewProp();</span>
<span class="nc" id="L407">          prop.setName(key.getName());</span>

<span class="nc" id="L409">          String namespace = key.getNamespace();</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">          if (!IAttributable.DEFAULT_PROPERY_NAMESPACE.equals(namespace)) {</span>
<span class="nc" id="L411">            prop.setNamespace(namespace);</span>
          }
<span class="nc" id="L413">          prop.setValue(value);</span>
<span class="nc" id="L414">        }</span>
<span class="nc" id="L415">      }</span>
<span class="nc" id="L416">    }</span>

    @Override
    public Void visitAllowedValues(IAllowedValuesConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L420">      TargetedAllowedValuesConstraintType bean = state.addNewAllowedValues();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L422">      applyCommonValues(constraint, bean);</span>

<span class="nc bnc" id="L424" title="All 2 branches missed.">      if (Boolean.compare(IAllowedValuesConstraint.ALLOW_OTHER_DEFAULT, constraint.isAllowedOther()) != 0) {</span>
<span class="nc" id="L425">        bean.setAllowOther(constraint.isAllowedOther());</span>
      }
<span class="nc" id="L427">      bean.setTarget(constraint.getTarget());</span>
<span class="nc" id="L428">      bean.setExtensible(constraint.getExtensible());</span>

<span class="nc bnc" id="L430" title="All 2 branches missed.">      for (Map.Entry&lt;String, ? extends IAllowedValue&gt; entry : constraint.getAllowedValues().entrySet()) {</span>
<span class="nc" id="L431">        String value = entry.getKey();</span>
<span class="nc" id="L432">        IAllowedValue allowedValue = entry.getValue();</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">        assert value.equals(allowedValue.getValue());</span>

<span class="nc" id="L436">        MarkupLine description = allowedValue.getDescription();</span>
<span class="nc" id="L437">        AllowedValueType enumType = bean.addNewEnum();</span>
<span class="nc" id="L438">        enumType.setValue(value);</span>

<span class="nc" id="L440">        XmlbeansMarkupWriter.visit(description, MetaschemaConstants.METASCHEMA_NAMESPACE, enumType);</span>
<span class="nc" id="L441">      }</span>

<span class="nc" id="L443">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L445">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L447">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L449">      return null;</span>
    }

    @Override
    public Void visitCardinalityConstraint(ICardinalityConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L454">      TargetedHasCardinalityConstraintType bean = state.addNewHasCardinality();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L456">      applyCommonValues(constraint, bean);</span>

<span class="nc" id="L458">      Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">      if (minOccurs != null) {</span>
<span class="nc" id="L460">        bean.setMinOccurs(BigInteger.valueOf(minOccurs));</span>
      }

<span class="nc" id="L463">      Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">      if (maxOccurs != null) {</span>
<span class="nc" id="L465">        bean.setMaxOccurs(BigInteger.valueOf(maxOccurs));</span>
      }

<span class="nc" id="L468">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L470">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L472">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L474">      return null;</span>
    }

    @Override
    public Void visitExpectConstraint(IExpectConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L479">      TargetedExpectConstraintType bean = state.addNewExpect();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L481">      applyCommonValues(constraint, bean);</span>

<span class="nc" id="L483">      bean.setTest(constraint.getTest());</span>

<span class="nc" id="L485">      String message = constraint.getMessage();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">      if (message != null) {</span>
<span class="nc" id="L487">        bean.setMessage(message);</span>
      }

<span class="nc" id="L490">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L492">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L494">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L496">      return null;</span>
    }

    @Override
    public Void visitMatchesConstraint(IMatchesConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L501">      TargetedMatchesConstraintType bean = state.addNewMatches();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L503">      applyCommonValues(constraint, bean);</span>

<span class="nc" id="L505">      Pattern pattern = constraint.getPattern();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">      if (pattern != null) {</span>
<span class="nc" id="L507">        bean.setRegex(pattern);</span>
      }

<span class="nc" id="L510">      IDataTypeAdapter&lt;?&gt; dataType = constraint.getDataType();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">      if (dataType != null) {</span>
<span class="nc" id="L512">        bean.setDatatype(dataType);</span>
      }

<span class="nc" id="L515">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L517">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L519">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L521">      return null;</span>
    }

    private static void applyKeyFields(@NonNull IKeyConstraint constraint, @NonNull KeyConstraintType bean) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">      for (IKeyField keyField : constraint.getKeyFields()) {</span>
<span class="nc" id="L526">        KeyField keyFieldBean = bean.addNewKeyField();</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        assert keyField != null;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        assert keyFieldBean != null;</span>
<span class="nc" id="L529">        applyKeyField(keyField, keyFieldBean);</span>
<span class="nc" id="L530">      }</span>
<span class="nc" id="L531">    }</span>

    private static void applyKeyField(@NonNull IKeyField keyField, @NonNull KeyField bean) {
<span class="nc" id="L534">      Pattern pattern = keyField.getPattern();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      if (pattern != null) {</span>
<span class="nc" id="L536">        bean.setPattern(pattern);</span>
      }

<span class="nc" id="L539">      bean.setTarget(keyField.getTarget());</span>

<span class="nc" id="L541">      MarkupMultiline remarks = keyField.getRemarks();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L543">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L545">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L547">    }</span>

    @Override
    public Void visitIndexConstraint(IIndexConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L551">      TargetedIndexConstraintType bean = state.addNewIndex();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L553">      applyCommonValues(constraint, bean);</span>
<span class="nc" id="L554">      applyKeyFields(constraint, bean);</span>

<span class="nc" id="L556">      bean.setName(constraint.getName());</span>

<span class="nc" id="L558">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L560">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L562">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L564">      return null;</span>
    }

    @Override
    public Void visitIndexHasKeyConstraint(IIndexHasKeyConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L569">      TargetedIndexHasKeyConstraintType bean = state.addNewIndexHasKey();</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L571">      applyCommonValues(constraint, bean);</span>
<span class="nc" id="L572">      applyKeyFields(constraint, bean);</span>

<span class="nc" id="L574">      bean.setName(constraint.getIndexName());</span>

<span class="nc" id="L576">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L578">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L580">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L582">      return null;</span>
    }

    @Override
    public Void visitUniqueConstraint(IUniqueConstraint constraint, DefineAssemblyConstraintsType state) {
<span class="nc" id="L587">      TargetedIndexHasKeyConstraintType bean = state.addNewIndexHasKey();</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">      assert bean != null;</span>
<span class="nc" id="L589">      applyCommonValues(constraint, bean);</span>
<span class="nc" id="L590">      applyKeyFields(constraint, bean);</span>

<span class="nc" id="L592">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L594">        RemarksType remarksType = bean.addNewRemarks();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">        assert remarksType != null;</span>
<span class="nc" id="L596">        XmlbeansMarkupWriter.visit(remarks, MetaschemaConstants.METASCHEMA_NAMESPACE, remarksType);</span>
      }
<span class="nc" id="L598">      return null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>