<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultConstraintValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.constraint</a> &gt; <span class="el_source">DefaultConstraintValidator.java</span></div><h1>DefaultConstraintValidator.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.constraint;

import gov.nist.secauto.metaschema.core.configuration.DefaultConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IConfiguration;
import gov.nist.secauto.metaschema.core.configuration.IMutableConfiguration;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.MetapathException;
import gov.nist.secauto.metaschema.core.metapath.MetapathExpression;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnBoolean;
import gov.nist.secauto.metaschema.core.metapath.function.library.FnData;
import gov.nist.secauto.metaschema.core.metapath.item.node.AbstractNodeItemVisitor;
import gov.nist.secauto.metaschema.core.metapath.item.node.IAssemblyNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDefinitionNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IFieldNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IFlagNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IModuleNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItem;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFieldDefinition;
import gov.nist.secauto.metaschema.core.model.IFlagDefinition;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Used to perform constraint validation over one or more node items.
 * &lt;p&gt;
 * This class is not thread safe.
 */
@SuppressWarnings({
    &quot;PMD.CouplingBetweenObjects&quot;,
    &quot;PMD.GodClass&quot; // provides validators for all types
})
public class DefaultConstraintValidator
    implements IConstraintValidator, IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; { // NOPMD - intentional
<span class="fc" id="L60">  private static final Logger LOGGER = LogManager.getLogger(DefaultConstraintValidator.class);</span>

<span class="fc" id="L62">  @NonNull</span>
  private final Map&lt;INodeItem, ValueStatus&gt; valueMap = new LinkedHashMap&lt;&gt;(); // NOPMD - intentional
<span class="fc" id="L64">  @NonNull</span>
  private final Map&lt;String, IIndex&gt; indexNameToIndexMap = new ConcurrentHashMap&lt;&gt;();
<span class="fc" id="L66">  @NonNull</span>
  private final Map&lt;String, List&lt;KeyRef&gt;&gt; indexNameToKeyRefMap = new ConcurrentHashMap&lt;&gt;();
  @NonNull
  private final IConstraintValidationHandler handler;
  @NonNull
  private final IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; configuration;

  /**
   * Construct a new constraint validator instance.
   *
   * @param handler
   *          the validation handler to use for handling constraint violations
   */
  public DefaultConstraintValidator(
<span class="fc" id="L80">      @NonNull IConstraintValidationHandler handler) {</span>
<span class="fc" id="L81">    this.handler = handler;</span>
<span class="fc" id="L82">    this.configuration = new DefaultConfiguration&lt;&gt;();</span>
<span class="fc" id="L83">  }</span>

  /**
   * Get the current configuration of the serializer/deserializer.
   *
   * @return the configuration
   */
  @NonNull
  protected IMutableConfiguration&lt;ValidationFeature&lt;?&gt;&gt; getConfiguration() {
<span class="fc" id="L92">    return configuration;</span>
  }

  @Override
  public DefaultConstraintValidator enableFeature(ValidationFeature&lt;?&gt; feature) {
<span class="nc" id="L97">    return set(feature, true);</span>
  }

  @Override
  public DefaultConstraintValidator disableFeature(ValidationFeature&lt;?&gt; feature) {
<span class="nc" id="L102">    return set(feature, false);</span>
  }

  @Override
  public DefaultConstraintValidator applyConfiguration(
      @NonNull IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; other) {
<span class="nc" id="L108">    getConfiguration().applyConfiguration(other);</span>
<span class="nc" id="L109">    return this;</span>
  }

  @Override
  public DefaultConstraintValidator set(ValidationFeature&lt;?&gt; feature, Object value) {
<span class="nc" id="L114">    getConfiguration().set(feature, value);</span>
<span class="nc" id="L115">    return this;</span>
  }

  @Override
  public boolean isFeatureEnabled(ValidationFeature&lt;?&gt; feature) {
<span class="fc" id="L120">    return getConfiguration().isFeatureEnabled(feature);</span>
  }

  @Override
  public Map&lt;ValidationFeature&lt;?&gt;, Object&gt; getFeatureValues() {
<span class="nc" id="L125">    return getConfiguration().getFeatureValues();</span>
  }

  /**
   * Get the validation handler to use for handling constraint violations.
   *
   * @return the handler
   */
  @NonNull
  protected IConstraintValidationHandler getConstraintValidationHandler() {
<span class="fc" id="L135">    return handler;</span>
  }

  @Override
  public void validate(
      @NonNull INodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L142">    item.accept(new Visitor(), dynamicContext);</span>
<span class="fc" id="L143">  }</span>

  /**
   * Validate the provided flag item against any associated constraints.
   *
   * @param item
   *          the flag item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateFlag(
      @NonNull IFlagNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L160">    IFlagDefinition definition = item.getDefinition();</span>

<span class="fc" id="L162">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="fc" id="L163">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="fc" id="L164">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="fc" id="L165">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="fc" id="L166">  }</span>

  /**
   * Validate the provided field item against any associated constraints.
   *
   * @param item
   *          the field item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateField(
      @NonNull IFieldNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L183">    IFieldDefinition definition = item.getDefinition();</span>

<span class="nc" id="L185">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="nc" id="L186">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L187">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="nc" id="L188">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L189">  }</span>

  /**
   * Validate the provided assembly item against any associated constraints.
   *
   * @param item
   *          the assembly item to validate
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   * @throws MetapathException
   *           if an error occurred while evaluating a Metapath used in a
   *           constraint
   */
  protected void validateAssembly(
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L206">    IAssemblyDefinition definition = item.getDefinition();</span>

<span class="nc" id="L208">    validateExpect(definition.getExpectConstraints(), item, dynamicContext);</span>
<span class="nc" id="L209">    validateAllowedValues(definition.getAllowedValuesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L210">    validateIndexHasKey(definition.getIndexHasKeyConstraints(), item, dynamicContext);</span>
<span class="nc" id="L211">    validateMatches(definition.getMatchesConstraints(), item, dynamicContext);</span>
<span class="nc" id="L212">    validateHasCardinality(definition.getHasCardinalityConstraints(), item, dynamicContext);</span>
<span class="nc" id="L213">    validateIndex(definition.getIndexConstraints(), item, dynamicContext);</span>
<span class="nc" id="L214">    validateUnique(definition.getUniqueConstraints(), item, dynamicContext);</span>
<span class="nc" id="L215">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateHasCardinality( // NOPMD false positive
      @NonNull List&lt;? extends ICardinalityConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">    for (ICardinalityConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L238">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L239">        validateHasCardinality(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L240">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L241">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L242">      }</span>
<span class="nc" id="L243">    }</span>
<span class="nc" id="L244">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateHasCardinality(
      @NonNull ICardinalityConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L264">    int itemCount = targets.size();</span>

<span class="nc" id="L266">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>

<span class="nc" id="L268">    boolean violation = false;</span>
<span class="nc" id="L269">    Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">    if (minOccurs != null &amp;&amp; itemCount &lt; minOccurs) {</span>
<span class="nc" id="L271">      handler.handleCardinalityMinimumViolation(constraint, node, targets, dynamicContext);</span>
<span class="nc" id="L272">      violation = true;</span>
    }

<span class="nc" id="L275">    Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">    if (maxOccurs != null &amp;&amp; itemCount &gt; maxOccurs) {</span>
<span class="nc" id="L277">      handler.handleCardinalityMaximumViolation(constraint, node, targets, dynamicContext);</span>
<span class="nc" id="L278">      violation = true;</span>
    }

<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (!violation) {</span>
<span class="nc" id="L282">      handlePass(constraint, node, node, dynamicContext);</span>
    }
<span class="nc" id="L284">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateIndex(
      @NonNull List&lt;? extends IIndexConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">    for (IIndexConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L307">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L308">        validateIndex(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L309">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L310">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L311">      }</span>
<span class="nc" id="L312">    }</span>
<span class="nc" id="L313">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateIndex(
      @NonNull IIndexConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L336">    String indexName = constraint.getName();</span>

<span class="nc" id="L338">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">    if (indexNameToIndexMap.containsKey(indexName)) {</span>
<span class="nc" id="L340">      handler.handleIndexDuplicateViolation(constraint, node, dynamicContext);</span>
    } else {
<span class="nc" id="L342">      IIndex index = IIndex.newInstance(constraint.getKeyFields());</span>
<span class="nc" id="L343">      targets.stream()</span>
<span class="nc" id="L344">          .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            assert item != null;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (item.hasValue()) {</span>
              try {
<span class="nc" id="L348">                INodeItem oldItem = index.put(item, dynamicContext);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (oldItem == null) {</span>
<span class="nc" id="L350">                  handlePass(constraint, node, item, dynamicContext);</span>
                } else {
<span class="nc" id="L352">                  handler.handleIndexDuplicateKeyViolation(constraint, node, oldItem, item, dynamicContext);</span>
                }
<span class="nc" id="L354">              } catch (MetapathException ex) {</span>
<span class="nc" id="L355">                handler.handleKeyMatchError(constraint, node, item, ex, dynamicContext);</span>
<span class="nc" id="L356">              }</span>
            }
<span class="nc" id="L358">          });</span>
<span class="nc" id="L359">      indexNameToIndexMap.put(indexName, index);</span>
    }
<span class="nc" id="L361">  }</span>

  private void handlePass(
      @NonNull IConstraint constraint,
      @NonNull INodeItem node,
      @NonNull INodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">    if (isFeatureEnabled(ValidationFeature.VALIDATE_GENERATE_PASS_FINDINGS)) {</span>
<span class="nc" id="L369">      getConstraintValidationHandler().handlePass(constraint, node, item, dynamicContext);</span>
    }
<span class="fc" id="L371">  }</span>

  private void handleError(
      @NonNull IConstraint constraint,
      @NonNull INodeItem node,
      @NonNull Throwable ex,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L378">    getConstraintValidationHandler()</span>
<span class="nc" id="L379">        .handleError(constraint, node, toErrorMessage(constraint, node, ex), ex, dynamicContext);</span>
<span class="nc" id="L380">  }</span>

  @NonNull
  private static String toErrorMessage(
      @NonNull IConstraint constraint,
      @NonNull INodeItem item,
      @NonNull Throwable ex) {
<span class="nc" id="L387">    StringBuilder builder = new StringBuilder(128);</span>
<span class="nc" id="L388">    builder.append(&quot;A &quot;)</span>
<span class="nc" id="L389">        .append(constraint.getClass().getName())</span>
<span class="nc" id="L390">        .append(&quot; constraint&quot;);</span>

<span class="nc" id="L392">    String id = constraint.getId();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">    if (id == null) {</span>
<span class="nc" id="L394">      builder.append(&quot; targeting the metapath '&quot;)</span>
<span class="nc" id="L395">          .append(constraint.getTarget())</span>
<span class="nc" id="L396">          .append('\'');</span>
    } else {
<span class="nc" id="L398">      builder.append(&quot; with id '&quot;)</span>
<span class="nc" id="L399">          .append(id)</span>
<span class="nc" id="L400">          .append('\'');</span>
    }

<span class="nc" id="L403">    builder.append(&quot;, matching the item at path '&quot;)</span>
<span class="nc" id="L404">        .append(item.getMetapath())</span>
<span class="nc" id="L405">        .append(&quot;', resulted in an unexpected error. The error was: &quot;)</span>
<span class="nc" id="L406">        .append(ex.getLocalizedMessage());</span>
<span class="nc" id="L407">    return ObjectUtils.notNull(builder.toString());</span>
  }

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateUnique(
      @NonNull List&lt;? extends IUniqueConstraint&gt; constraints,
      @NonNull IAssemblyNodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc bnc" id="L427" title="All 2 branches missed.">    for (IUniqueConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L431">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L432">        validateUnique(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L433">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L434">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L435">      }</span>
<span class="nc" id="L436">    }</span>
<span class="nc" id="L437">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateUnique(
      @NonNull IUniqueConstraint constraint,
      @NonNull IAssemblyNodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {

<span class="nc" id="L461">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L462">    IIndex index = IIndex.newInstance(constraint.getKeyFields());</span>
<span class="nc" id="L463">    targets.stream()</span>
<span class="nc" id="L464">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">          assert item != null;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">          if (item.hasValue()) {</span>
            try {
<span class="nc" id="L468">              INodeItem oldItem = index.put(item, dynamicContext);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">              if (oldItem == null) {</span>
<span class="nc" id="L470">                handlePass(constraint, node, item, dynamicContext);</span>
              } else {
<span class="nc" id="L472">                handler.handleUniqueKeyViolation(constraint, node, oldItem, item, dynamicContext);</span>
              }
<span class="nc" id="L474">            } catch (MetapathException ex) {</span>
<span class="nc" id="L475">              handler.handleKeyMatchError(constraint, node, item, ex, dynamicContext);</span>
<span class="nc" id="L476">              throw ex;</span>
<span class="nc" id="L477">            }</span>
          }
<span class="nc" id="L479">        });</span>
<span class="nc" id="L480">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateMatches( // NOPMD false positive
      @NonNull List&lt;? extends IMatchesConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {

<span class="pc bpc" id="L500" title="1 of 2 branches missed.">    for (IMatchesConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L504">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L505">        validateMatches(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L506">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L507">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L508">      }</span>
<span class="nc" id="L509">    }</span>
<span class="fc" id="L510">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateMatches(
      @NonNull IMatchesConstraint constraint,
      @NonNull INodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L530">    targets.stream()</span>
<span class="nc" id="L531">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">          assert item != null;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">          if (item.hasValue()) {</span>
<span class="nc" id="L534">            validateMatchesItem(constraint, node, item, dynamicContext);</span>
          }
<span class="nc" id="L536">        });</span>
<span class="nc" id="L537">  }</span>

  private void validateMatchesItem(
      @NonNull IMatchesConstraint constraint,
      @NonNull INodeItem node,
      @NonNull INodeItem item,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L544">    String value = FnData.fnDataItem(item).asString();</span>

<span class="nc" id="L546">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L547">    boolean valid = true;</span>
<span class="nc" id="L548">    Pattern pattern = constraint.getPattern();</span>
<span class="nc bnc" id="L549" title="All 4 branches missed.">    if (pattern != null &amp;&amp; !pattern.asMatchPredicate().test(value)) {</span>
      // failed pattern match
<span class="nc" id="L551">      handler.handleMatchPatternViolation(constraint, node, item, value, pattern, dynamicContext);</span>
<span class="nc" id="L552">      valid = false;</span>
    }

<span class="nc" id="L555">    IDataTypeAdapter&lt;?&gt; adapter = constraint.getDataType();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">    if (adapter != null) {</span>
      try {
<span class="nc" id="L558">        adapter.parse(value);</span>
<span class="nc" id="L559">      } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L560">        handler.handleMatchDatatypeViolation(constraint, node, item, value, adapter, ex, dynamicContext);</span>
<span class="nc" id="L561">        valid = false;</span>
<span class="nc" id="L562">      }</span>
    }

<span class="nc bnc" id="L565" title="All 2 branches missed.">    if (valid) {</span>
<span class="nc" id="L566">      handlePass(constraint, node, item, dynamicContext);</span>
    }
<span class="nc" id="L568">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateIndexHasKey( // NOPMD false positive
      @NonNull List&lt;? extends IIndexHasKeyConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {

<span class="pc bpc" id="L588" title="1 of 2 branches missed.">    for (IIndexHasKeyConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L592">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L593">        validateIndexHasKey(constraint, item, targets);</span>
<span class="nc" id="L594">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L595">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L596">      }</span>
<span class="nc" id="L597">    }</span>
<span class="fc" id="L598">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   */
  private void validateIndexHasKey(
      @NonNull IIndexHasKeyConstraint constraint,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets) {
<span class="nc" id="L617">    String indexName = constraint.getIndexName();</span>

<span class="nc" id="L619">    List&lt;KeyRef&gt; keyRefItems = indexNameToKeyRefMap.get(indexName);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">    if (keyRefItems == null) {</span>
<span class="nc" id="L621">      keyRefItems = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L622">      indexNameToKeyRefMap.put(indexName, keyRefItems);</span>
    }

<span class="nc" id="L625">    KeyRef keyRef = new KeyRef(constraint, node, new ArrayList&lt;&gt;(targets.getValue()));</span>
<span class="nc" id="L626">    keyRefItems.add(keyRef);</span>
<span class="nc" id="L627">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateExpect(
      @NonNull List&lt;? extends IExpectConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">    for (IExpectConstraint constraint : constraints) {</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">      assert constraint != null;</span>

      try {
<span class="nc" id="L650">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="nc" id="L651">        validateExpect(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L652">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L653">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L654">      }</span>
<span class="nc" id="L655">    }</span>
<span class="fc" id="L656">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  private void validateExpect(
      @NonNull IExpectConstraint constraint,
      @NonNull INodeItem node,
      @NonNull ISequence&lt;? extends INodeItem&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L679">    MetapathExpression metapath = MetapathExpression.compile(</span>
<span class="nc" id="L680">        constraint.getTest(),</span>
<span class="nc" id="L681">        dynamicContext.getStaticContext());</span>

<span class="nc" id="L683">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="nc" id="L684">    targets.stream()</span>
<span class="nc" id="L685">        .forEachOrdered(item -&gt; {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">          assert item != null;</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">          if (item.hasValue()) {</span>
            try {
<span class="nc" id="L690">              ISequence&lt;?&gt; result = metapath.evaluate(item, dynamicContext);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">              if (FnBoolean.fnBoolean(result).toBoolean()) {</span>
<span class="nc" id="L692">                handlePass(constraint, node, item, dynamicContext);</span>
              } else {
<span class="nc" id="L694">                handler.handleExpectViolation(constraint, node, item, dynamicContext);</span>
              }
<span class="nc" id="L696">            } catch (MetapathException ex) {</span>
<span class="nc" id="L697">              handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L698">            }</span>
          }
<span class="nc" id="L700">        });</span>
<span class="nc" id="L701">  }</span>

  /**
   * Evaluates the provided collection of {@code constraints} in the context of
   * the {@code item}.
   *
   * @param constraints
   *          the constraints to execute
   * @param item
   *          the focus of Metapath evaluation
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateAllowedValues(
      @NonNull List&lt;? extends IAllowedValuesConstraint&gt; constraints,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; item,
      @NonNull DynamicContext dynamicContext) {
<span class="fc bfc" id="L720" title="All 2 branches covered.">    for (IAllowedValuesConstraint constraint : constraints) {</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">      assert constraint != null;</span>
      try {
<span class="fc" id="L723">        ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets = constraint.matchTargets(item, dynamicContext);</span>
<span class="fc" id="L724">        validateAllowedValues(constraint, item, targets, dynamicContext);</span>
<span class="nc" id="L725">      } catch (RuntimeException ex) {</span>
<span class="nc" id="L726">        handleError(constraint, item, ex, dynamicContext);</span>
<span class="fc" id="L727">      }</span>
<span class="fc" id="L728">    }</span>
<span class="fc" id="L729">  }</span>

  /**
   * Evaluates the provided {@code constraint} against each of the
   * {@code targets}.
   *
   * @param constraint
   *          the constraint to execute
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   * @param targets
   *          the focus of Metapath evaluation for evaluating any constraint
   *          Metapath clauses
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  private void validateAllowedValues(
      @NonNull IAllowedValuesConstraint constraint,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node,
      @NonNull ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; targets,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L753">    targets.stream().forEachOrdered(item -&gt; {</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">      assert item != null;</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">      if (item.hasValue()) {</span>
        try {
<span class="fc" id="L757">          updateValueStatus(item, constraint, node);</span>
<span class="nc" id="L758">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L759">          handleError(constraint, item, ex, dynamicContext);</span>
<span class="fc" id="L760">        }</span>
      }
<span class="fc" id="L762">    });</span>
<span class="fc" id="L763">  }</span>

  /**
   * Add a new allowed value to the value status tracker.
   *
   * @param targetItem
   *          the item whose value is targeted by the constraint
   * @param allowedValues
   *          the allowed values constraint
   * @param node
   *          the original focus of Metapath evaluation for identifying the
   *          targets
   */
  protected void updateValueStatus(
      @NonNull INodeItem targetItem,
      @NonNull IAllowedValuesConstraint allowedValues,
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; node) {
    // constraint.getAllowedValues().containsKey(value)

    @Nullable
<span class="fc" id="L783">    ValueStatus valueStatus = valueMap.get(targetItem);</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">    if (valueStatus == null) {</span>
<span class="fc" id="L785">      valueStatus = new ValueStatus(targetItem);</span>
<span class="fc" id="L786">      valueMap.put(targetItem, valueStatus);</span>
    }

<span class="fc" id="L789">    valueStatus.registerAllowedValue(allowedValues, node);</span>
<span class="fc" id="L790">  }</span>

  /**
   * Evaluate the value associated with the {@code targetItem} and update the
   * status tracker.
   *
   * @param targetItem
   *          the item whose value will be validated
   * @param dynamicContext
   *          the Metapath dynamic execution context to use for Metapath
   *          evaluation
   */
  protected void handleAllowedValues(
      @NonNull INodeItem targetItem,
      @NonNull DynamicContext dynamicContext) {
<span class="fc" id="L805">    ValueStatus valueStatus = valueMap.remove(targetItem);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">    if (valueStatus != null) {</span>
<span class="fc" id="L807">      valueStatus.validate(dynamicContext);</span>
    }
<span class="fc" id="L809">  }</span>

  @SuppressWarnings(&quot;PMD.AvoidCatchingGenericException&quot;)
  @Override
  public void finalizeValidation(DynamicContext dynamicContext) {
    // key references
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">    for (Map.Entry&lt;String, List&lt;KeyRef&gt;&gt; entry : indexNameToKeyRefMap.entrySet()) {</span>
<span class="nc" id="L816">      String indexName = ObjectUtils.notNull(entry.getKey());</span>
<span class="nc" id="L817">      IIndex index = indexNameToIndexMap.get(indexName);</span>

<span class="nc" id="L819">      List&lt;KeyRef&gt; keyRefs = entry.getValue();</span>

<span class="nc bnc" id="L821" title="All 2 branches missed.">      for (KeyRef keyRef : keyRefs) {</span>
<span class="nc" id="L822">        IIndexHasKeyConstraint constraint = keyRef.getConstraint();</span>

<span class="nc" id="L824">        INodeItem node = keyRef.getNode();</span>
<span class="nc" id="L825">        List&lt;INodeItem&gt; targets = keyRef.getTargets();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        for (INodeItem item : targets) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">          assert item != null;</span>
          try {
<span class="nc" id="L829">            validateKeyRef(constraint, node, item, indexName, index, dynamicContext);</span>
<span class="nc" id="L830">          } catch (RuntimeException ex) {</span>
<span class="nc" id="L831">            handleError(constraint, item, ex, dynamicContext);</span>
<span class="nc" id="L832">          }</span>
<span class="nc" id="L833">        }</span>
<span class="nc" id="L834">      }</span>
<span class="nc" id="L835">    }</span>
<span class="fc" id="L836">  }</span>

  private void validateKeyRef(
      @NonNull IIndexHasKeyConstraint constraint,
      @NonNull INodeItem contextNode,
      @NonNull INodeItem item,
      @NonNull String indexName,
      @Nullable IIndex index,
      @NonNull DynamicContext dynamicContext) {
<span class="nc" id="L845">    IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
    try {
<span class="nc" id="L847">      List&lt;String&gt; key = IIndex.toKey(item, constraint.getKeyFields(), dynamicContext);</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">      if (index == null) {</span>
<span class="nc" id="L850">        handler.handleMissingIndexViolation(</span>
            constraint,
            contextNode,
            item,
<span class="nc" id="L854">            ObjectUtils.notNull(String.format(&quot;Key reference to undefined index with name '%s'&quot;,</span>
                indexName)),
            dynamicContext);
      } else {
<span class="nc" id="L858">        INodeItem referencedItem = index.get(key);</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (referencedItem == null) {</span>
<span class="nc" id="L861">          handler.handleIndexMiss(constraint, contextNode, item, key, dynamicContext);</span>
        } else {
<span class="nc" id="L863">          handlePass(constraint, contextNode, item, dynamicContext);</span>
        }
      }
<span class="nc" id="L866">    } catch (MetapathException ex) {</span>
<span class="nc" id="L867">      handler.handleKeyMatchError(constraint, contextNode, item, ex, dynamicContext);</span>
<span class="nc" id="L868">    }</span>
<span class="nc" id="L869">  }</span>

  private class ValueStatus {
<span class="fc" id="L872">    @NonNull</span>
    private final List&lt;Pair&lt;IAllowedValuesConstraint, IDefinitionNodeItem&lt;?, ?&gt;&gt;&gt; constraints = new LinkedList&lt;&gt;();
    @NonNull
    private final String value;
    @NonNull
    private final INodeItem item;
<span class="fc" id="L878">    private boolean allowOthers = true;</span>
<span class="fc" id="L879">    @NonNull</span>
    private IAllowedValuesConstraint.Extensible extensible = IAllowedValuesConstraint.Extensible.EXTERNAL;

<span class="fc" id="L882">    public ValueStatus(@NonNull INodeItem item) {</span>
<span class="fc" id="L883">      this.item = item;</span>
<span class="fc" id="L884">      this.value = FnData.fnDataItem(item).asString();</span>
<span class="fc" id="L885">    }</span>

    public void registerAllowedValue(
        @NonNull IAllowedValuesConstraint allowedValues,
        @NonNull IDefinitionNodeItem&lt;?, ?&gt; node) {
<span class="fc" id="L890">      this.constraints.add(Pair.of(allowedValues, node));</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">      if (!allowedValues.isAllowedOther()) {</span>
        // record the most restrictive value
<span class="fc" id="L893">        allowOthers = false;</span>
      }

<span class="fc" id="L896">      IAllowedValuesConstraint.Extensible newExtensible = allowedValues.getExtensible();</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">      if (newExtensible.ordinal() &gt; extensible.ordinal()) {</span>
        // record the most restrictive value
<span class="nc" id="L899">        extensible = allowedValues.getExtensible();</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">      } else if (IAllowedValuesConstraint.Extensible.NONE.equals(newExtensible)</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">          &amp;&amp; IAllowedValuesConstraint.Extensible.NONE.equals(extensible)) {</span>
        // this is an error, where there are two none constraints that conflict
<span class="nc" id="L903">        throw new MetapathException(</span>
<span class="nc" id="L904">            String.format(&quot;Multiple constraints have extensibility scope=none at path '%s'&quot;, item.getMetapath()));</span>
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">      } else if (allowedValues.getExtensible().ordinal() &lt; extensible.ordinal()) {</span>
<span class="nc" id="L906">        String msg = String.format(</span>
            &quot;An allowed values constraint with an extensibility scope '%s'&quot;
                + &quot; exceeds the allowed scope '%s' at path '%s'&quot;,
<span class="nc" id="L909">            allowedValues.getExtensible().name(), extensible.name(), item.getMetapath());</span>
<span class="nc" id="L910">        LOGGER.atError().log(msg);</span>
<span class="nc" id="L911">        throw new MetapathException(msg);</span>
      }
<span class="fc" id="L913">    }</span>

    public void validate(@NonNull DynamicContext dynamicContext) {
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">      if (!constraints.isEmpty()) {</span>
<span class="fc" id="L917">        boolean match = false;</span>
<span class="fc" id="L918">        List&lt;IAllowedValuesConstraint&gt; failedConstraints = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L919">        IConstraintValidationHandler handler = getConstraintValidationHandler();</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">        for (Pair&lt;IAllowedValuesConstraint, IDefinitionNodeItem&lt;?, ?&gt;&gt; pair : constraints) {</span>
<span class="fc" id="L921">          IAllowedValuesConstraint allowedValues = pair.getLeft();</span>
<span class="fc" id="L922">          IDefinitionNodeItem&lt;?, ?&gt; node = ObjectUtils.notNull(pair.getRight());</span>
<span class="fc" id="L923">          IAllowedValue matchingValue = allowedValues.getAllowedValue(value);</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">          if (matchingValue != null) {</span>
<span class="fc" id="L925">            match = true;</span>
<span class="fc" id="L926">            handlePass(allowedValues, node, item, dynamicContext);</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">          } else if (IAllowedValuesConstraint.Extensible.NONE.equals(allowedValues.getExtensible())) {</span>
            // hard failure, since no other values can satisfy this constraint
<span class="nc" id="L929">            failedConstraints = CollectionUtil.singletonList(allowedValues);</span>
<span class="nc" id="L930">            match = false;</span>
<span class="nc" id="L931">            break;</span>
          } else {
<span class="fc" id="L933">            failedConstraints.add(allowedValues);</span>
          } // this constraint passes, but we need to make sure other constraints do as well
<span class="fc" id="L935">        }</span>

        // it's not a failure if allow others is true
<span class="fc bfc" id="L938" title="All 4 branches covered.">        if (!match &amp;&amp; !allowOthers) {</span>
<span class="fc" id="L939">          handler.handleAllowedValuesViolation(failedConstraints, item, dynamicContext);</span>
        }
      }
<span class="fc" id="L942">    }</span>
  }

<span class="fc" id="L945">  class Visitor</span>
      extends AbstractNodeItemVisitor&lt;DynamicContext, Void&gt; {

    @NonNull
    private DynamicContext handleLetStatements(
        @NonNull INodeItem focus,
        @NonNull Map&lt;QName, ILet&gt; letExpressions,
        @NonNull DynamicContext dynamicContext) {

      DynamicContext retval;
<span class="fc" id="L955">      Collection&lt;ILet&gt; lets = letExpressions.values();</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">      if (lets.isEmpty()) {</span>
<span class="fc" id="L957">        retval = dynamicContext;</span>
      } else {
<span class="nc" id="L959">        final DynamicContext subContext = dynamicContext.subContext();</span>

<span class="nc bnc" id="L961" title="All 2 branches missed.">        for (ILet let : lets) {</span>
<span class="nc" id="L962">          QName name = let.getName();</span>
<span class="nc" id="L963">          ISequence&lt;?&gt; result = let.getValueExpression().evaluate(focus, subContext);</span>

          // ensure the sequence is list backed
<span class="nc" id="L966">          result.getValue();</span>

<span class="nc" id="L968">          subContext.bindVariableValue(name, result);</span>
<span class="nc" id="L969">        }</span>
<span class="nc" id="L970">        retval = subContext;</span>
      }
<span class="fc" id="L972">      return retval;</span>
    }

    @Override
    public Void visitFlag(@NonNull IFlagNodeItem item, DynamicContext context) {
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">      assert context != null;</span>

<span class="fc" id="L979">      IFlagDefinition definition = item.getDefinition();</span>
<span class="fc" id="L980">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="fc" id="L982">      validateFlag(item, effectiveContext);</span>
<span class="fc" id="L983">      super.visitFlag(item, effectiveContext);</span>
<span class="fc" id="L984">      handleAllowedValues(item, context);</span>
<span class="fc" id="L985">      return null;</span>
    }

    @Override
    public Void visitField(@NonNull IFieldNodeItem item, DynamicContext context) {
<span class="nc bnc" id="L990" title="All 2 branches missed.">      assert context != null;</span>

<span class="nc" id="L992">      IFieldDefinition definition = item.getDefinition();</span>
<span class="nc" id="L993">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="nc" id="L995">      validateField(item, effectiveContext);</span>
<span class="nc" id="L996">      super.visitField(item, effectiveContext);</span>
<span class="nc" id="L997">      handleAllowedValues(item, context);</span>
<span class="nc" id="L998">      return null;</span>
    }

    @Override
    public Void visitAssembly(@NonNull IAssemblyNodeItem item, DynamicContext context) {
<span class="nc bnc" id="L1003" title="All 2 branches missed.">      assert context != null;</span>

<span class="nc" id="L1005">      IAssemblyDefinition definition = item.getDefinition();</span>
<span class="nc" id="L1006">      DynamicContext effectiveContext = handleLetStatements(item, definition.getLetExpressions(), context);</span>

<span class="nc" id="L1008">      validateAssembly(item, effectiveContext);</span>
<span class="nc" id="L1009">      super.visitAssembly(item, effectiveContext);</span>
<span class="nc" id="L1010">      return null;</span>
    }

    @Override
    public Void visitMetaschema(@NonNull IModuleNodeItem item, DynamicContext context) {
<span class="nc" id="L1015">      throw new UnsupportedOperationException(&quot;not needed&quot;);</span>
    }

    @Override
    protected Void defaultResult() {
      // no result value
<span class="fc" id="L1021">      return null;</span>
    }
  }

  private static class KeyRef {
    @NonNull
    private final IIndexHasKeyConstraint constraint;
    @NonNull
    private final INodeItem node;
    @NonNull
    private final List&lt;INodeItem&gt; targets;

    public KeyRef(
        @NonNull IIndexHasKeyConstraint constraint,
        @NonNull INodeItem node,
<span class="nc" id="L1036">        @NonNull List&lt;INodeItem&gt; targets) {</span>
<span class="nc" id="L1037">      this.node = node;</span>
<span class="nc" id="L1038">      this.constraint = constraint;</span>
<span class="nc" id="L1039">      this.targets = targets;</span>
<span class="nc" id="L1040">    }</span>

    @NonNull
    public IIndexHasKeyConstraint getConstraint() {
<span class="nc" id="L1044">      return constraint;</span>
    }

    @NonNull
    protected INodeItem getNode() {
<span class="nc" id="L1049">      return node;</span>
    }

    @NonNull
    public List&lt;INodeItem&gt; getTargets() {
<span class="nc" id="L1054">      return targets;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>