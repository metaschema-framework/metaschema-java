<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlEventUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.util</a> &gt; <span class="el_source">XmlEventUtil.java</span></div><h1>XmlEventUtil.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.util;

import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.codehaus.stax2.XMLEventReader2;
import org.codehaus.stax2.XMLStreamReader2;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Characters;
import javax.xml.stream.events.EndElement;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

public final class XmlEventUtil { // NOPMD this is a set of utility methods
<span class="fc" id="L34">  private static final Pattern WHITESPACE_ONLY = Pattern.compile(&quot;^\\s+$&quot;);</span>

<span class="fc" id="L36">  private static final Map&lt;Integer, String&gt; EVENT_NAME_MAP = new HashMap&lt;&gt;(); // NOPMD - this value is immutable</span>

  static {
<span class="fc" id="L39">    EVENT_NAME_MAP.put(XMLStreamConstants.START_ELEMENT, &quot;START_ELEMENT&quot;);</span>
<span class="fc" id="L40">    EVENT_NAME_MAP.put(XMLStreamConstants.END_ELEMENT, &quot;END_ELEMENT&quot;);</span>
<span class="fc" id="L41">    EVENT_NAME_MAP.put(XMLStreamConstants.PROCESSING_INSTRUCTION, &quot;PROCESSING_INSTRUCTION&quot;);</span>
<span class="fc" id="L42">    EVENT_NAME_MAP.put(XMLStreamConstants.CHARACTERS, &quot;CHARACTERS&quot;);</span>
<span class="fc" id="L43">    EVENT_NAME_MAP.put(XMLStreamConstants.COMMENT, &quot;COMMENT&quot;);</span>
<span class="fc" id="L44">    EVENT_NAME_MAP.put(XMLStreamConstants.SPACE, &quot;SPACE&quot;);</span>
<span class="fc" id="L45">    EVENT_NAME_MAP.put(XMLStreamConstants.START_DOCUMENT, &quot;START_DOCUMENT&quot;);</span>
<span class="fc" id="L46">    EVENT_NAME_MAP.put(XMLStreamConstants.END_DOCUMENT, &quot;END_DOCUMENT&quot;);</span>
<span class="fc" id="L47">    EVENT_NAME_MAP.put(XMLStreamConstants.ENTITY_REFERENCE, &quot;ENTITY_REFERENCE&quot;);</span>
<span class="fc" id="L48">    EVENT_NAME_MAP.put(XMLStreamConstants.ATTRIBUTE, &quot;ATTRIBUTE&quot;);</span>
<span class="fc" id="L49">    EVENT_NAME_MAP.put(XMLStreamConstants.DTD, &quot;DTD&quot;);</span>
<span class="fc" id="L50">    EVENT_NAME_MAP.put(XMLStreamConstants.CDATA, &quot;CDATA&quot;);</span>
<span class="fc" id="L51">    EVENT_NAME_MAP.put(XMLStreamConstants.NAMESPACE, &quot;XML_NAMESPACE&quot;);</span>
<span class="fc" id="L52">    EVENT_NAME_MAP.put(XMLStreamConstants.NOTATION_DECLARATION, &quot;NOTATION_DECLARATION&quot;);</span>
<span class="fc" id="L53">    EVENT_NAME_MAP.put(XMLStreamConstants.ENTITY_DECLARATION, &quot;ENTITY_DECLARATION&quot;);</span>
<span class="fc" id="L54">  }</span>

  private XmlEventUtil() {
    // disable construction
  }

  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  private static Object escape(@NonNull String data) {
<span class="nc" id="L63">    return data.chars()</span>
<span class="nc" id="L64">        .mapToObj(c -&gt; (char) c)</span>
<span class="nc" id="L65">        .map(XmlEventUtil::escape).collect(Collectors.joining());</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  private static String escape(char ch) {
    String retval;
<span class="nc bnc" id="L72" title="All 3 branches missed.">    switch (ch) {</span>
    case '\n':
<span class="nc" id="L74">      retval = &quot;\\n&quot;;</span>
<span class="nc" id="L75">      break;</span>
    case '\r':
<span class="nc" id="L77">      retval = &quot;\\r&quot;;</span>
<span class="nc" id="L78">      break;</span>
    default:
<span class="nc" id="L80">      retval = String.valueOf(ch);</span>
      break;
    }
<span class="nc" id="L83">    return retval;</span>
  }

  /**
   * Generate a message suitable for logging that describes the provided
   * {@link XMLEvent}.
   *
   * @param xmlEvent
   *          the XML event to generate the message for
   * @return the message
   */
  @NonNull
  public static CharSequence toString(XMLEvent xmlEvent) {
    CharSequence retval;
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    if (xmlEvent == null) {</span>
<span class="nc" id="L98">      retval = &quot;EOF&quot;;</span>
    } else {
      @SuppressWarnings(&quot;null&quot;)
      @NonNull
<span class="fc" id="L102">      StringBuilder builder = new StringBuilder()</span>
<span class="fc" id="L103">          .append(toEventName(xmlEvent));</span>
<span class="fc" id="L104">      QName name = toQName(xmlEvent);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      if (name != null) {</span>
<span class="fc" id="L106">        builder.append(&quot;: &quot;).append(name.toString());</span>
      }
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">      if (xmlEvent.isCharacters()) {</span>
<span class="nc" id="L109">        String text = xmlEvent.asCharacters().getData();</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L111">          builder.append(&quot; '&quot;).append(escape(text)).append('\'');</span>
        }
      }
<span class="fc" id="L114">      Location location = toLocation(xmlEvent);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">      if (location != null) {</span>
<span class="fc" id="L116">        builder.append(&quot; at &quot;).append(toString(location));</span>
      }
<span class="fc" id="L118">      retval = builder;</span>
    }
<span class="fc" id="L120">    return retval;</span>
  }

  /**
   * Generates a message for the provided {@link Location}.
   *
   * @param location
   *          the location to generate the message for
   * @return the message
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static CharSequence toString(@Nullable Location location) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    return location == null ? &quot;unknown&quot;</span>
        : new StringBuilder()
<span class="fc" id="L135">            .append(location.getLineNumber())</span>
<span class="fc" id="L136">            .append(':')</span>
<span class="fc" id="L137">            .append(location.getColumnNumber());</span>
  }

  /**
   * Generates a string containing the current event and location of the stream
   * reader.
   *
   * @param reader
   *          the XML event stream reader
   * @return the generated string
   */
  @NonNull
  public static CharSequence toString(@NonNull XMLStreamReader2 reader) { // NO_UCD (unused code)
<span class="nc" id="L150">    int type = reader.getEventType();</span>

    @SuppressWarnings(&quot;null&quot;)
    @NonNull
<span class="nc" id="L154">    StringBuilder builder = new StringBuilder().append(toEventName(type));</span>
<span class="nc" id="L155">    QName name = reader.getName();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (name != null) {</span>
<span class="nc" id="L157">      builder.append(&quot;: &quot;).append(name.toString());</span>
    }
<span class="nc bnc" id="L159" title="All 2 branches missed.">    if (XMLStreamConstants.CHARACTERS == type) {</span>
<span class="nc" id="L160">      String text = reader.getText();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      if (text != null) {</span>
<span class="nc" id="L162">        builder.append(&quot; '&quot;).append(escape(text)).append('\'');</span>
      }
    }
<span class="nc" id="L165">    Location location = reader.getLocation();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (location != null) {</span>
<span class="nc" id="L167">      builder.append(&quot; at &quot;).append(toString(location));</span>
    }
<span class="nc" id="L169">    return builder;</span>
  }

  /**
   * Retrieve the resource location of {@code event}.
   *
   * @param event
   *          the XML event to identify the location for
   * @return the location or {@code null} if the location is unknown
   */
  @Nullable
  public static Location toLocation(@NonNull XMLEvent event) {
<span class="fc" id="L181">    Location retval = null;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">    if (event.isStartElement()) {</span>
<span class="fc" id="L183">      StartElement start = event.asStartElement();</span>
<span class="fc" id="L184">      retval = start.getLocation();</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">    } else if (event.isEndElement()) {</span>
<span class="nc" id="L186">      EndElement end = event.asEndElement();</span>
<span class="nc" id="L187">      retval = end.getLocation();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    } else if (event.isCharacters()) {</span>
<span class="nc" id="L189">      Characters characters = event.asCharacters();</span>
<span class="nc" id="L190">      retval = characters.getLocation();</span>
    }
<span class="fc" id="L192">    return retval;</span>
  }

  /**
   * Retrieve the name of the node associated with {@code event}.
   *
   * @param event
   *          the XML event to get the {@link QName} for
   * @return the name of the node or {@code null} if the event is not a start or
   *         end element
   */
  @Nullable
  public static QName toQName(@NonNull XMLEvent event) {
<span class="fc" id="L205">    QName retval = null;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">    if (event.isStartElement()) {</span>
<span class="fc" id="L207">      StartElement start = event.asStartElement();</span>
<span class="fc" id="L208">      retval = start.getName();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    } else if (event.isEndElement()) {</span>
<span class="fc" id="L210">      EndElement end = event.asEndElement();</span>
<span class="fc" id="L211">      retval = end.getName();</span>
    }
<span class="fc" id="L213">    return retval;</span>
  }

  /**
   * Get the event name of the {@code event}.
   *
   * @param event
   *          the XML event to get the event name for
   * @return the event name
   */
  @NonNull
  public static String toEventName(@NonNull XMLEvent event) {
<span class="fc" id="L225">    return toEventName(event.getEventType());</span>
  }

  /**
   * Get the event name of the {@code eventType}, which is one of the types
   * defined by {@link XMLStreamConstants}.
   *
   * @param eventType
   *          the event constant to get the event name for as defined by
   *          {@link XMLStreamConstants}
   * @return the event name
   */
  @NonNull
  public static String toEventName(int eventType) {
<span class="fc" id="L239">    String retval = EVENT_NAME_MAP.get(eventType);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (retval == null) {</span>
<span class="nc" id="L241">      retval = &quot;unknown event '&quot; + Integer.toString(eventType) + &quot;'&quot;;</span>
    }
<span class="fc" id="L243">    return retval;</span>
  }

  /**
   * Advance through XMLEvents until the event type identified by
   * {@code eventType} is reached or the end of stream is found.
   *
   * @param reader
   *          the XML event reader to advance
   * @param eventType
   *          the event type to stop on as defined by {@link XMLStreamConstants}
   * @return the next event of the specified type or {@code null} if the end of
   *         stream is reached
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @Nullable
  public static XMLEvent advanceTo(@NonNull XMLEventReader2 reader, int eventType)
      throws XMLStreamException { // NO_UCD (unused code)
    XMLEvent xmlEvent;
    do {
<span class="nc" id="L264">      xmlEvent = reader.nextEvent();</span>
      // if (LOGGER.isWarnEnabled()) {
      // LOGGER.warn(&quot;skipping over: {}&quot;, XmlEventUtil.toString(xmlEvent));
      // }
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (xmlEvent.isStartElement()) {</span>
<span class="nc" id="L269">        advanceTo(reader, XMLStreamConstants.END_ELEMENT);</span>
        // skip this end element
<span class="nc" id="L271">        xmlEvent = reader.nextEvent();</span>
        // if (LOGGER.isDebugEnabled()) {
        // LOGGER.debug(&quot;skipping over: {}&quot;, XmlEventUtil.toString(xmlEvent));
        // }
      }
<span class="nc bnc" id="L276" title="All 4 branches missed.">    } while (reader.hasNext() &amp;&amp; (xmlEvent = reader.peek()).getEventType() != eventType);</span>
<span class="nc" id="L277">    return xmlEvent;</span>
  }

  /**
   * Skip over the next element in the event stream.
   *
   * @param reader
   *          the XML event stream reader
   * @return the next XML event
   * @throws XMLStreamException
   *           if an error occurred while reading the event stream
   */
  @SuppressWarnings(&quot;PMD.OnlyOneReturn&quot;)
  public static XMLEvent skipElement(@NonNull XMLEventReader2 reader) throws XMLStreamException {
<span class="nc" id="L291">    XMLEvent xmlEvent = reader.peek();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    if (!xmlEvent.isStartElement()) {</span>
<span class="nc" id="L293">      return xmlEvent;</span>
    }
    // if (LOGGER.isInfoEnabled()) {
    // LOGGER.atInfo().log(String.format(&quot;At location %s&quot;, toString(xmlEvent)));
    // }

<span class="nc" id="L299">    int depth = 0;</span>
    do {
<span class="nc" id="L301">      xmlEvent = reader.nextEvent();</span>
      // if (LOGGER.isInfoEnabled()) {
      // LOGGER.atInfo().log(String.format(&quot;Skipping %s&quot;, toString(xmlEvent)));
      // }
<span class="nc bnc" id="L305" title="All 2 branches missed.">      if (xmlEvent.isStartElement()) {</span>
<span class="nc" id="L306">        depth++;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      } else if (xmlEvent.isEndElement()) {</span>
<span class="nc" id="L308">        depth--;</span>
      }
<span class="nc bnc" id="L310" title="All 4 branches missed.">    } while (depth &gt; 0 &amp;&amp; reader.hasNext());</span>
<span class="nc" id="L311">    return reader.peek();</span>
  }

  /**
   * Skip over any processing instructions.
   *
   * @param reader
   *          the XML event reader to advance
   * @return the last processing instruction event or the reader's next event if
   *         no processing instruction was found
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @NonNull
  public static XMLEvent skipProcessingInstructions(@NonNull XMLEventReader2 reader) throws XMLStreamException {
    XMLEvent nextEvent;
<span class="nc bnc" id="L327" title="All 2 branches missed.">    while ((nextEvent = reader.peek()).isProcessingInstruction()) {</span>
<span class="nc" id="L328">      nextEvent = reader.nextEvent();</span>
    }
<span class="nc" id="L330">    return nextEvent;</span>
  }

  /**
   * Skip over any whitespace.
   *
   * @param reader
   *          the XML event reader to advance
   * @return the last character event containing whitespace or the reader's next
   *         event if no character event was found
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static XMLEvent skipWhitespace(@NonNull XMLEventReader2 reader) throws XMLStreamException {
    @NonNull
    XMLEvent nextEvent;
<span class="fc bfc" id="L348" title="All 2 branches covered.">    while ((nextEvent = reader.peek()).isCharacters()) {</span>
<span class="fc" id="L349">      Characters characters = nextEvent.asCharacters();</span>
<span class="fc" id="L350">      String data = characters.getData();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">      if (!WHITESPACE_ONLY.matcher(data).matches()) {</span>
<span class="nc" id="L352">        break;</span>
      }
<span class="fc" id="L354">      nextEvent = reader.nextEvent();</span>
<span class="fc" id="L355">    }</span>
<span class="fc" id="L356">    return nextEvent;</span>
  }

  /**
   * Determine if the {@code event} is an end element whose name matches the
   * provided {@code expectedQName}.
   *
   * @param event
   *          the XML event
   * @param expectedQName
   *          the expected element name
   * @return {@code true} if the next event matches the {@code expectedQName}
   */
  public static boolean isEventEndElement(XMLEvent event, @NonNull QName expectedQName) {
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">    return event != null</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        &amp;&amp; event.isEndElement()</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        &amp;&amp; expectedQName.equals(event.asEndElement().getName());</span>
  }

  /**
   * Determine if the {@code event} is an end of document event.
   *
   * @param event
   *          the XML event
   * @return {@code true} if the next event is an end of document event
   */
  public static boolean isEventEndDocument(XMLEvent event) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">    return event != null</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        &amp;&amp; event.isEndElement();</span>
  }

  /**
   * Determine if the {@code event} is a start element whose name matches the
   * provided {@code expectedQName}.
   *
   * @param event
   *          the event
   * @param expectedQName
   *          the expected element name
   * @return {@code true} if the next event is a start element that matches the
   *         {@code expectedQName}
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static boolean isEventStartElement(XMLEvent event, @NonNull QName expectedQName) throws XMLStreamException {
<span class="nc bnc" id="L401" title="All 2 branches missed.">    return event != null</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        &amp;&amp; event.isStartElement()</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        &amp;&amp; expectedQName.equals(event.asStartElement().getName());</span>
  }

  /**
   * Consume the next event from {@code reader} and assert that this event is of
   * the type identified by {@code presumedEventType}.
   *
   * @param reader
   *          the XML event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static XMLEvent consumeAndAssert(XMLEventReader2 reader, int presumedEventType)
      throws XMLStreamException {
<span class="nc" id="L420">    return consumeAndAssert(reader, presumedEventType, null);</span>
  }

  /**
   * Consume the next event from {@code reader} and assert that this event is of
   * the type identified by {@code presumedEventType} and has the name identified
   * by {@code presumedName}.
   *
   * @param reader
   *          the XML event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @param presumedName
   *          the expected name of the node associated with the event
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static XMLEvent consumeAndAssert(XMLEventReader2 reader, int presumedEventType, QName presumedName)
      throws XMLStreamException {
<span class="nc" id="L440">    XMLEvent retval = reader.nextEvent();</span>

<span class="nc" id="L442">    int eventType = retval.getEventType();</span>
<span class="nc" id="L443">    QName name = toQName(retval);</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">    assert eventType == presumedEventType</span>
        &amp;&amp; (presumedName == null
<span class="nc bnc" id="L446" title="All 2 branches missed.">            || presumedName.equals(name)) : generateExpectedMessage(</span>
                retval,
                presumedEventType,
                presumedName);
<span class="nc" id="L450">    return retval;</span>
  }

  /**
   * Ensure that the next event is an XML start element that matches the presumed
   * name.
   *
   * @param reader
   *          the XML event reader
   * @param presumedName
   *          the qualified name of the expected next event
   * @return the XML start element event
   * @throws IOException
   *           if an error occurred while parsing the resource
   * @throws XMLStreamException
   *           if an error occurred while parsing the XML event stream
   */
  @NonNull
  public static StartElement requireStartElement(
      @NonNull XMLEventReader2 reader,
      @NonNull QName presumedName) throws IOException, XMLStreamException {
<span class="nc" id="L471">    XMLEvent retval = reader.nextEvent();</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">    if (!retval.isStartElement() || !presumedName.equals(retval.asStartElement().getName())) {</span>
<span class="nc" id="L473">      throw new IOException(generateExpectedMessage(</span>
          retval,
          XMLStreamConstants.START_ELEMENT,
<span class="nc" id="L476">          presumedName).toString());</span>
    }
<span class="nc" id="L478">    return ObjectUtils.notNull(retval.asStartElement());</span>
  }

  /**
   * Ensure that the next event is an XML start element that matches the presumed
   * name.
   *
   * @param reader
   *          the XML event reader
   * @param presumedName
   *          the qualified name of the expected next event
   * @return the XML start element event
   * @throws IOException
   *           if an error occurred while parsing the resource
   * @throws XMLStreamException
   *           if an error occurred while parsing the XML event stream
   */
  @NonNull
  public static EndElement requireEndElement(
      @NonNull XMLEventReader2 reader,
      @NonNull QName presumedName) throws IOException, XMLStreamException {
<span class="nc" id="L499">    XMLEvent retval = reader.nextEvent();</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">    if (!retval.isEndElement() || !presumedName.equals(retval.asEndElement().getName())) {</span>
<span class="nc" id="L501">      throw new IOException(generateExpectedMessage(</span>
          retval,
          XMLStreamConstants.END_ELEMENT,
<span class="nc" id="L504">          presumedName).toString());</span>
    }
<span class="nc" id="L506">    return ObjectUtils.notNull(retval.asEndElement());</span>
  }

  /**
   * Ensure that the next event from {@code reader} is of the type identified by
   * {@code presumedEventType}.
   *
   * @param reader
   *          the event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   * @throws AssertionError
   *           if the next event does not match the presumed event
   */
  public static XMLEvent assertNext(
      @NonNull XMLEventReader2 reader,
      int presumedEventType)
      throws XMLStreamException {
<span class="nc" id="L527">    return assertNext(reader, presumedEventType, null);</span>
  }

  /**
   * Ensure that the next event from {@code reader} is of the type identified by
   * {@code presumedEventType} and has the name identified by
   * {@code presumedName}.
   *
   * @param reader
   *          the event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @param presumedName
   *          the expected name of the node associated with the event
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   * @throws AssertionError
   *           if the next event does not match the presumed event
   */
  public static XMLEvent assertNext(
      @NonNull XMLEventReader2 reader,
      int presumedEventType,
      @Nullable QName presumedName)
      throws XMLStreamException {
<span class="fc" id="L552">    XMLEvent nextEvent = reader.peek();</span>

<span class="fc" id="L554">    int eventType = nextEvent.getEventType();</span>
<span class="pc bpc" id="L555" title="2 of 4 branches missed.">    assert eventType == presumedEventType</span>
        &amp;&amp; (presumedName == null
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            || presumedName.equals(toQName(nextEvent))) : generateExpectedMessage(</span>
                nextEvent,
                presumedEventType,
                presumedName);
<span class="fc" id="L561">    return nextEvent;</span>
  }

  /**
   * Generate a location string for the current location in the XML event stream.
   *
   * @param event
   *          an XML event
   * @return the location string
   */
  public static CharSequence generateLocationMessage(@NonNull XMLEvent event) {
<span class="nc" id="L572">    Location location = toLocation(event);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    return location == null ? &quot;&quot; : generateLocationMessage(location);</span>
  }

  /**
   * Generate a location string for the current location in the XML event stream.
   *
   * @param location
   *          an XML event stream location
   * @return the location string
   */
  public static CharSequence generateLocationMessage(@NonNull Location location) {
<span class="nc" id="L584">    return new StringBuilder(12)</span>
<span class="nc" id="L585">        .append(&quot; at &quot;)</span>
<span class="nc" id="L586">        .append(XmlEventUtil.toString(location));</span>
  }

  /**
   * Generate a message intended for error reporting based on a presumed event.
   *
   * @param event
   *          the current XML event
   * @param presumedEventType
   *          the expected event type ({@link XMLEvent#getEventType()})
   * @param presumedName
   *          the expected event qualified name or {@code null} if there is no
   *          expectation
   * @return the message string
   */
  public static CharSequence generateExpectedMessage(
      @Nullable XMLEvent event,
      int presumedEventType,
      @Nullable QName presumedName) {
<span class="nc" id="L605">    StringBuilder builder = new StringBuilder(64);</span>
<span class="nc" id="L606">    builder</span>
<span class="nc" id="L607">        .append(&quot;Expected XML &quot;)</span>
<span class="nc" id="L608">        .append(toEventName(presumedEventType));</span>

<span class="nc bnc" id="L610" title="All 2 branches missed.">    if (presumedName != null) {</span>
<span class="nc" id="L611">      builder.append(&quot; for QName '&quot;)</span>
<span class="nc" id="L612">          .append(presumedName.toString());</span>
    }

<span class="nc bnc" id="L615" title="All 2 branches missed.">    if (event == null) {</span>
<span class="nc" id="L616">      builder.append(&quot;', instead found null event&quot;);</span>
    } else {
<span class="nc" id="L618">      builder.append(&quot;', instead found &quot;)</span>
<span class="nc" id="L619">          .append(toString(event));</span>
    }
<span class="nc" id="L621">    return builder;</span>
  }

  /**
   * Skips events specified by {@code events}.
   *
   * @param reader
   *          the event reader
   * @param events
   *          the events to skip
   * @return the next non-mataching event returned by
   *         {@link XMLEventReader2#peek()}, or {@code null} if there was no next
   *         event
   * @throws XMLStreamException
   *           if an error occurred while reading
   */
  public static XMLEvent skipEvents(XMLEventReader2 reader, int... events) throws XMLStreamException {
<span class="nc" id="L638">    Set&lt;Integer&gt; skipEvents = IntStream.of(events).boxed().collect(Collectors.toSet());</span>

<span class="nc" id="L640">    XMLEvent nextEvent = null;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">    while (reader.hasNext()) {</span>
<span class="nc" id="L642">      nextEvent = reader.peek();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">      if (!skipEvents.contains(nextEvent.getEventType())) {</span>
<span class="nc" id="L644">        break;</span>
      }
<span class="nc" id="L646">      reader.nextEvent();</span>
    }
<span class="nc" id="L648">    return nextEvent;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>