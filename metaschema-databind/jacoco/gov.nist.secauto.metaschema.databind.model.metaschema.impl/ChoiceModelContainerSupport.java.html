<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChoiceModelContainerSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.model.metaschema.impl</a> &gt; <span class="el_source">ChoiceModelContainerSupport.java</span></div><h1>ChoiceModelContainerSupport.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.model.metaschema.impl;

import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItemFactory;
import gov.nist.secauto.metaschema.core.model.IAssemblyInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.IChoiceInstance;
import gov.nist.secauto.metaschema.core.model.IContainerModelSupport;
import gov.nist.secauto.metaschema.core.model.IFieldInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.IModelInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.INamedModelInstanceAbsolute;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedAssembly;
import gov.nist.secauto.metaschema.databind.model.metaschema.binding.AssemblyReference;
import gov.nist.secauto.metaschema.databind.model.metaschema.binding.FieldReference;
import gov.nist.secauto.metaschema.databind.model.metaschema.binding.InlineDefineAssembly;
import gov.nist.secauto.metaschema.databind.model.metaschema.binding.InlineDefineField;
import gov.nist.secauto.metaschema.databind.model.metaschema.binding.AssemblyModel.Choice;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

<span class="fc" id="L37">class ChoiceModelContainerSupport</span>
    extends AbstractBindingModelContainerSupport {
  @NonNull
  private final List&lt;IModelInstanceAbsolute&gt; modelInstances;
  @NonNull
  private final Map&lt;QName, INamedModelInstanceAbsolute&gt; namedModelInstances;
  @NonNull
  private final Map&lt;QName, IFieldInstanceAbsolute&gt; fieldInstances;
  @NonNull
  private final Map&lt;QName, IAssemblyInstanceAbsolute&gt; assemblyInstances;

  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static IContainerModelSupport&lt;
      IModelInstanceAbsolute,
      INamedModelInstanceAbsolute,
      IFieldInstanceAbsolute,
      IAssemblyInstanceAbsolute&gt; of(
          @Nullable Choice binding,
          @NonNull IBoundInstanceModelGroupedAssembly bindingInstance,
          @NonNull IChoiceInstance parent,
          @NonNull INodeItemFactory nodeItemFactory) {
    List&lt;Object&gt; instances;
<span class="pc bpc" id="L59" title="3 of 6 branches missed.">    return binding == null || (instances = binding.getChoices()) == null || instances.isEmpty()</span>
<span class="nc" id="L60">        ? IContainerModelSupport.empty()</span>
<span class="fc" id="L61">        : new ChoiceModelContainerSupport(</span>
            binding,
            bindingInstance,
            parent,
            nodeItemFactory);
  }

  /**
   * Construct a new assembly model container.
   *
   * @param binding
   *          the choice model object bound to a Java class
   * @param bindingInstance
   *          the Metaschema module instance for the bound model object
   * @param parent
   *          the assembly definition containing this container
   * @param nodeItemFactory
   *          the node item factory used to generate child nodes
   */
  @SuppressWarnings({ &quot;PMD.AvoidInstantiatingObjectsInLoops&quot;, &quot;PMD.UseConcurrentHashMap&quot;, &quot;PMD.PrematureDeclaration&quot; })
  @SuppressFBWarnings(value = &quot;CT_CONSTRUCTOR_THROW&quot;, justification = &quot;Use of final fields&quot;)
  public ChoiceModelContainerSupport(
      @NonNull Choice binding,
      @NonNull IBoundInstanceModelGroupedAssembly bindingInstance,
      @NonNull IChoiceInstance parent,
<span class="fc" id="L86">      @NonNull INodeItemFactory nodeItemFactory) {</span>

    // create temporary collections to store the child binding objects
<span class="fc" id="L89">    final List&lt;IModelInstanceAbsolute&gt; modelInstances = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L90">    final Map&lt;QName, INamedModelInstanceAbsolute&gt; namedModelInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L91">    final Map&lt;QName, IFieldInstanceAbsolute&gt; fieldInstances = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L92">    final Map&lt;QName, IAssemblyInstanceAbsolute&gt; assemblyInstances = new LinkedHashMap&lt;&gt;();</span>

    // create counters to track child positions
<span class="fc" id="L95">    AtomicInteger assemblyReferencePosition = new AtomicInteger();</span>
<span class="fc" id="L96">    AtomicInteger assemblyInlineDefinitionPosition = new AtomicInteger();</span>
<span class="fc" id="L97">    AtomicInteger fieldReferencePosition = new AtomicInteger();</span>
<span class="fc" id="L98">    AtomicInteger fieldInlineDefinitionPosition = new AtomicInteger();</span>

    // TODO: make &quot;instances&quot; a constant
<span class="fc" id="L101">    IBoundInstanceModelChoiceGroup instance = ObjectUtils.requireNonNull(</span>
<span class="fc" id="L102">        bindingInstance.getDefinition().getChoiceGroupInstanceByName(&quot;choices&quot;));</span>

<span class="fc" id="L104">    ObjectUtils.notNull(binding.getChoices()).forEach(obj -&gt; {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">      assert obj != null;</span>
<span class="fc" id="L106">      IBoundInstanceModelGroupedAssembly objInstance</span>
<span class="fc" id="L107">          = (IBoundInstanceModelGroupedAssembly) instance.getItemInstance(obj);</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">      if (obj instanceof AssemblyReference) {</span>
<span class="fc" id="L110">        addInstance(</span>
<span class="fc" id="L111">            newInstance(</span>
                (AssemblyReference) obj,
                objInstance,
<span class="fc" id="L114">                assemblyReferencePosition.getAndIncrement(),</span>
                parent),
            modelInstances,
            namedModelInstances,
            assemblyInstances);
<span class="fc bfc" id="L119" title="All 2 branches covered.">      } else if (obj instanceof InlineDefineAssembly) {</span>
<span class="fc" id="L120">        IAssemblyInstanceAbsolute assembly = new InstanceModelAssemblyInline(</span>
            (InlineDefineAssembly) obj,
            objInstance,
<span class="fc" id="L123">            assemblyInlineDefinitionPosition.getAndIncrement(),</span>
            parent,
            nodeItemFactory);
<span class="fc" id="L126">        addInstance(assembly, modelInstances, namedModelInstances, assemblyInstances);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">      } else if (obj instanceof FieldReference) {</span>
<span class="fc" id="L128">        IFieldInstanceAbsolute field = newInstance(</span>
            (FieldReference) obj,
            objInstance,
<span class="fc" id="L131">            fieldReferencePosition.getAndIncrement(),</span>
            parent);
<span class="fc" id="L133">        addInstance(field, modelInstances, namedModelInstances, fieldInstances);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">      } else if (obj instanceof InlineDefineField) {</span>
<span class="fc" id="L135">        IFieldInstanceAbsolute field = new InstanceModelFieldInline(</span>
            (InlineDefineField) obj,
            objInstance,
<span class="fc" id="L138">            fieldInlineDefinitionPosition.getAndIncrement(),</span>
            parent);
<span class="fc" id="L140">        addInstance(field, modelInstances, namedModelInstances, fieldInstances);</span>
<span class="fc" id="L141">      } else {</span>
<span class="nc" id="L142">        throw new UnsupportedOperationException(String.format(&quot;Unknown model instance class: %s&quot;, obj.getClass()));</span>
      }
<span class="fc" id="L144">    });</span>

<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    this.modelInstances = modelInstances.isEmpty()</span>
<span class="nc" id="L147">        ? CollectionUtil.emptyList()</span>
<span class="fc" id="L148">        : CollectionUtil.unmodifiableList(modelInstances);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">    this.namedModelInstances = namedModelInstances.isEmpty()</span>
<span class="nc" id="L150">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L151">        : CollectionUtil.unmodifiableMap(namedModelInstances);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    this.fieldInstances = fieldInstances.isEmpty()</span>
<span class="fc" id="L153">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L154">        : CollectionUtil.unmodifiableMap(fieldInstances);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">    this.assemblyInstances = assemblyInstances.isEmpty()</span>
<span class="fc" id="L156">        ? CollectionUtil.emptyMap()</span>
<span class="fc" id="L157">        : CollectionUtil.unmodifiableMap(assemblyInstances);</span>
<span class="fc" id="L158">  }</span>

  @Override
  public List&lt;IModelInstanceAbsolute&gt; getModelInstances() {
<span class="fc" id="L162">    return modelInstances;</span>
  }

  @Override
  public Map&lt;QName, INamedModelInstanceAbsolute&gt; getNamedModelInstanceMap() {
<span class="nc" id="L167">    return namedModelInstances;</span>
  }

  @Override
  public Map&lt;QName, IFieldInstanceAbsolute&gt; getFieldInstanceMap() {
<span class="nc" id="L172">    return fieldInstances;</span>
  }

  @Override
  public Map&lt;QName, IAssemblyInstanceAbsolute&gt; getAssemblyInstanceMap() {
<span class="nc" id="L177">    return assemblyInstances;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>