<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaschemaXmlReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.io.xml</a> &gt; <span class="el_source">MetaschemaXmlReader.java</span></div><h1>MetaschemaXmlReader.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.io.xml;

import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.util.XmlEventUtil;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.io.BindingException;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundFieldValue;
import gov.nist.secauto.metaschema.databind.model.IBoundInstance;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceFlag;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModel;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldScalar;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedField;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedNamed;
import gov.nist.secauto.metaschema.databind.model.info.AbstractModelInstanceReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IFeatureScalarItemValueHandler;
import gov.nist.secauto.metaschema.databind.model.info.IItemReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IModelInstanceCollectionInfo;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.codehaus.stax2.XMLEventReader2;

import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

public class MetaschemaXmlReader
    implements IXmlParsingContext {
<span class="fc" id="L61">  private static final Logger LOGGER = LogManager.getLogger(MetaschemaXmlReader.class);</span>
  @NonNull
  private final XMLEventReader2 reader;
  @NonNull
  private final IXmlProblemHandler problemHandler;

  /**
   * Construct a new Module-aware XML parser using the default problem handler.
   *
   * @param reader
   *          the XML reader to parse with
   * @see DefaultXmlProblemHandler
   */
  public MetaschemaXmlReader(
      @NonNull XMLEventReader2 reader) {
<span class="fc" id="L76">    this(reader, new DefaultXmlProblemHandler());</span>
<span class="fc" id="L77">  }</span>

  public &lt;ITEM&gt; ITEM readItem(
      @NonNull IBoundObject item,
      @NonNull IBoundInstance&lt;ITEM&gt; instance,
      @NonNull StartElement start) throws IOException {
<span class="nc" id="L83">    return instance.readItem(item, new ItemReadHandler(start));</span>
  }

  /**
   * Construct a new Module-aware parser.
   *
   * @param reader
   *          the XML reader to parse with
   * @param problemHandler
   *          the problem handler implementation to use
   */
  public MetaschemaXmlReader(
      @NonNull XMLEventReader2 reader,
<span class="fc" id="L96">      @NonNull IXmlProblemHandler problemHandler) {</span>
<span class="fc" id="L97">    this.reader = reader;</span>
<span class="fc" id="L98">    this.problemHandler = problemHandler;</span>
<span class="fc" id="L99">  }</span>

  @Override
  public XMLEventReader2 getReader() {
<span class="fc" id="L103">    return reader;</span>
  }

  @Override
  public IXmlProblemHandler getProblemHandler() {
<span class="fc" id="L108">    return problemHandler;</span>
  }

  /**
   * Parses XML into a bound object based on the provided {@code definition}.
   * &lt;p&gt;
   * Parses the {@link XMLStreamConstants#START_DOCUMENT}, any processing
   * instructions, and the element.
   *
   * @param &lt;CLASS&gt;
   *          the returned object type
   * @param definition
   *          the definition describing the element data to read
   * @return the parsed object
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  @Override
  @NonNull
  public &lt;CLASS&gt; CLASS read(@NonNull IBoundDefinitionModelComplex definition) throws IOException {
    try {
      // we may be at the START_DOCUMENT
<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (reader.peek().isStartDocument()) {</span>
<span class="fc" id="L131">        XmlEventUtil.consumeAndAssert(reader, XMLStreamConstants.START_DOCUMENT);</span>
      }

      // advance past any other info to get to next start element
<span class="fc" id="L135">      XmlEventUtil.skipEvents(reader, XMLStreamConstants.CHARACTERS, XMLStreamConstants.PROCESSING_INSTRUCTION,</span>
          XMLStreamConstants.DTD);

<span class="fc" id="L138">      XMLEvent event = ObjectUtils.requireNonNull(reader.peek());</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">      if (!event.isStartElement()) {</span>
<span class="nc" id="L140">        throw new IOException(</span>
<span class="nc" id="L141">            String.format(&quot;The token '%s' is not an XML element%s.&quot;,</span>
<span class="nc" id="L142">                XmlEventUtil.toEventName(event),</span>
<span class="nc" id="L143">                XmlEventUtil.generateLocationMessage(event)));</span>
      }

<span class="fc" id="L146">      ItemReadHandler handler = new ItemReadHandler(ObjectUtils.notNull(event.asStartElement()));</span>
<span class="fc" id="L147">      Object value = definition.readItem(null, handler);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L149">        event = reader.peek();</span>
<span class="nc" id="L150">        throw new IOException(String.format(&quot;Unable to read data.%s&quot;,</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            event == null ? &quot;&quot; : XmlEventUtil.generateLocationMessage(event)));</span>
      }

<span class="fc" id="L154">      return ObjectUtils.asType(value);</span>
<span class="nc" id="L155">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L156">      throw new IOException(ex);</span>
    }
  }

  /**
   * Read the XML attribute data described by the {@code targetDefinition} and
   * apply it to the provided {@code targetObject}.
   *
   * @param targetDefinition
   *          the Module definition that describes the syntax of the data to read
   * @param targetObject
   *          the Java object that data parsed by this method will be stored in
   * @param start
   *          the containing XML element that was previously parsed
   * @throws IOException
   *           if an error occurred while parsing the input
   * @throws XMLStreamException
   *           if an error occurred while parsing XML events
   */
  protected void readFlagInstances(
      @NonNull IBoundDefinitionModelComplex targetDefinition,
      @NonNull IBoundObject targetObject,
      @NonNull StartElement start) throws IOException, XMLStreamException {

<span class="fc" id="L180">    Map&lt;QName, IBoundInstanceFlag&gt; flagInstanceMap = targetDefinition.getFlagInstances().stream()</span>
<span class="fc" id="L181">        .collect(Collectors.toMap(</span>
            IBoundInstanceFlag::getXmlQName,
<span class="fc" id="L183">            Function.identity()));</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">    for (Attribute attribute : CollectionUtil.toIterable(ObjectUtils.notNull(start.getAttributes()))) {</span>
<span class="fc" id="L186">      QName qname = attribute.getName();</span>
<span class="fc" id="L187">      IBoundInstanceFlag instance = flagInstanceMap.get(qname);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      if (instance == null) {</span>
        // unrecognized flag
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (!getProblemHandler().handleUnknownAttribute(targetDefinition, targetObject, attribute, this)) {</span>
<span class="nc" id="L191">          throw new IOException(</span>
<span class="nc" id="L192">              String.format(&quot;Unrecognized attribute '%s'%s.&quot;,</span>
                  qname,
<span class="nc" id="L194">                  XmlEventUtil.generateLocationMessage(attribute)));</span>
        }
      } else {
        try {
          // get the attribute value
<span class="fc" id="L199">          Object value = instance.getDefinition().getJavaTypeAdapter().parse(ObjectUtils.notNull(attribute.getValue()));</span>
          // apply the value to the parentObject
<span class="fc" id="L201">          instance.setValue(targetObject, value);</span>
<span class="fc" id="L202">          flagInstanceMap.remove(qname);</span>
<span class="nc" id="L203">        } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L204">          throw new IOException(</span>
<span class="nc" id="L205">              String.format(&quot;Malformed data '%s'%s. %s&quot;,</span>
<span class="nc" id="L206">                  attribute.getValue(),</span>
<span class="nc" id="L207">                  XmlEventUtil.generateLocationMessage(start),</span>
<span class="nc" id="L208">                  ex.getLocalizedMessage()),</span>
              ex);
<span class="fc" id="L210">        }</span>
      }
<span class="fc" id="L212">    }</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (!flagInstanceMap.isEmpty()) {</span>
<span class="fc" id="L215">      getProblemHandler().handleMissingFlagInstances(</span>
          targetDefinition,
          targetObject,
<span class="fc" id="L218">          ObjectUtils.notNull(flagInstanceMap.values()));</span>
    }
<span class="fc" id="L220">  }</span>

  /**
   * Read the XML element data described by the {@code targetDefinition} and apply
   * it to the provided {@code targetObject}.
   *
   * @param targetDefinition
   *          the Module definition that describes the syntax of the data to read
   * @param targetObject
   *          the Java object that data parsed by this method will be stored in
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  protected void readModelInstances(
      @NonNull IBoundDefinitionModelAssembly targetDefinition,
      @NonNull IBoundObject targetObject)
      throws IOException {
<span class="fc" id="L237">    Collection&lt;? extends IBoundInstanceModel&lt;?&gt;&gt; instances = targetDefinition.getModelInstances();</span>
<span class="fc" id="L238">    Set&lt;IBoundInstanceModel&lt;?&gt;&gt; unhandledProperties = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">    for (IBoundInstanceModel&lt;?&gt; modelInstance : instances) {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      assert modelInstance != null;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (!readItems(modelInstance, targetObject, true)) {</span>
<span class="fc" id="L242">        unhandledProperties.add(modelInstance);</span>
      }
<span class="fc" id="L244">    }</span>

    // process all properties that did not get a value
<span class="fc" id="L247">    getProblemHandler().handleMissingModelInstances(targetDefinition, targetObject, unhandledProperties);</span>

    // handle any
    try {
<span class="fc bfc" id="L251" title="All 2 branches covered.">      if (!getReader().peek().isEndElement()) {</span>
        // handle any
<span class="fc" id="L253">        XmlEventUtil.skipWhitespace(getReader());</span>
<span class="fc" id="L254">        XmlEventUtil.skipElement(getReader());</span>
<span class="fc" id="L255">        XmlEventUtil.skipWhitespace(getReader());</span>
      }

<span class="fc" id="L258">      XmlEventUtil.assertNext(getReader(), XMLStreamConstants.END_ELEMENT);</span>
<span class="nc" id="L259">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L260">      throw new IOException(ex);</span>
<span class="fc" id="L261">    }</span>
<span class="fc" id="L262">  }</span>

  /**
   * Determine if the next data to read corresponds to the next model instance.
   *
   * @param targetInstance
   *          the model instance that describes the syntax of the data to read
   * @return {@code true} if the Module instance needs to be parsed, or
   *         {@code false} otherwise
   * @throws XMLStreamException
   *           if an error occurred while parsing XML events
   */
  @SuppressWarnings(&quot;PMD.OnlyOneReturn&quot;)
  protected boolean isNextInstance(
      @NonNull IBoundInstanceModel&lt;?&gt; targetInstance)
      throws XMLStreamException {

<span class="fc" id="L279">    XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc" id="L281">    XMLEvent nextEvent = reader.peek();</span>

<span class="fc" id="L283">    boolean retval = nextEvent.isStartElement();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">    if (retval) {</span>
<span class="fc" id="L285">      QName qname = ObjectUtils.notNull(nextEvent.asStartElement().getName());</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">      retval = qname.equals(targetInstance.getEffectiveXmlGroupAsQName()) // parse the grouping element</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">          || targetInstance.canHandleXmlQName(qname); // parse the instance(s)</span>
    }
<span class="fc" id="L289">    return retval;</span>
  }

  /**
   * Read the data associated with the {@code instance} and apply it to the
   * provided {@code parentObject}.
   *
   * @param instance
   *          the instance to parse data for
   * @param parentObject
   *          the Java object that data parsed by this method will be stored in
   * @return {@code true} if the instance was parsed, or {@code false} if the data
   *         did not contain information for this instance
   * @throws IOException
   *           if an error occurred while parsing the input
   */
  @Override
  public &lt;T&gt; boolean readItems(
      @NonNull IBoundInstanceModel&lt;T&gt; instance,
      @NonNull IBoundObject parentObject,
      boolean parseGrouping)
      throws IOException {
    try {
<span class="fc" id="L312">      boolean handled = isNextInstance(instance);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">      if (handled) {</span>
        // XmlEventUtil.skipWhitespace(reader);

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        QName groupQName = parseGrouping ? instance.getEffectiveXmlGroupAsQName() : null;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (groupQName != null) {</span>
          // we need to parse the grouping element, if the next token matches
<span class="fc" id="L319">          XmlEventUtil.requireStartElement(reader, groupQName);</span>
        }

<span class="fc" id="L322">        IModelInstanceCollectionInfo&lt;T&gt; collectionInfo = instance.getCollectionInfo();</span>

<span class="fc" id="L324">        ModelInstanceReadHandler&lt;T&gt; handler = new ModelInstanceReadHandler&lt;&gt;(instance, parentObject);</span>

        // let the property info decide how to parse the value
<span class="fc" id="L327">        Object value = collectionInfo.readItems(handler);</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L329">          instance.setValue(parentObject, value);</span>
        }

        // consume extra whitespace between elements
<span class="fc" id="L333">        XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (groupQName != null) {</span>
          // consume the end of the group
<span class="fc" id="L337">          XmlEventUtil.requireEndElement(reader, groupQName);</span>
        }
      }
<span class="fc" id="L340">      return handled;</span>
<span class="nc" id="L341">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L342">      throw new IOException(ex);</span>
    }
  }

<span class="fc" id="L346">  private final class ModelInstanceReadHandler&lt;ITEM&gt;</span>
      extends AbstractModelInstanceReadHandler&lt;ITEM&gt; {

    private ModelInstanceReadHandler(
        @NonNull IBoundInstanceModel&lt;ITEM&gt; instance,
<span class="fc" id="L351">        @NonNull IBoundObject parentObject) {</span>
<span class="fc" id="L352">      super(instance, parentObject);</span>
<span class="fc" id="L353">    }</span>

    @Override
    public List&lt;ITEM&gt; readList() throws IOException {
<span class="fc" id="L357">      return ObjectUtils.notNull(readCollection());</span>
    }

    @Override
    public Map&lt;String, ITEM&gt; readMap() throws IOException {
<span class="fc" id="L362">      IBoundInstanceModel&lt;?&gt; instance = getCollectionInfo().getInstance();</span>

<span class="fc" id="L364">      return ObjectUtils.notNull(readCollection().stream()</span>
<span class="fc" id="L365">          .collect(Collectors.toMap(</span>
              item -&gt; {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                assert item != null;</span>

<span class="fc" id="L369">                IBoundInstanceFlag jsonKey = instance.getItemJsonKey(item);</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                assert jsonKey != null;</span>
<span class="fc" id="L371">                return ObjectUtils.requireNonNull(jsonKey.getValue(item)).toString();</span>
              },
<span class="fc" id="L373">              Function.identity(),</span>
<span class="nc" id="L374">              (t, u) -&gt; u,</span>
              LinkedHashMap::new)));
    }

    @NonNull
    private List&lt;ITEM&gt; readCollection() throws IOException {
<span class="fc" id="L380">      List&lt;ITEM&gt; retval = new LinkedList&lt;&gt;();</span>
      try {
        // consume extra whitespace between elements
<span class="fc" id="L383">        XmlEventUtil.skipWhitespace(reader);</span>

<span class="fc" id="L385">        IBoundInstanceModel&lt;?&gt; instance = getCollectionInfo().getInstance();</span>
        XMLEvent event;
<span class="fc bfc" id="L387" title="All 2 branches covered.">        while ((event = reader.peek()).isStartElement()</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            &amp;&amp; instance.canHandleXmlQName(ObjectUtils.notNull(event.asStartElement().getName()))) {</span>

          // Consume the start element
<span class="fc" id="L391">          ITEM value = readItem();</span>
<span class="fc" id="L392">          retval.add(value);</span>

          // consume extra whitespace between elements
<span class="fc" id="L395">          XmlEventUtil.skipWhitespace(reader);</span>
<span class="fc" id="L396">        }</span>
<span class="nc" id="L397">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L398">        throw new IOException(ex);</span>
<span class="fc" id="L399">      }</span>
<span class="fc" id="L400">      return retval;</span>
    }

    @Override
    public ITEM readItem() throws IOException {
      try {
<span class="fc" id="L406">        return getCollectionInfo().getInstance().readItem(</span>
<span class="fc" id="L407">            getParentObject(),</span>
<span class="fc" id="L408">            new ItemReadHandler(ObjectUtils.notNull(getReader().peek().asStartElement())));</span>
<span class="nc" id="L409">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L410">        throw new IOException(ex);</span>
      }
    }
  }

<span class="fc" id="L415">  private final class ItemReadHandler implements IItemReadHandler {</span>
    @NonNull
    private final StartElement startElement;

<span class="fc" id="L419">    private ItemReadHandler(@NonNull StartElement startElement) {</span>
<span class="fc" id="L420">      this.startElement = startElement;</span>
<span class="fc" id="L421">    }</span>

    /**
     * Get the current start element.
     *
     * @return the startElement
     */
    @NonNull
    private StartElement getStartElement() {
<span class="fc" id="L430">      return startElement;</span>
    }

    @NonNull
    private &lt;DEF extends IBoundDefinitionModelComplex&gt; IBoundObject readDefinitionElement(
        @NonNull DEF definition,
        @NonNull StartElement start,
        @NonNull QName expectedQName,
        @Nullable IBoundObject parent,
        @NonNull DefinitionBodyHandler&lt;DEF, IBoundObject&gt; bodyHandler) throws IOException {
      try {
        // consume the start element
<span class="fc" id="L442">        XmlEventUtil.requireStartElement(reader, expectedQName);</span>

<span class="fc" id="L444">        Location location = start.getLocation();</span>

        // construct the item
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        IBoundObject item = definition.newInstance(location == null ? null : () -&gt; new MetaschemaData(location));</span>

        // call pre-parse initialization hook
<span class="fc" id="L450">        definition.callBeforeDeserialize(item, parent);</span>

        // read the flags
<span class="fc" id="L453">        readFlagInstances(definition, item, start);</span>

        // read the body
<span class="fc" id="L456">        bodyHandler.accept(definition, item);</span>

<span class="fc" id="L458">        XmlEventUtil.skipWhitespace(reader);</span>

        // call post-parse initialization hook
<span class="fc" id="L461">        definition.callAfterDeserialize(item, parent);</span>

        // consume the end element
<span class="fc" id="L464">        XmlEventUtil.requireEndElement(reader, expectedQName);</span>
<span class="fc" id="L465">        return ObjectUtils.asType(item);</span>
<span class="nc" id="L466">      } catch (BindingException | XMLStreamException ex) {</span>
<span class="nc" id="L467">        throw new IOException(ex);</span>
      }
    }

    @Override
    public Object readItemFlag(
        IBoundObject parent,
        IBoundInstanceFlag flag) throws IOException {
      // should never be called
<span class="nc" id="L476">      throw new UnsupportedOperationException(&quot;handled by readFlagInstances()&quot;);</span>
    }

    private void handleFieldDefinitionBody(
        @NonNull IBoundDefinitionModelFieldComplex definition,
        @NonNull IBoundObject item) throws IOException {
<span class="fc" id="L482">      IBoundFieldValue fieldValue = definition.getFieldValue();</span>

      // parse the value
<span class="fc" id="L485">      Object value = fieldValue.readItem(item, this);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">      if (value != null) {</span>
<span class="fc" id="L487">        fieldValue.setValue(item, value);</span>
      }
<span class="fc" id="L489">    }</span>

    @Override
    public Object readItemField(
        IBoundObject parent,
        IBoundInstanceModelFieldScalar instance)
        throws IOException {

      try {
<span class="fc" id="L498">        QName wrapper = null;</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (instance.isEffectiveValueWrappedInXml()) {</span>
<span class="fc" id="L500">          wrapper = instance.getXmlQName();</span>

<span class="fc" id="L502">          XmlEventUtil.skipWhitespace(getReader());</span>
<span class="fc" id="L503">          XmlEventUtil.requireStartElement(getReader(), wrapper);</span>
        }

<span class="fc" id="L506">        Object retval = readScalarItem(instance);</span>

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (wrapper != null) {</span>
<span class="fc" id="L509">          XmlEventUtil.skipWhitespace(getReader());</span>

<span class="fc" id="L511">          XmlEventUtil.requireEndElement(getReader(), wrapper);</span>
        }
<span class="fc" id="L513">        return retval;</span>
<span class="nc" id="L514">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L515">        throw new IOException(ex);</span>
      }
    }

    @Override
    public IBoundObject readItemField(
        IBoundObject parent,
        IBoundInstanceModelFieldComplex instance)
        throws IOException {
<span class="fc" id="L524">      return readDefinitionElement(</span>
<span class="fc" id="L525">          instance.getDefinition(),</span>
<span class="fc" id="L526">          getStartElement(),</span>
<span class="fc" id="L527">          instance.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public IBoundObject readItemField(IBoundObject parent, IBoundInstanceModelGroupedField instance)
        throws IOException {
<span class="nc" id="L535">      return readDefinitionElement(</span>
<span class="nc" id="L536">          instance.getDefinition(),</span>
<span class="nc" id="L537">          getStartElement(),</span>
<span class="nc" id="L538">          instance.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public IBoundObject readItemField(
        IBoundObject parent,
        IBoundDefinitionModelFieldComplex definition) throws IOException {
<span class="fc" id="L547">      return readDefinitionElement(</span>
          definition,
<span class="fc" id="L549">          getStartElement(),</span>
<span class="fc" id="L550">          definition.getXmlQName(),</span>
          parent,
          this::handleFieldDefinitionBody);
    }

    @Override
    public Object readItemFieldValue(
        IBoundObject parent,
        IBoundFieldValue fieldValue) throws IOException {
<span class="fc" id="L559">      return checkMissingFieldValue(readScalarItem(fieldValue));</span>
    }

    @Nullable
    private Object checkMissingFieldValue(Object value) throws IOException {
<span class="pc bpc" id="L564" title="1 of 4 branches missed.">      if (value == null &amp;&amp; LOGGER.isWarnEnabled()) {</span>
<span class="fc" id="L565">        StartElement start = getStartElement();</span>
<span class="fc" id="L566">        LOGGER.atWarn().log(&quot;Missing property value{}&quot;,</span>
<span class="fc" id="L567">            XmlEventUtil.generateLocationMessage(start));</span>
      }
<span class="fc" id="L569">      return value;</span>
    }

    private void handleAssemblyDefinitionBody(
        @NonNull IBoundDefinitionModelAssembly definition,
        @NonNull IBoundObject item) throws IOException {
<span class="fc" id="L575">      readModelInstances(definition, item);</span>
<span class="fc" id="L576">    }</span>

    @Override
    public IBoundObject readItemAssembly(
        IBoundObject parent,
        IBoundInstanceModelAssembly instance) throws IOException {
<span class="fc" id="L582">      return readDefinitionElement(</span>
<span class="fc" id="L583">          instance.getDefinition(),</span>
<span class="fc" id="L584">          getStartElement(),</span>
<span class="fc" id="L585">          instance.getXmlQName(),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @Override
    public IBoundObject readItemAssembly(IBoundObject parent, IBoundInstanceModelGroupedAssembly instance)
        throws IOException {
<span class="fc" id="L593">      return readDefinitionElement(</span>
<span class="fc" id="L594">          instance.getDefinition(),</span>
<span class="fc" id="L595">          getStartElement(),</span>
<span class="fc" id="L596">          instance.getXmlQName(),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @Override
    public IBoundObject readItemAssembly(
        IBoundObject parent,
        IBoundDefinitionModelAssembly definition) throws IOException {
<span class="fc" id="L605">      return readDefinitionElement(</span>
          definition,
<span class="fc" id="L607">          getStartElement(),</span>
<span class="fc" id="L608">          ObjectUtils.requireNonNull(definition.getRootXmlQName()),</span>
          parent,
          this::handleAssemblyDefinitionBody);
    }

    @Nullable
    private Object readScalarItem(@NonNull IFeatureScalarItemValueHandler handler)
        throws IOException {
<span class="fc" id="L616">      return handler.getJavaTypeAdapter().parse(getReader());</span>
    }

    @Override
    public IBoundObject readChoiceGroupItem(IBoundObject parent, IBoundInstanceModelChoiceGroup instance)
        throws IOException {
      try {
<span class="fc" id="L623">        XMLEventReader2 eventReader = getReader();</span>
        // consume extra whitespace between elements
<span class="fc" id="L625">        XmlEventUtil.skipWhitespace(eventReader);</span>

<span class="fc" id="L627">        XMLEvent event = eventReader.peek();</span>
<span class="fc" id="L628">        QName nextQName = ObjectUtils.notNull(event.asStartElement().getName());</span>
<span class="fc" id="L629">        IBoundInstanceModelGroupedNamed actualInstance = instance.getGroupedModelInstance(nextQName);</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">        assert actualInstance != null;</span>
<span class="fc" id="L631">        return actualInstance.readItem(parent, this);</span>
<span class="nc" id="L632">      } catch (XMLStreamException ex) {</span>
<span class="nc" id="L633">        throw new IOException(ex);</span>
      }
    }
  }

  private static class MetaschemaData implements IMetaschemaData {
    private final int line;
    private final int column;
    private final long charOffset;

<span class="fc" id="L643">    public MetaschemaData(@NonNull Location location) {</span>
<span class="fc" id="L644">      this.line = location.getLineNumber();</span>
<span class="fc" id="L645">      this.column = location.getColumnNumber();</span>
<span class="fc" id="L646">      this.charOffset = location.getCharacterOffset();</span>
<span class="fc" id="L647">    }</span>

    @Override
    public int getLine() {
<span class="nc" id="L651">      return line;</span>
    }

    @Override
    public int getColumn() {
<span class="nc" id="L656">      return column;</span>
    }

    @Override
    public long getCharOffset() {
<span class="nc" id="L661">      return charOffset;</span>
    }

    @Override
    public long getByteOffset() {
<span class="nc" id="L666">      return -1;</span>
    }
  }

  @FunctionalInterface
  private interface DefinitionBodyHandler&lt;DEF extends IBoundDefinitionModelComplex, ITEM&gt; {
    void accept(
        @NonNull DEF definition,
        @NonNull ITEM item) throws IOException;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>