<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstraintFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.model.impl</a> &gt; <span class="el_source">ConstraintFactory.java</span></div><h1>ConstraintFactory.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.model.impl;

import gov.nist.secauto.metaschema.core.datatype.DataTypeService;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.model.ISource;
import gov.nist.secauto.metaschema.core.model.constraint.AbstractConfigurableMessageConstraintBuilder;
import gov.nist.secauto.metaschema.core.model.constraint.AbstractConstraintBuilder;
import gov.nist.secauto.metaschema.core.model.constraint.AbstractKeyConstraintBuilder;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValue;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValuesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ICardinalityConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IExpectConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexHasKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyField;
import gov.nist.secauto.metaschema.core.model.constraint.ILet;
import gov.nist.secauto.metaschema.core.model.constraint.IMatchesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IUniqueConstraint;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.databind.model.annotations.Expect;
import gov.nist.secauto.metaschema.databind.model.annotations.HasCardinality;
import gov.nist.secauto.metaschema.databind.model.annotations.Index;
import gov.nist.secauto.metaschema.databind.model.annotations.IndexHasKey;
import gov.nist.secauto.metaschema.databind.model.annotations.IsUnique;
import gov.nist.secauto.metaschema.databind.model.annotations.KeyField;
import gov.nist.secauto.metaschema.databind.model.annotations.Let;
import gov.nist.secauto.metaschema.databind.model.annotations.Matches;
import gov.nist.secauto.metaschema.databind.model.annotations.ModelUtil;
import gov.nist.secauto.metaschema.databind.model.annotations.NullJavaTypeAdapter;
import gov.nist.secauto.metaschema.databind.model.annotations.Property;

import java.util.Arrays;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
final class ConstraintFactory {
  private ConstraintFactory() {
    // disable
  }

  static MarkupMultiline toRemarks(@NonNull String remarks) {
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">    return remarks.isBlank() ? null : MarkupMultiline.fromMarkdown(remarks);</span>
  }

  @NonNull
  static String toMetapath(@NonNull String metapath) {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">    return metapath.isBlank() ? IConstraint.DEFAULT_TARGET_METAPATH : metapath;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyId(@NonNull T builder, @NonNull String id) {
<span class="fc bfc" id="L67" title="All 2 branches covered.">    if (!id.isBlank()) {</span>
<span class="fc" id="L68">      builder.identifier(id);</span>
    }
<span class="fc" id="L70">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyFormalName(@NonNull T builder, @NonNull String name) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (!name.isBlank()) {</span>
<span class="fc" id="L76">      builder.formalName(name);</span>
    }
<span class="fc" id="L78">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyDescription(@NonNull T builder, @NonNull String value) {
<span class="fc bfc" id="L83" title="All 2 branches covered.">    if (!value.isBlank()) {</span>
<span class="fc" id="L84">      builder.description(MarkupLine.fromMarkdown(value));</span>
    }
<span class="fc" id="L86">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyTarget(@NonNull T builder, @NonNull String target) {
<span class="fc" id="L91">    builder.target(toMetapath(target));</span>
<span class="fc" id="L92">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyProperties(
      @NonNull T builder,
      @Nullable Property... properties) {
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">    if (properties != null) {</span>
<span class="fc" id="L100">      Arrays.stream(properties)</span>
<span class="fc" id="L101">          .map(ModelUtil::toPropertyEntry)</span>
<span class="pc" id="L102">          .forEachOrdered(entry -&gt; builder.property(</span>
<span class="nc" id="L103">              ObjectUtils.notNull(entry.getKey()),</span>
<span class="nc" id="L104">              ObjectUtils.notNull(entry.getValue())));</span>
    }
<span class="fc" id="L106">    return builder;</span>
  }

  static &lt;T extends AbstractConfigurableMessageConstraintBuilder&lt;T, ?&gt;&gt; T applyMessage(@NonNull T builder,
      @Nullable String message) {
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">    if (message != null &amp;&amp; !message.isBlank()) {</span>
<span class="fc" id="L112">      builder.message(message);</span>
    }
<span class="fc" id="L114">    return builder;</span>
  }

  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyRemarks(@NonNull T builder, @NonNull String remarks) {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (!remarks.isBlank()) {</span>
<span class="nc" id="L119">      builder.remarks(MarkupMultiline.fromMarkdown(remarks));</span>
    }
<span class="fc" id="L121">    return builder;</span>
  }

  @SuppressWarnings(&quot;PMD.NullAssignment&quot;)
  @NonNull
  static IAllowedValuesConstraint.Builder applyAllowedValues(
      @NonNull IAllowedValuesConstraint.Builder builder,
      @NonNull AllowedValues constraint) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">    for (AllowedValue value : constraint.values()) {</span>
<span class="fc" id="L130">      String deprecatedVersion = value.deprecatedVersion();</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">      if (deprecatedVersion.isBlank()) {</span>
<span class="fc" id="L132">        deprecatedVersion = null;</span>
      }

<span class="fc" id="L135">      IAllowedValue allowedValue = IAllowedValue.of(</span>
<span class="fc" id="L136">          value.value(),</span>
<span class="fc" id="L137">          MarkupLine.fromMarkdown(value.description()),</span>
          deprecatedVersion);
<span class="fc" id="L139">      builder.allowedValue(allowedValue);</span>
    }
<span class="fc" id="L141">    return builder;</span>
  }

  @Nullable
  static Pattern toPattern(@NonNull String pattern) {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    return pattern.isBlank() ? null : Pattern.compile(pattern);</span>
  }

  @Nullable
  static String toMessage(@NonNull String message) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">    return message.isBlank() ? null : message;</span>
  }

  @Nullable
  static IDataTypeAdapter&lt;?&gt; toDataType(@NonNull Class&lt;? extends IDataTypeAdapter&lt;?&gt;&gt; adapterClass) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">    return adapterClass.isAssignableFrom(NullJavaTypeAdapter.class) ? null</span>
<span class="nc" id="L157">        : DataTypeService.getInstance().getJavaTypeAdapterByClass(adapterClass);</span>
  }

  @NonNull
  static IAllowedValuesConstraint newAllowedValuesConstraint(
      @NonNull AllowedValues constraint,
      @NonNull ISource source) {
<span class="fc" id="L164">    IAllowedValuesConstraint.Builder builder = IAllowedValuesConstraint.builder();</span>
<span class="fc" id="L165">    applyId(builder, constraint.id());</span>
<span class="fc" id="L166">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L167">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L168">    builder</span>
<span class="fc" id="L169">        .source(source)</span>
<span class="fc" id="L170">        .level(constraint.level());</span>
<span class="fc" id="L171">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L172">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L173">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L175">    applyAllowedValues(builder, constraint);</span>
<span class="fc" id="L176">    builder.allowsOther(constraint.allowOthers());</span>
<span class="fc" id="L177">    builder.extensible(constraint.extensible());</span>

<span class="fc" id="L179">    return builder.build();</span>
  }

  @NonNull
  static IMatchesConstraint newMatchesConstraint(Matches constraint, @NonNull ISource source) {
<span class="nc" id="L184">    IMatchesConstraint.Builder builder = IMatchesConstraint.builder();</span>
<span class="nc" id="L185">    applyId(builder, constraint.id());</span>
<span class="nc" id="L186">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L187">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L188">    builder</span>
<span class="nc" id="L189">        .source(source)</span>
<span class="nc" id="L190">        .level(constraint.level());</span>
<span class="nc" id="L191">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L192">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L193">    applyMessage(builder, constraint.message());</span>
<span class="nc" id="L194">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L196">    Pattern pattern = toPattern(constraint.pattern());</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (pattern != null) {</span>
<span class="nc" id="L198">      builder.regex(pattern);</span>
    }

<span class="nc" id="L201">    IDataTypeAdapter&lt;?&gt; dataType = toDataType(constraint.typeAdapter());</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (dataType != null) {</span>
<span class="nc" id="L203">      builder.datatype(dataType);</span>
    }

<span class="nc" id="L206">    return builder.build();</span>
  }

  @NonNull
  static &lt;T extends AbstractKeyConstraintBuilder&lt;T, ?&gt;&gt; T applyKeyFields(
      @NonNull T builder,
      @NonNull ISource source,
      @NonNull KeyField... keyFields) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    for (KeyField keyField : keyFields) {</span>
      @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;) // ok
<span class="fc" id="L216">      IKeyField field = IKeyField.of(</span>
<span class="fc" id="L217">          toMetapath(keyField.target()),</span>
<span class="fc" id="L218">          toPattern(keyField.pattern()),</span>
<span class="fc" id="L219">          toRemarks(keyField.remarks()),</span>
          source);
<span class="fc" id="L221">      builder.keyField(field);</span>
    }
<span class="fc" id="L223">    return builder;</span>
  }

  @NonNull
  static IUniqueConstraint newUniqueConstraint(@NonNull IsUnique constraint, @NonNull ISource source) {
<span class="fc" id="L228">    IUniqueConstraint.Builder builder = IUniqueConstraint.builder();</span>
<span class="fc" id="L229">    applyId(builder, constraint.id());</span>
<span class="fc" id="L230">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L231">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L232">    builder</span>
<span class="fc" id="L233">        .source(source)</span>
<span class="fc" id="L234">        .level(constraint.level());</span>
<span class="fc" id="L235">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L236">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L237">    applyMessage(builder, constraint.message());</span>
<span class="fc" id="L238">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L240">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="fc" id="L242">    return builder.build();</span>
  }

  @NonNull
  static IIndexConstraint newIndexConstraint(@NonNull Index constraint, @NonNull ISource source) {
<span class="nc" id="L247">    IIndexConstraint.Builder builder = IIndexConstraint.builder(constraint.name());</span>
<span class="nc" id="L248">    applyId(builder, constraint.id());</span>
<span class="nc" id="L249">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L250">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L251">    builder</span>
<span class="nc" id="L252">        .source(source)</span>
<span class="nc" id="L253">        .level(constraint.level());</span>
<span class="nc" id="L254">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L255">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L256">    applyMessage(builder, constraint.message());</span>
<span class="nc" id="L257">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L259">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="nc" id="L261">    return builder.build();</span>
  }

  @NonNull
  static IIndexHasKeyConstraint newIndexHasKeyConstraint(
      @NonNull IndexHasKey constraint,
      @NonNull ISource source) {
<span class="nc" id="L268">    IIndexHasKeyConstraint.Builder builder = IIndexHasKeyConstraint.builder(constraint.indexName());</span>
<span class="nc" id="L269">    applyId(builder, constraint.id());</span>
<span class="nc" id="L270">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L271">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L272">    builder</span>
<span class="nc" id="L273">        .source(source)</span>
<span class="nc" id="L274">        .level(constraint.level());</span>
<span class="nc" id="L275">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L276">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L277">    applyMessage(builder, constraint.message());</span>
<span class="nc" id="L278">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L280">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="nc" id="L282">    return builder.build();</span>
  }

  @NonNull
  static IExpectConstraint newExpectConstraint(@NonNull Expect constraint, @NonNull ISource source) {
<span class="fc" id="L287">    IExpectConstraint.Builder builder = IExpectConstraint.builder();</span>
<span class="fc" id="L288">    applyId(builder, constraint.id());</span>
<span class="fc" id="L289">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L290">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L291">    builder</span>
<span class="fc" id="L292">        .source(source)</span>
<span class="fc" id="L293">        .level(constraint.level());</span>
<span class="fc" id="L294">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L295">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L296">    applyMessage(builder, constraint.message());</span>
<span class="fc" id="L297">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L299">    builder.test(toMetapath(constraint.test()));</span>

<span class="fc" id="L301">    return builder.build();</span>
  }

  @Nullable
  static Integer toCardinality(int value) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">    return value &lt; 0 ? null : value;</span>
  }

  @NonNull
  static ICardinalityConstraint newCardinalityConstraint(@NonNull HasCardinality constraint,
      @NonNull ISource source) {
<span class="nc" id="L312">    ICardinalityConstraint.Builder builder = ICardinalityConstraint.builder();</span>
<span class="nc" id="L313">    applyId(builder, constraint.id());</span>
<span class="nc" id="L314">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L315">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L316">    builder</span>
<span class="nc" id="L317">        .source(source)</span>
<span class="nc" id="L318">        .level(constraint.level());</span>
<span class="nc" id="L319">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L320">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L321">    applyMessage(builder, constraint.message());</span>
<span class="nc" id="L322">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L324">    Integer min = toCardinality(constraint.minOccurs());</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">    if (min != null) {</span>
<span class="nc" id="L326">      builder.minOccurs(min);</span>
    }
<span class="nc" id="L328">    Integer max = toCardinality(constraint.maxOccurs());</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (max != null) {</span>
<span class="nc" id="L330">      builder.maxOccurs(max);</span>
    }

<span class="nc" id="L333">    return builder.build();</span>
  }

  @NonNull
  static ILet newLetExpression(@NonNull Let annotation, @NonNull ISource source) {
<span class="fc" id="L338">    String remarkMarkdown = annotation.remarks();</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">    MarkupMultiline remarks = remarkMarkdown.isBlank()</span>
<span class="fc" id="L340">        ? null</span>
<span class="fc" id="L341">        : MarkupMultiline.fromMarkdown(remarkMarkdown);</span>
<span class="fc" id="L342">    return ILet.of(</span>
<span class="fc" id="L343">        new QName(annotation.name()),</span>
<span class="fc" id="L344">        annotation.target(),</span>
        source,
        remarks);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>