<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstraintFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.model.impl</a> &gt; <span class="el_source">ConstraintFactory.java</span></div><h1>ConstraintFactory.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.model.impl;

import gov.nist.secauto.metaschema.core.datatype.DataTypeService;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.model.IAttributable;
import gov.nist.secauto.metaschema.core.model.constraint.AbstractConstraintBuilder;
import gov.nist.secauto.metaschema.core.model.constraint.AbstractKeyConstraintBuilder;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValue;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValuesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ICardinalityConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IExpectConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexHasKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyField;
import gov.nist.secauto.metaschema.core.model.constraint.ILet;
import gov.nist.secauto.metaschema.core.model.constraint.IMatchesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ISource;
import gov.nist.secauto.metaschema.core.model.constraint.IUniqueConstraint;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.databind.model.annotations.Expect;
import gov.nist.secauto.metaschema.databind.model.annotations.HasCardinality;
import gov.nist.secauto.metaschema.databind.model.annotations.Index;
import gov.nist.secauto.metaschema.databind.model.annotations.IndexHasKey;
import gov.nist.secauto.metaschema.databind.model.annotations.IsUnique;
import gov.nist.secauto.metaschema.databind.model.annotations.KeyField;
import gov.nist.secauto.metaschema.databind.model.annotations.Let;
import gov.nist.secauto.metaschema.databind.model.annotations.Matches;
import gov.nist.secauto.metaschema.databind.model.annotations.NullJavaTypeAdapter;
import gov.nist.secauto.metaschema.databind.model.annotations.Property;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

final class ConstraintFactory {
<span class="fc" id="L55">  private static final Logger LOGGER = LogManager.getLogger(ConstraintFactory.class);</span>

  private ConstraintFactory() {
    // disable
  }

  static MarkupMultiline toRemarks(@NonNull String remarks) {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">    return remarks.isBlank() ? null : MarkupMultiline.fromMarkdown(remarks);</span>
  }

  @NonNull
  static String toMetapath(@NonNull String metapath) {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">    return metapath.isBlank() ? IConstraint.DEFAULT_TARGET_METAPATH : metapath;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyId(@NonNull T builder, @NonNull String id) {
<span class="fc bfc" id="L72" title="All 2 branches covered.">    if (!id.isBlank()) {</span>
<span class="fc" id="L73">      builder.identifier(id);</span>
    }
<span class="fc" id="L75">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyFormalName(@NonNull T builder, @NonNull String name) {
<span class="fc bfc" id="L80" title="All 2 branches covered.">    if (!name.isBlank()) {</span>
<span class="fc" id="L81">      builder.formalName(name);</span>
    }
<span class="fc" id="L83">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyDescription(@NonNull T builder, @NonNull String value) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (!value.isBlank()) {</span>
<span class="fc" id="L89">      builder.description(MarkupLine.fromMarkdown(value));</span>
    }
<span class="fc" id="L91">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyTarget(@NonNull T builder, @NonNull String target) {
<span class="fc" id="L96">    builder.target(toMetapath(target));</span>
<span class="fc" id="L97">    return builder;</span>
  }

  @NonNull
  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyProperties(
      @NonNull T builder,
      @Nullable Property... properties) {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    if (properties != null) {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">      for (Property property : properties) {</span>
<span class="nc" id="L106">        String name = property.name();</span>
<span class="nc" id="L107">        String namespace = property.namespace();</span>
        @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;) // ok
<span class="nc" id="L109">        IAttributable.Key key = IAttributable.key(namespace, name);</span>

<span class="nc" id="L111">        String[] values = property.values();</span>
<span class="nc" id="L112">        List&lt;String&gt; valueList = Arrays.asList(values);</span>
        @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;) // ok
<span class="nc" id="L114">        Set&lt;String&gt; valueSet = new LinkedHashSet&lt;&gt;(valueList);</span>
<span class="nc" id="L115">        builder.property(key, valueSet);</span>
      }
    }
<span class="fc" id="L118">    return builder;</span>
  }

  static &lt;T extends AbstractConstraintBuilder&lt;T, ?&gt;&gt; T applyRemarks(@NonNull T builder, @NonNull String remarks) {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (!remarks.isBlank()) {</span>
<span class="nc" id="L123">      builder.remarks(MarkupMultiline.fromMarkdown(remarks));</span>
    }
<span class="fc" id="L125">    return builder;</span>
  }

  @NonNull
  static IAllowedValuesConstraint.Builder applyAllowedValues(
      @NonNull IAllowedValuesConstraint.Builder builder,
      @NonNull AllowedValues constraint) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">    for (AllowedValue value : constraint.values()) {</span>
<span class="fc" id="L133">      IAllowedValue allowedValue = IAllowedValue.of(value.value(), MarkupLine.fromMarkdown(value.description()));</span>
<span class="fc" id="L134">      builder.allowedValue(allowedValue);</span>
    }
<span class="fc" id="L136">    return builder;</span>
  }

  @Nullable
  static Pattern toPattern(@NonNull String pattern) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">    return pattern.isBlank() ? null : Pattern.compile(pattern);</span>
  }

  @Nullable
  static String toMessage(@NonNull String message) {
<span class="nc bnc" id="L146" title="All 2 branches missed.">    return message.isBlank() ? null : message;</span>
  }

  @Nullable
  static IDataTypeAdapter&lt;?&gt; toDataType(@NonNull Class&lt;? extends IDataTypeAdapter&lt;?&gt;&gt; adapterClass) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">    return adapterClass.isAssignableFrom(NullJavaTypeAdapter.class) ? null</span>
<span class="nc" id="L152">        : DataTypeService.getInstance().getJavaTypeAdapterByClass(adapterClass);</span>
  }

  @NonNull
  static IAllowedValuesConstraint newAllowedValuesConstraint(
      @NonNull AllowedValues constraint,
      @NonNull ISource source) {
<span class="fc" id="L159">    IAllowedValuesConstraint.Builder builder = IAllowedValuesConstraint.builder();</span>
<span class="fc" id="L160">    applyId(builder, constraint.id());</span>
<span class="fc" id="L161">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L162">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L163">    builder</span>
<span class="fc" id="L164">        .source(source)</span>
<span class="fc" id="L165">        .level(constraint.level());</span>
<span class="fc" id="L166">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L167">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L168">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L170">    applyAllowedValues(builder, constraint);</span>
<span class="fc" id="L171">    builder.allowsOther(constraint.allowOthers());</span>
<span class="fc" id="L172">    builder.extensible(constraint.extensible());</span>

<span class="fc" id="L174">    return builder.build();</span>
  }

  @NonNull
  static IMatchesConstraint newMatchesConstraint(Matches constraint, @NonNull ISource source) {
<span class="nc" id="L179">    IMatchesConstraint.Builder builder = IMatchesConstraint.builder();</span>
<span class="nc" id="L180">    applyId(builder, constraint.id());</span>
<span class="nc" id="L181">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L182">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L183">    builder</span>
<span class="nc" id="L184">        .source(source)</span>
<span class="nc" id="L185">        .level(constraint.level());</span>
<span class="nc" id="L186">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L187">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L188">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L190">    Pattern pattern = toPattern(constraint.pattern());</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (pattern != null) {</span>
<span class="nc" id="L192">      builder.regex(pattern);</span>
    }

<span class="nc" id="L195">    IDataTypeAdapter&lt;?&gt; dataType = toDataType(constraint.typeAdapter());</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">    if (dataType != null) {</span>
<span class="nc" id="L197">      builder.datatype(dataType);</span>
    }

<span class="nc" id="L200">    return builder.build();</span>
  }

  @NonNull
  static &lt;T extends AbstractKeyConstraintBuilder&lt;T, ?&gt;&gt; T applyKeyFields(
      @NonNull T builder,
      @NonNull ISource source,
      @NonNull KeyField... keyFields) {
<span class="fc bfc" id="L208" title="All 2 branches covered.">    for (KeyField keyField : keyFields) {</span>
      @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;) // ok
<span class="fc" id="L210">      IKeyField field = IKeyField.of(</span>
<span class="fc" id="L211">          toMetapath(keyField.target()),</span>
<span class="fc" id="L212">          toPattern(keyField.pattern()),</span>
<span class="fc" id="L213">          toRemarks(keyField.remarks()),</span>
          source);
<span class="fc" id="L215">      builder.keyField(field);</span>
    }
<span class="fc" id="L217">    return builder;</span>
  }

  @NonNull
  static IUniqueConstraint newUniqueConstraint(@NonNull IsUnique constraint, @NonNull ISource source) {
<span class="fc" id="L222">    IUniqueConstraint.Builder builder = IUniqueConstraint.builder();</span>
<span class="fc" id="L223">    applyId(builder, constraint.id());</span>
<span class="fc" id="L224">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L225">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L226">    builder</span>
<span class="fc" id="L227">        .source(source)</span>
<span class="fc" id="L228">        .level(constraint.level());</span>
<span class="fc" id="L229">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L230">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L231">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L233">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="fc" id="L235">    return builder.build();</span>
  }

  @NonNull
  static IIndexConstraint newIndexConstraint(@NonNull Index constraint, @NonNull ISource source) {
<span class="fc" id="L240">    IIndexConstraint.Builder builder = IIndexConstraint.builder(constraint.name());</span>
<span class="fc" id="L241">    applyId(builder, constraint.id());</span>
<span class="fc" id="L242">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L243">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L244">    builder</span>
<span class="fc" id="L245">        .source(source)</span>
<span class="fc" id="L246">        .level(constraint.level());</span>
<span class="fc" id="L247">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L248">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L249">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L251">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="fc" id="L253">    return builder.build();</span>
  }

  @NonNull
  static IIndexHasKeyConstraint newIndexHasKeyConstraint(
      @NonNull IndexHasKey constraint,
      @NonNull ISource source) {
<span class="nc" id="L260">    IIndexHasKeyConstraint.Builder builder = IIndexHasKeyConstraint.builder(constraint.indexName());</span>
<span class="nc" id="L261">    applyId(builder, constraint.id());</span>
<span class="nc" id="L262">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L263">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L264">    builder</span>
<span class="nc" id="L265">        .source(source)</span>
<span class="nc" id="L266">        .level(constraint.level());</span>
<span class="nc" id="L267">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L268">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L269">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L271">    applyKeyFields(builder, source, constraint.keyFields());</span>

<span class="nc" id="L273">    return builder.build();</span>
  }

  @NonNull
  static IExpectConstraint newExpectConstraint(@NonNull Expect constraint, @NonNull ISource source) {
<span class="fc" id="L278">    IExpectConstraint.Builder builder = IExpectConstraint.builder();</span>
<span class="fc" id="L279">    applyId(builder, constraint.id());</span>
<span class="fc" id="L280">    applyFormalName(builder, constraint.formalName());</span>
<span class="fc" id="L281">    applyDescription(builder, constraint.description());</span>
<span class="fc" id="L282">    builder</span>
<span class="fc" id="L283">        .source(source)</span>
<span class="fc" id="L284">        .level(constraint.level());</span>
<span class="fc" id="L285">    applyTarget(builder, constraint.target());</span>
<span class="fc" id="L286">    applyProperties(builder, constraint.properties());</span>
<span class="fc" id="L287">    applyRemarks(builder, constraint.remarks());</span>

<span class="fc" id="L289">    builder.test(toMetapath(constraint.test()));</span>

<span class="fc" id="L291">    String message = constraint.message();</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">    if (!message.isBlank()) {</span>
<span class="fc" id="L293">      builder.message(message);</span>
    }

<span class="fc" id="L296">    return builder.build();</span>
  }

  @Nullable
  static Integer toCardinality(int value) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">    return value &lt; 0 ? null : value;</span>
  }

  @NonNull
  static ICardinalityConstraint newCardinalityConstraint(@NonNull HasCardinality constraint,
      @NonNull ISource source) {
<span class="nc" id="L307">    ICardinalityConstraint.Builder builder = ICardinalityConstraint.builder();</span>
<span class="nc" id="L308">    applyId(builder, constraint.id());</span>
<span class="nc" id="L309">    applyFormalName(builder, constraint.formalName());</span>
<span class="nc" id="L310">    applyDescription(builder, constraint.description());</span>
<span class="nc" id="L311">    builder</span>
<span class="nc" id="L312">        .source(source)</span>
<span class="nc" id="L313">        .level(constraint.level());</span>
<span class="nc" id="L314">    applyTarget(builder, constraint.target());</span>
<span class="nc" id="L315">    applyProperties(builder, constraint.properties());</span>
<span class="nc" id="L316">    applyRemarks(builder, constraint.remarks());</span>

<span class="nc" id="L318">    Integer min = toCardinality(constraint.minOccurs());</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">    if (min != null) {</span>
<span class="nc" id="L320">      builder.minOccurs(min);</span>
    }
<span class="nc" id="L322">    Integer max = toCardinality(constraint.maxOccurs());</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if (max != null) {</span>
<span class="nc" id="L324">      builder.maxOccurs(max);</span>
    }

<span class="nc" id="L327">    return builder.build();</span>
  }

  @NonNull
  static ILet newLetExpression(@NonNull Let annotation, @NonNull ISource source) {
<span class="fc" id="L332">    return ILet.of(new QName(annotation.name()), annotation.target(), source);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>