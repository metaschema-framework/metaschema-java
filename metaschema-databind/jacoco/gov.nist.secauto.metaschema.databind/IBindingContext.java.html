<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IBindingContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind</a> &gt; <span class="el_source">IBindingContext.java</span></div><h1>IBindingContext.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind;

import gov.nist.secauto.metaschema.core.configuration.IConfiguration;
import gov.nist.secauto.metaschema.core.datatype.DataTypeService;
import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDefinitionNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDocumentNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IRootAssemblyNodeItem;
import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IConstraintLoader;
import gov.nist.secauto.metaschema.core.model.IModule;
import gov.nist.secauto.metaschema.core.model.IModuleLoader;
import gov.nist.secauto.metaschema.core.model.MetaschemaException;
import gov.nist.secauto.metaschema.core.model.constraint.DefaultConstraintValidator;
import gov.nist.secauto.metaschema.core.model.constraint.ExternalConstraintsModulePostProcessor;
import gov.nist.secauto.metaschema.core.model.constraint.FindingCollectingConstraintValidationHandler;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintSet;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintValidationHandler;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintValidator;
import gov.nist.secauto.metaschema.core.model.constraint.ValidationFeature;
import gov.nist.secauto.metaschema.core.model.validation.AggregateValidationResult;
import gov.nist.secauto.metaschema.core.model.validation.IValidationResult;
import gov.nist.secauto.metaschema.core.model.validation.JsonSchemaContentValidator;
import gov.nist.secauto.metaschema.core.model.validation.XmlSchemaContentValidator;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.codegen.DefaultModuleBindingGenerator;
import gov.nist.secauto.metaschema.databind.io.BindingException;
import gov.nist.secauto.metaschema.databind.io.DefaultBoundLoader;
import gov.nist.secauto.metaschema.databind.io.DeserializationFeature;
import gov.nist.secauto.metaschema.databind.io.Format;
import gov.nist.secauto.metaschema.databind.io.IBoundLoader;
import gov.nist.secauto.metaschema.databind.io.IDeserializer;
import gov.nist.secauto.metaschema.databind.io.ISerializer;
import gov.nist.secauto.metaschema.databind.io.yaml.YamlOperations;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModel;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundModule;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaField;
import gov.nist.secauto.metaschema.databind.model.metaschema.BindingConstraintLoader;
import gov.nist.secauto.metaschema.databind.model.metaschema.IBindingMetaschemaModule;
import gov.nist.secauto.metaschema.databind.model.metaschema.IBindingModuleLoader;
import gov.nist.secauto.metaschema.databind.model.metaschema.ModuleLoadingPostProcessor;

import org.json.JSONObject;
import org.json.JSONTokener;
import org.xml.sax.SAXException;

import java.io.BufferedInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.URI;
import java.net.URL;
import java.nio.file.Path;
import java.time.ZonedDateTime;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Function;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Provides information supporting a binding between a set of Module models and
 * corresponding Java classes.
 */
public interface IBindingContext {
  /**
   * Get a new builder that can produce a new, configured binding context.
   *
   * @return the builder
   * @since 2.0.0
   */
  static BindingContextBuilder builder() {
<span class="fc" id="L88">    return new BindingContextBuilder();</span>
  }

  /**
   * Get a new {@link IBindingContext} instance, which can be used to load
   * information that binds a model to a set of Java classes.
   *
   * @return a new binding context
   * @since 2.0.0
   */
  @NonNull
  static IBindingContext newInstance() {
<span class="fc" id="L100">    return new DefaultBindingContext();</span>
  }

  /**
   * Get a new {@link IBindingContext} instance, which can be used to load
   * information that binds a model to a set of Java classes.
   *
   * @param strategy
   *          the loader strategy to use when loading Metaschema modules
   * @return a new binding context
   * @since 2.0.0
   */
  @NonNull
  static IBindingContext newInstance(@NonNull IBindingContext.IModuleLoaderStrategy strategy) {
<span class="nc" id="L114">    return new DefaultBindingContext(strategy);</span>
  }

  /**
   * Get the Metaschema module loader strategy used by this binding context to
   * load modules.
   *
   * @return the strategy instance
   * @since 2.0.0
   */
  @NonNull
  IModuleLoaderStrategy getModuleLoaderStrategy();

  /**
   * Get a loader that supports loading a Metaschema module from a specified
   * resource.
   * &lt;p&gt;
   * Modules loaded with this loader are automatically registered with this
   * binding context.
   * &lt;p&gt;
   * Use of this method requires that the binding context is initialized using a
   * {@link IModuleLoaderStrategy} that supports dynamic bound module loading.
   * This can be accomplished using the {@link SimpleModuleLoaderStrategy}
   * initialized using the {@link DefaultModuleBindingGenerator}. * @return the
   * loader
   *
   * @return the loader
   * @since 2.0.0
   */
  @NonNull
  IBindingModuleLoader newModuleLoader();

  /**
   * Loads a Metaschema module from the specified path.
   * &lt;p&gt;
   * This method automatically registers the module with this binding context.
   * &lt;p&gt;
   * Use of this method requires that the binding context is initialized using a
   * {@link IModuleLoaderStrategy} that supports dynamic bound module loading.
   * This can be accomplished using the {@link SimpleModuleLoaderStrategy}
   * initialized using the {@link DefaultModuleBindingGenerator}.
   *
   * @param path
   *          the path to load the module from
   * @return the loaded Metaschema module
   * @throws MetaschemaException
   *           if an error occurred while processing the resource
   * @throws IOException
   *           if an error occurred parsing the resource
   * @throws UnsupportedOperationException
   *           if this binding context is not configured to support dynamic bound
   *           module loading
   * @since 2.0.0
   */
  @NonNull
  default IBindingMetaschemaModule loadMetaschema(@NonNull Path path) throws MetaschemaException, IOException {
<span class="fc" id="L170">    return newModuleLoader().load(path);</span>
  }

  /**
   * Loads a Metaschema module from the specified URL.
   * &lt;p&gt;
   * This method automatically registers the module with this binding context.
   * &lt;p&gt;
   * Use of this method requires that the binding context is initialized using a
   * {@link IModuleLoaderStrategy} that supports dynamic bound module loading.
   * This can be accomplished using the {@link SimpleModuleLoaderStrategy}
   * initialized using the {@link DefaultModuleBindingGenerator}.
   *
   * @param url
   *          the URL to load the module from
   * @return the loaded Metaschema module
   * @throws MetaschemaException
   *           if an error occurred while processing the resource
   * @throws IOException
   *           if an error occurred parsing the resource
   * @throws UnsupportedOperationException
   *           if this binding context is not configured to support dynamic bound
   *           module loading
   * @since 2.0.0
   */
  @NonNull
  default IBindingMetaschemaModule loadMetaschema(@NonNull URL url) throws MetaschemaException, IOException {
<span class="fc" id="L197">    return newModuleLoader().load(url);</span>
  }

  /**
   * Get a loader that supports loading Metaschema module constraints from a
   * specified resource.
   * &lt;p&gt;
   * Metaschema module constraints loaded this need to be used with a new
   * {@link IBindingContext} instance to be applied to loaded modules. The new
   * binding context must initialized using the
   * {@link PostProcessingModuleLoaderStrategy} that is initialized with a
   * {@link ExternalConstraintsModulePostProcessor} instance.
   *
   * @return the loader
   * @since 2.0.0
   */
  @NonNull
  static IConstraintLoader getConstraintLoader() {
<span class="fc" id="L215">    return new BindingConstraintLoader(DefaultBindingContext.instance());</span>
  }

  /**
   * Get a loader that supports loading Metaschema module constraints from a
   * specified resource.
   * &lt;p&gt;
   * Metaschema module constraints loaded this need to be used with a new
   * {@link IBindingContext} instance to be applied to loaded modules. The new
   * binding context must initialized using the
   * {@link PostProcessingModuleLoaderStrategy} that is initialized with a
   * {@link ExternalConstraintsModulePostProcessor} instance.
   *
   * @return the loader
   * @since 2.0.0
   */
  @NonNull
  default IConstraintLoader newConstraintLoader() {
<span class="nc" id="L233">    return new BindingConstraintLoader(this);</span>
  }

  /**
   * Load a bound Metaschema module implemented by the provided class.
   * &lt;p&gt;
   * Also registers any associated bound classes.
   * &lt;p&gt;
   * Implementations are expected to return the same IModule instance for multiple
   * calls to this method with the same class argument.
   *
   * @param clazz
   *          the class implementing a bound Metaschema module
   * @return the loaded module
   */
  @NonNull
  IBoundModule registerModule(@NonNull Class&lt;? extends IBoundModule&gt; clazz);

  /**
   * Registers the provided Metaschema module with this binding context.
   * &lt;p&gt;
   * If the provided instance is not an instance of {@link IBoundModule}, then
   * annotated Java classes for this module will be generated, compiled, and
   * loaded based on the provided Module.
   *
   * @param module
   *          the Module module to generate classes for
   * @return the registered module, which may be a different instance than what
   *         was provided if dynamic compilation was performed
   * @throws UnsupportedOperationException
   *           if this binding context is not configured to support dynamic bound
   *           module loading and the module instance is not a subclass of
   *           {@link IBoundModule}
   * @since 2.0.0
   */
  @NonNull
  default IBoundModule registerModule(@NonNull IModule module) {
<span class="fc" id="L270">    return getModuleLoaderStrategy().registerModule(module, this);</span>
  }

  /**
   * Register a class binding for a given bound class.
   *
   * @param definition
   *          the bound class information to register
   * @return the old bound class information or {@code null} if no binding existed
   *         for the associated class
   */
  @Nullable
  IBoundDefinitionModelComplex registerClassBinding(@NonNull IBoundDefinitionModelComplex definition);

  /**
   * Get the {@link IBoundDefinitionModel} instance associated with the provided
   * Java class.
   * &lt;p&gt;
   * Typically the class will have a {@link MetaschemaAssembly} or
   * {@link MetaschemaField} annotation.
   *
   * @param clazz
   *          the class binding to load
   * @return the associated class binding instance or {@code null} if the class is
   *         not bound
   */
  @Nullable
  IBoundDefinitionModelComplex getBoundDefinitionForClass(@NonNull Class&lt;? extends IBoundObject&gt; clazz);

  /**
   * Determine the bound class for the provided XML {@link QName}.
   *
   * @param rootQName
   *          the root XML element's QName
   * @return the bound class or {@code null} if not recognized
   */
  @Nullable
  Class&lt;? extends IBoundObject&gt; getBoundClassForRootXmlQName(@NonNull QName rootQName);

  /**
   * Determine the bound class for the provided JSON/YAML property/item name using
   * any registered matchers.
   *
   * @param rootName
   *          the JSON/YAML property/item name
   * @return the bound class or {@code null} if not recognized
   */
  @Nullable
  Class&lt;? extends IBoundObject&gt; getBoundClassForRootJsonName(@NonNull String rootName);

  /**
   * Get's the {@link IDataTypeAdapter} associated with the specified Java class,
   * which is used to read and write XML, JSON, and YAML data to and from
   * instances of that class. Thus, this adapter supports a direct binding between
   * the Java class and structured data in one of the supported formats. Adapters
   * are used to support bindings for simple data objects (e.g., {@link String},
   * {@link BigInteger}, {@link ZonedDateTime}, etc).
   *
   * @param &lt;TYPE&gt;
   *          the class type of the adapter
   * @param clazz
   *          the Java {@link Class} for the bound type
   * @return the adapter instance or {@code null} if the provided class is not
   *         bound
   */
  @Nullable
  default &lt;TYPE extends IDataTypeAdapter&lt;?&gt;&gt; TYPE getJavaTypeAdapterInstance(@NonNull Class&lt;TYPE&gt; clazz) {
<span class="fc" id="L337">    return DataTypeService.getInstance().getJavaTypeAdapterByClass(clazz);</span>
  }

  /**
   * Gets a data {@link ISerializer} which can be used to write Java instance data
   * for the provided class in the requested format.
   * &lt;p&gt;
   * The provided class must be a bound Java class with a
   * {@link MetaschemaAssembly} or {@link MetaschemaField} annotation for which a
   * {@link IBoundDefinitionModel} exists.
   *
   * @param &lt;CLASS&gt;
   *          the Java type this serializer can write data from
   * @param format
   *          the format to serialize into
   * @param clazz
   *          the Java data object to serialize
   * @return the serializer instance
   * @throws NullPointerException
   *           if any of the provided arguments, except the configuration, are
   *           {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   * @throws UnsupportedOperationException
   *           if the requested format is not supported by the implementation
   * @see #getBoundDefinitionForClass(Class)
   */
  @NonNull
  &lt;CLASS extends IBoundObject&gt; ISerializer&lt;CLASS&gt; newSerializer(
      @NonNull Format format,
      @NonNull Class&lt;CLASS&gt; clazz);

  /**
   * Gets a data {@link IDeserializer} which can be used to read Java instance
   * data for the provided class from the requested format.
   * &lt;p&gt;
   * The provided class must be a bound Java class with a
   * {@link MetaschemaAssembly} or {@link MetaschemaField} annotation for which a
   * {@link IBoundDefinitionModel} exists.
   *
   * @param &lt;CLASS&gt;
   *          the Java type this deserializer can read data into
   * @param format
   *          the format to serialize into
   * @param clazz
   *          the Java data type to serialize
   * @return the deserializer instance
   * @throws NullPointerException
   *           if any of the provided arguments, except the configuration, are
   *           {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   * @throws UnsupportedOperationException
   *           if the requested format is not supported by the implementation
   * @see #getBoundDefinitionForClass(Class)
   */
  @NonNull
  &lt;CLASS extends IBoundObject&gt; IDeserializer&lt;CLASS&gt; newDeserializer(
      @NonNull Format format,
      @NonNull Class&lt;CLASS&gt; clazz);

  /**
   * Get a new {@link IBoundLoader} instance to load bound content instances.
   *
   * @return the instance
   */
  @NonNull
  default IBoundLoader newBoundLoader() {
<span class="fc" id="L405">    return new DefaultBoundLoader(this);</span>
  }

  /**
   * Create a deep copy of the provided bound object.
   *
   * @param &lt;CLASS&gt;
   *          the bound object type
   * @param other
   *          the object to copy
   * @param parentInstance
   *          the object's parent or {@code null}
   * @return a deep copy of the provided object
   * @throws BindingException
   *           if an error occurred copying content between java instances
   * @throws NullPointerException
   *           if the provided object is {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   */
  @NonNull
  &lt;CLASS extends IBoundObject&gt; CLASS deepCopy(@NonNull CLASS other, IBoundObject parentInstance)
      throws BindingException;

  /**
   * Get a new single use constraint validator.
   *
   * @param handler
   *          the validation handler to use to process the validation results
   * @param config
   *          the validation configuration
   *
   * @return the validator
   */
  default IConstraintValidator newValidator(
      @NonNull IConstraintValidationHandler handler,
      @Nullable IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; config) {
<span class="nc" id="L442">    IBoundLoader loader = newBoundLoader();</span>
<span class="nc" id="L443">    loader.disableFeature(DeserializationFeature.DESERIALIZE_VALIDATE_CONSTRAINTS);</span>

<span class="nc" id="L445">    DynamicContext context = new DynamicContext();</span>
<span class="nc" id="L446">    context.setDocumentLoader(loader);</span>

<span class="nc" id="L448">    DefaultConstraintValidator retval = new DefaultConstraintValidator(handler);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">    if (config != null) {</span>
<span class="nc" id="L450">      retval.applyConfiguration(config);</span>
    }
<span class="nc" id="L452">    return retval;</span>
  }

  /**
   * Perform constraint validation on the provided bound object represented as an
   * {@link IDocumentNodeItem}.
   *
   * @param nodeItem
   *          the node item to validate
   * @param loader
   *          a module loader used to load and resolve referenced resources
   * @param config
   *          the validation configuration
   * @return the validation result
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   */
  default IValidationResult validate(
      @NonNull IDocumentNodeItem nodeItem,
      @NonNull IBoundLoader loader,
      @Nullable IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; config) {
<span class="nc" id="L473">    IRootAssemblyNodeItem root = nodeItem.getRootAssemblyNodeItem();</span>
<span class="nc" id="L474">    return validate(root, loader, config);</span>
  }

  /**
   * Perform constraint validation on the provided bound object represented as an
   * {@link IDefinitionNodeItem}.
   *
   * @param nodeItem
   *          the node item to validate
   * @param loader
   *          a module loader used to load and resolve referenced resources
   * @param config
   *          the validation configuration
   * @return the validation result
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   */
  default IValidationResult validate(
      @NonNull IDefinitionNodeItem&lt;?, ?&gt; nodeItem,
      @NonNull IBoundLoader loader,
      @Nullable IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; config) {

<span class="nc" id="L496">    FindingCollectingConstraintValidationHandler handler = new FindingCollectingConstraintValidationHandler();</span>
<span class="nc" id="L497">    IConstraintValidator validator = newValidator(handler, config);</span>

<span class="nc" id="L499">    DynamicContext dynamicContext = new DynamicContext(nodeItem.getStaticContext());</span>
<span class="nc" id="L500">    dynamicContext.setDocumentLoader(loader);</span>

<span class="nc" id="L502">    validator.validate(nodeItem, dynamicContext);</span>
<span class="nc" id="L503">    validator.finalizeValidation(dynamicContext);</span>
<span class="nc" id="L504">    return handler;</span>
  }

  /**
   * Load and perform schema and constraint validation on the target. The
   * constraint validation will only be performed if the schema validation passes.
   *
   * @param target
   *          the target to validate
   * @param asFormat
   *          the schema format to use to validate the target
   * @param schemaProvider
   *          provides callbacks to get the appropriate schemas
   * @param config
   *          the validation configuration
   * @return the validation result
   * @throws IOException
   *           if an error occurred while reading the target
   */
  default IValidationResult validate(
      @NonNull URI target,
      @NonNull Format asFormat,
      @NonNull ISchemaValidationProvider schemaProvider,
      @Nullable IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; config) throws IOException {

<span class="nc" id="L529">    IValidationResult retval = schemaProvider.validateWithSchema(target, asFormat, this);</span>

<span class="nc bnc" id="L531" title="All 2 branches missed.">    if (retval.isPassing()) {</span>
<span class="nc" id="L532">      IValidationResult constraintValidationResult = validateWithConstraints(target, config);</span>
<span class="nc" id="L533">      retval = AggregateValidationResult.aggregate(retval, constraintValidationResult);</span>
    }
<span class="nc" id="L535">    return retval;</span>
  }

  /**
   * Load and validate the provided {@code target} using the associated Module
   * module constraints.
   *
   * @param target
   *          the file to load and validate
   * @param config
   *          the validation configuration
   * @return the validation results
   * @throws IOException
   *           if an error occurred while parsing the target
   */
  default IValidationResult validateWithConstraints(
      @NonNull URI target,
      @Nullable IConfiguration&lt;ValidationFeature&lt;?&gt;&gt; config)
      throws IOException {
<span class="nc" id="L554">    IBoundLoader loader = newBoundLoader();</span>
<span class="nc" id="L555">    loader.disableFeature(DeserializationFeature.DESERIALIZE_VALIDATE_CONSTRAINTS);</span>
<span class="nc" id="L556">    IDocumentNodeItem nodeItem = loader.loadAsNodeItem(target);</span>

<span class="nc" id="L558">    return validate(nodeItem, loader, config);</span>
  }

  /**
   * A behavioral class used by the binding context to load Metaschema modules.
   * &lt;p&gt;
   * A module will flow through the following process.
   * &lt;ol&gt;
   * &lt;li&gt;&lt;b&gt;Loading:&lt;/b&gt; The module is read from its source.&lt;/li&gt;
   * &lt;li&gt;&lt;b&gt;Post Processing:&lt;/b&gt; The module is prepared for use.&lt;/li&gt;
   * &lt;li&gt;&lt;b&gt;Registration:&lt;/b&gt; The module is registered for use.&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;p&gt;
   * A module will be loaded when either the module or one of its global
   * definitions is accessed the first time.
   */
  interface IModuleLoaderStrategy extends ModuleLoadingPostProcessor {
    /**
     * Load the bound Metaschema module represented by the provided class.
     * &lt;p&gt;
     * This is the primary entry point for loading an already bound module. This
     * method must ensure that the loaded module is post-processed and registered.
     * &lt;p&gt;
     * Implementations are allowed to return a cached instance if the module has
     * already been loaded by this method.
     *
     * @param clazz
     *          the Module class
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the module
     * @throws IllegalStateException
     *           if an error occurred while processing the associated module
     *           information
     * @since 2.0.0
     */
    @NonNull
    IBoundModule loadModule(
        @NonNull Class&lt;? extends IBoundModule&gt; clazz,
        @NonNull IBindingContext bindingContext);

    /**
     * Perform post-processing on the module.
     *
     * @param module
     *          the Metaschema module to post-process
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @since 2.0.0
     */
    @Override
    default void postProcessModule(
        @NonNull IModule module,
        @NonNull IBindingContext bindingContext) {
      // do nothing by default
<span class="fc" id="L613">    }</span>

    /**
     * Registers the provided Metaschema module.
     * &lt;p&gt;
     * If this module has not been post-processed, this method is expected to drive
     * post-processing first.
     * &lt;p&gt;
     * If the provided instance is not an instance of {@link IBoundModule}, then
     * annotated Java classes for this module will be generated, compiled, and
     * loaded based on the provided Module.
     *
     * @param module
     *          the Module module to generate classes for
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the registered module, which may be a different instance than what
     *         was provided if dynamic compilation was performed
     * @throws UnsupportedOperationException
     *           if this binding context is not configured to support dynamic bound
     *           module loading and the module instance is not a subclass of
     *           {@link IBoundModule}
     * @since 2.0.0
     */
    @NonNull
    IBoundModule registerModule(
        @NonNull IModule module,
        @NonNull IBindingContext bindingContext);
    //
    // /**
    // * Register a matcher used to identify a bound class by the definition's root
    // * name.
    // *
    // * @param definition
    // * the definition to match for
    // * @return the matcher
    // */
    // @NonNull
    // IBindingMatcher registerBindingMatcher(@NonNull IBoundDefinitionModelAssembly
    // definition);

    /**
     * Get the matchers used to identify the bound class associated with the
     * definition's root name.
     *
     * @return the matchers
     */
    @NonNull
    Collection&lt;IBindingMatcher&gt; getBindingMatchers();

    /**
     * Get the {@link IBoundDefinitionModel} instance associated with the provided
     * Java class.
     * &lt;p&gt;
     * Typically the class will have a {@link MetaschemaAssembly} or
     * {@link MetaschemaField} annotation.
     *
     * @param clazz
     *          the class binding to load
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the associated class binding instance
     * @throws IllegalArgumentException
     *           if the class is not a bound definition with a
     *           {@link MetaschemaAssembly} or {@link MetaschemaField} annotation
     */
    @NonNull
    IBoundDefinitionModelComplex getBoundDefinitionForClass(
        @NonNull Class&lt;? extends IBoundObject&gt; clazz,
        @NonNull IBindingContext bindingContext);
  }

  /**
   * Enables building a {@link IBindingContext} using common configuration options
   * based on the builder pattern.
   *
   * @since 2.0.0
   */
  final class BindingContextBuilder {
    private Path compilePath;
<span class="fc" id="L693">    private final List&lt;IModuleLoader.IModulePostProcessor&gt; postProcessors = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L694">    private final List&lt;IConstraintSet&gt; constraintSets = new LinkedList&lt;&gt;();</span>
    @NonNull
    private final Function&lt;IBindingContext.IModuleLoaderStrategy, IBindingContext&gt; initializer;

    private BindingContextBuilder() {
<span class="fc" id="L699">      this(DefaultBindingContext::new);</span>
<span class="fc" id="L700">    }</span>

    /**
     * Construct a new builder.
     *
     * @param initializer
     *          the callback to use to get a new binding context instance
     */
    public BindingContextBuilder(
<span class="fc" id="L709">        @NonNull Function&lt;IBindingContext.IModuleLoaderStrategy, IBindingContext&gt; initializer) {</span>
<span class="fc" id="L710">      this.initializer = initializer;</span>
<span class="fc" id="L711">    }</span>

    /**
     * Enable dynamic code generation and compilation for Metaschema module-based
     * classes.
     *
     * @param path
     *          the path to use to generate and compile Metaschema module-based
     *          classes
     * @return this builder
     */
    @NonNull
    public BindingContextBuilder compilePath(@NonNull Path path) {
<span class="fc" id="L724">      compilePath = path;</span>
<span class="fc" id="L725">      return this;</span>
    }

    /**
     * Configure a Metaschema module post processor.
     *
     * @param processor
     *          the post processor to configure
     * @return this builder
     */
    @NonNull
    public BindingContextBuilder postProcessor(@NonNull IModuleLoader.IModulePostProcessor processor) {
<span class="nc" id="L737">      postProcessors.add(processor);</span>
<span class="nc" id="L738">      return this;</span>
    }

    /**
     * Configure a set of constraints targeting Metaschema modules.
     *
     * @param set
     *          the constraint set to configure
     * @return this builder
     */
    @NonNull
    public BindingContextBuilder constraintSet(@NonNull IConstraintSet set) {
<span class="nc" id="L750">      constraintSets.add(set);</span>
<span class="nc" id="L751">      return this;</span>
    }

    /**
     * Configure a collection of constraint sets targeting Metaschema modules.
     *
     * @param set
     *          the constraint sets to configure
     * @return this builder
     */
    @NonNull
    public BindingContextBuilder constraintSet(@NonNull Collection&lt;IConstraintSet&gt; set) {
<span class="fc" id="L763">      constraintSets.addAll(set);</span>
<span class="fc" id="L764">      return this;</span>
    }

    /**
     * Build a {@link IBindingContext} using the configuration options provided to
     * the builder.
     *
     * @return a new, configured binding context
     */
    @NonNull
    public IBindingContext build() {
      // get loader strategy based on if code generation is configured
<span class="fc bfc" id="L776" title="All 2 branches covered.">      IBindingContext.IModuleLoaderStrategy strategy = compilePath == null</span>
<span class="fc" id="L777">          ? new SimpleModuleLoaderStrategy()</span>
<span class="fc" id="L778">          : new SimpleModuleLoaderStrategy(new DefaultModuleBindingGenerator(compilePath));</span>

      // determine if any post processors are configured or need to be
<span class="fc" id="L781">      List&lt;IModuleLoader.IModulePostProcessor&gt; processors = new LinkedList&lt;&gt;(postProcessors);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">      if (!constraintSets.isEmpty()) {</span>
<span class="fc" id="L783">        processors.add(new ExternalConstraintsModulePostProcessor(constraintSets));</span>
      }

<span class="fc bfc" id="L786" title="All 2 branches covered.">      if (!processors.isEmpty()) {</span>
        // post processors are configured, configure the loader strategy to handle them
<span class="fc" id="L788">        strategy = new PostProcessingModuleLoaderStrategy(</span>
<span class="fc" id="L789">            CollectionUtil.unmodifiableList(processors),</span>
            strategy);
      }

<span class="fc" id="L793">      return ObjectUtils.notNull(initializer.apply(strategy));</span>
    }
  }

  /**
   * Provides schema validation capabilities.
   */
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">  interface ISchemaValidationProvider {</span>

    /**
     * Validate the target resource.
     *
     * @param target
     *          the resource to validate
     * @param asFormat
     *          the format to validate the content as
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the validation result
     * @throws FileNotFoundException
     *           if the resource was not found
     * @throws IOException
     *           if an error occurred while reading the resource
     */
    @NonNull
    default IValidationResult validateWithSchema(
        @NonNull URI target,
        @NonNull Format asFormat,
        @NonNull IBindingContext bindingContext)
        throws FileNotFoundException, IOException {
<span class="nc" id="L823">      URL targetResource = ObjectUtils.notNull(target.toURL());</span>

      IValidationResult retval;
<span class="nc bnc" id="L826" title="All 4 branches missed.">      switch (asFormat) {</span>
      case JSON: {
        JSONObject json;
        try (@SuppressWarnings(&quot;resource&quot;)
<span class="nc" id="L830">        InputStream is</span>
<span class="nc" id="L831">            = new BufferedInputStream(ObjectUtils.notNull(targetResource.openStream()))) {</span>
<span class="nc" id="L832">          json = new JSONObject(new JSONTokener(is));</span>
        }
<span class="nc" id="L834">        retval = getJsonSchema(json, bindingContext).validate(json, target);</span>
<span class="nc" id="L835">        break;</span>
      }
      case XML:
        try {
<span class="nc" id="L839">          retval = getXmlSchemas(targetResource, bindingContext).validate(target);</span>
<span class="nc" id="L840">        } catch (SAXException ex) {</span>
<span class="nc" id="L841">          throw new IOException(ex);</span>
<span class="nc" id="L842">        }</span>
        break;
      case YAML: {
<span class="nc" id="L845">        JSONObject json = YamlOperations.yamlToJson(YamlOperations.parseYaml(target));</span>
<span class="nc bnc" id="L846" title="All 4 branches missed.">        assert json != null;</span>
<span class="nc" id="L847">        retval = getJsonSchema(json, bindingContext).validate(json, ObjectUtils.notNull(target));</span>
<span class="nc" id="L848">        break;</span>
      }
      default:
<span class="nc" id="L851">        throw new UnsupportedOperationException(&quot;Unsupported format: &quot; + asFormat.name());</span>
      }
<span class="nc" id="L853">      return retval;</span>
    }

    /**
     * Get a JSON schema to use for content validation.
     *
     * @param json
     *          the JSON content to validate
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the JSON schema validator
     * @throws IOException
     *           if an error occurred while loading the schema
     * @since 2.0.0
     */
    @NonNull
    JsonSchemaContentValidator getJsonSchema(@NonNull JSONObject json, @NonNull IBindingContext bindingContext)
        throws IOException;

    /**
     * Get a XML schema to use for content validation.
     *
     * @param targetResource
     *          the URL for the XML content to validate
     * @param bindingContext
     *          the Metaschema binding context used to load bound resources
     * @return the XML schema validator
     * @throws IOException
     *           if an error occurred while loading the schema
     * @throws SAXException
     *           if an error occurred while parsing the schema
     * @since 2.0.0
     */
    @NonNull
    XmlSchemaContentValidator getXmlSchemas(@NonNull URL targetResource, @NonNull IBindingContext bindingContext)
        throws IOException, SAXException;
  }

  /**
   * Implementations of this interface provide a means by which a bound class can
   * be found that corresponds to an XML element, JSON property, or YAML item
   * name.
   */
  interface IBindingMatcher {
    /**
     * Construct a new binding matcher for the provided assembly definition.
     *
     * @param assembly
     *          the assembly definition that matcher is for
     * @return the matcher
     */
    @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
    @NonNull
    static IBindingMatcher of(IBoundDefinitionModelAssembly assembly) {
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">      if (!assembly.isRoot()) {</span>
<span class="nc" id="L908">        throw new IllegalArgumentException(</span>
<span class="nc" id="L909">            String.format(&quot;The provided class '%s' is not a root assembly.&quot;, assembly.getBoundClass().getName()));</span>
      }
<span class="fc" id="L911">      return new RootAssemblyBindingMatcher(assembly);</span>
    }

    /**
     * Determine the bound class for the provided XML {@link QName}.
     *
     * @param rootQName
     *          the root XML element's QName
     * @return the bound class for the XML qualified name or {@code null} if not
     *         recognized
     */
    Class&lt;? extends IBoundObject&gt; getBoundClassForXmlQName(QName rootQName);

    /**
     * Determine the bound class for the provided JSON/YAML property/item name.
     *
     * @param rootName
     *          the JSON/YAML property/item name
     * @return the bound class for the JSON property name or {@code null} if not
     *         recognized
     */
    Class&lt;? extends IBoundObject&gt; getBoundClassForJsonName(String rootName);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>