<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.codegen.impl</a> &gt; <span class="el_source">AnnotationGenerator.java</span></div><h1>AnnotationGenerator.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.codegen.impl;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.AnnotationSpec.Builder;

import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.item.node.IAssemblyNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDefinitionNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItemFactory;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFlagDefinition;
import gov.nist.secauto.metaschema.core.model.IModelDefinition;
import gov.nist.secauto.metaschema.core.model.INamedInstance;
import gov.nist.secauto.metaschema.core.model.INamedModelInstanceAbsolute;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValue;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValuesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ICardinalityConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IExpectConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexHasKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyField;
import gov.nist.secauto.metaschema.core.model.constraint.ILet;
import gov.nist.secauto.metaschema.core.model.constraint.IMatchesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IUniqueConstraint;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.databind.model.annotations.AssemblyConstraints;
import gov.nist.secauto.metaschema.databind.model.annotations.Expect;
import gov.nist.secauto.metaschema.databind.model.annotations.HasCardinality;
import gov.nist.secauto.metaschema.databind.model.annotations.Index;
import gov.nist.secauto.metaschema.databind.model.annotations.IndexHasKey;
import gov.nist.secauto.metaschema.databind.model.annotations.IsUnique;
import gov.nist.secauto.metaschema.databind.model.annotations.KeyField;
import gov.nist.secauto.metaschema.databind.model.annotations.Let;
import gov.nist.secauto.metaschema.databind.model.annotations.Matches;
import gov.nist.secauto.metaschema.databind.model.annotations.ValueConstraints;

import org.apache.logging.log4j.LogBuilder;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;

/**
 * A variety of utility functions for creating Module annotations.
 */
@SuppressWarnings({
    &quot;PMD.GodClass&quot;, &quot;PMD.CouplingBetweenObjects&quot; // utility class
})
public final class AnnotationGenerator {
<span class="fc" id="L69">  private static final Logger LOGGER = LogManager.getLogger(AnnotationGenerator.class);</span>

  private AnnotationGenerator() {
    // disable construction
  }

  /**
   * Get the default vale of the given member of an annotation.
   *
   * @param annotation
   *          the annotation to analyze
   * @param member
   *          the annotation member to analyze
   * @return the default value for the annotation member or {@code null} if there
   *         is not default value
   */
  public static Object getDefaultValue(Class&lt;?&gt; annotation, String member) {
    Method method;
    try {
<span class="fc" id="L88">      method = annotation.getDeclaredMethod(member);</span>
<span class="nc" id="L89">    } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L90">      throw new IllegalArgumentException(ex);</span>
<span class="fc" id="L91">    }</span>
    Object retval;
    try {
<span class="fc" id="L94">      retval = method.getDefaultValue();</span>
<span class="nc" id="L95">    } catch (TypeNotPresentException ex) {</span>
<span class="nc" id="L96">      retval = null; // NOPMD readability</span>
<span class="fc" id="L97">    }</span>
<span class="fc" id="L98">    return retval;</span>
  }

  private static void buildConstraint(Class&lt;?&gt; annotationType, AnnotationSpec.Builder annotation,
      IConstraint constraint) {
<span class="fc" id="L103">    String id = constraint.getId();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (id != null) {</span>
<span class="fc" id="L105">      annotation.addMember(&quot;id&quot;, &quot;$S&quot;, id);</span>
    }

<span class="fc" id="L108">    String formalName = constraint.getFormalName();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (formalName != null) {</span>
<span class="fc" id="L110">      annotation.addMember(&quot;formalName&quot;, &quot;$S&quot;, formalName);</span>
    }

<span class="fc" id="L113">    MarkupLine description = constraint.getDescription();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (description != null) {</span>
<span class="fc" id="L115">      annotation.addMember(&quot;description&quot;, &quot;$S&quot;, description.toMarkdown());</span>
    }

<span class="fc" id="L118">    annotation.addMember(&quot;level&quot;, &quot;$T.$L&quot;, IConstraint.Level.class, constraint.getLevel());</span>

<span class="fc" id="L120">    String target = constraint.getTarget();</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (!target.equals(getDefaultValue(annotationType, &quot;target&quot;))) {</span>
<span class="fc" id="L122">      annotation.addMember(&quot;target&quot;, &quot;$S&quot;, target);</span>
    }
<span class="fc" id="L124">  }</span>

  /**
   * Build a value constraints annotation.
   *
   * @param builder
   *          the annotation builder
   * @param definition
   *          the definition to get the value constraints for
   */
  public static void buildValueConstraints(
      @NonNull AnnotationSpec.Builder builder,
      @NonNull IFlagDefinition definition) {

<span class="fc" id="L138">    Map&lt;QName, ? extends ILet&gt; lets = definition.getLetExpressions();</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">    if (!lets.isEmpty() || !definition.getConstraints().isEmpty()) {</span>
<span class="fc" id="L140">      AnnotationSpec.Builder annotation = AnnotationSpec.builder(ValueConstraints.class);</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">      assert annotation != null;</span>

<span class="fc" id="L143">      applyLetAssignments(annotation, lets);</span>
<span class="fc" id="L144">      applyAllowedValuesConstraints(annotation, definition.getAllowedValuesConstraints());</span>
<span class="fc" id="L145">      applyIndexHasKeyConstraints(annotation, definition.getIndexHasKeyConstraints());</span>
<span class="fc" id="L146">      applyMatchesConstraints(annotation, definition.getMatchesConstraints());</span>
<span class="fc" id="L147">      applyExpectConstraints(annotation, definition.getExpectConstraints());</span>

<span class="fc" id="L149">      builder.addMember(&quot;valueConstraints&quot;, &quot;$L&quot;, annotation.build());</span>
    }
<span class="fc" id="L151">  }</span>

  /**
   * Build a value constraints annotation.
   *
   * @param builder
   *          the annotation builder
   * @param definition
   *          the definition to get the value constraints for
   */
  public static void buildValueConstraints(
      @NonNull AnnotationSpec.Builder builder,
      @NonNull IModelDefinition definition) {

<span class="fc" id="L165">    Map&lt;QName, ? extends ILet&gt; lets = definition.getLetExpressions();</span>
<span class="fc" id="L166">    List&lt;? extends IAllowedValuesConstraint&gt; allowedValues = definition.getAllowedValuesConstraints();</span>
<span class="fc" id="L167">    List&lt;? extends IIndexHasKeyConstraint&gt; indexHasKey = definition.getIndexHasKeyConstraints();</span>
<span class="fc" id="L168">    List&lt;? extends IMatchesConstraint&gt; matches = definition.getMatchesConstraints();</span>
<span class="fc" id="L169">    List&lt;? extends IExpectConstraint&gt; expects = definition.getExpectConstraints();</span>

<span class="fc bfc" id="L171" title="All 8 branches covered.">    if (!lets.isEmpty() || !allowedValues.isEmpty() || !indexHasKey.isEmpty() || !matches.isEmpty()</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        || !expects.isEmpty()) {</span>
<span class="fc" id="L173">      AnnotationSpec.Builder annotation = AnnotationSpec.builder(ValueConstraints.class);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">      assert annotation != null;</span>

<span class="fc" id="L176">      applyLetAssignments(annotation, lets);</span>
<span class="fc" id="L177">      applyAllowedValuesConstraints(annotation, allowedValues);</span>
<span class="fc" id="L178">      applyIndexHasKeyConstraints(annotation, indexHasKey);</span>
<span class="fc" id="L179">      applyMatchesConstraints(annotation, matches);</span>
<span class="fc" id="L180">      applyExpectConstraints(annotation, expects);</span>

<span class="fc" id="L182">      builder.addMember(&quot;valueConstraints&quot;, &quot;$L&quot;, annotation.build());</span>
    }
<span class="fc" id="L184">  }</span>

  /**
   * Build an assembly constraints annotation.
   *
   * @param builder
   *          the annotation builder
   * @param definition
   *          the definition to get the value constraints for
   */
  public static void buildAssemblyConstraints(
      @NonNull AnnotationSpec.Builder builder,
      @NonNull IAssemblyDefinition definition) {

<span class="fc" id="L198">    List&lt;? extends IIndexConstraint&gt; index = definition.getIndexConstraints();</span>
<span class="fc" id="L199">    List&lt;? extends IUniqueConstraint&gt; unique = definition.getUniqueConstraints();</span>
<span class="fc" id="L200">    List&lt;? extends ICardinalityConstraint&gt; cardinality = definition.getHasCardinalityConstraints();</span>

<span class="fc bfc" id="L202" title="All 6 branches covered.">    if (!index.isEmpty() || !unique.isEmpty() || !cardinality.isEmpty()) {</span>
<span class="fc" id="L203">      AnnotationSpec.Builder annotation = ObjectUtils.notNull(AnnotationSpec.builder(AssemblyConstraints.class));</span>

<span class="fc" id="L205">      applyIndexConstraints(annotation, index);</span>
<span class="fc" id="L206">      applyUniqueConstraints(annotation, unique);</span>
<span class="fc" id="L207">      applyHasCardinalityConstraints(definition, annotation, cardinality);</span>

<span class="fc" id="L209">      builder.addMember(&quot;modelConstraints&quot;, &quot;$L&quot;, annotation.build());</span>
    }
<span class="fc" id="L211">  }</span>

  private static void applyLetAssignments(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull Map&lt;QName, ? extends ILet&gt; lets) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">    for (ILet let : lets.values()) {</span>
<span class="fc" id="L217">      AnnotationSpec.Builder letAnnotation = AnnotationSpec.builder(Let.class);</span>
<span class="fc" id="L218">      letAnnotation.addMember(&quot;name&quot;, &quot;$S&quot;, let.getName());</span>
<span class="fc" id="L219">      letAnnotation.addMember(&quot;target&quot;, &quot;$S&quot;, let.getValueExpression().getPath());</span>

<span class="fc" id="L221">      MarkupMultiline remarks = let.getRemarks();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L223">        letAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L226">      annotation.addMember(&quot;lets&quot;, &quot;$L&quot;, letAnnotation.build());</span>
<span class="fc" id="L227">    }</span>
<span class="fc" id="L228">  }</span>

  private static void applyAllowedValuesConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IAllowedValuesConstraint&gt; constraints) {
<span class="fc bfc" id="L233" title="All 2 branches covered.">    for (IAllowedValuesConstraint constraint : constraints) {</span>
<span class="fc" id="L234">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(AllowedValues.class);</span>
<span class="fc" id="L235">      buildConstraint(AllowedValues.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L237">      boolean isAllowedOther = constraint.isAllowedOther();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">      if (isAllowedOther != (boolean) getDefaultValue(AllowedValues.class, &quot;allowOthers&quot;)) {</span>
<span class="fc" id="L239">        constraintAnnotation.addMember(&quot;allowOthers&quot;, &quot;$L&quot;, isAllowedOther);</span>
      }

<span class="fc bfc" id="L242" title="All 2 branches covered.">      for (IAllowedValue value : constraint.getAllowedValues().values()) {</span>
<span class="fc" id="L243">        AnnotationSpec.Builder valueAnnotation = AnnotationSpec.builder(AllowedValue.class);</span>

<span class="fc" id="L245">        valueAnnotation.addMember(&quot;value&quot;, &quot;$S&quot;, value.getValue());</span>
<span class="fc" id="L246">        valueAnnotation.addMember(&quot;description&quot;, &quot;$S&quot;, value.getDescription().toMarkdown());</span>

<span class="fc" id="L248">        String deprecatedVersion = value.getDeprecatedVersion();</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (deprecatedVersion != null) {</span>
<span class="fc" id="L250">          valueAnnotation.addMember(&quot;deprecatedVersion&quot;, &quot;$S&quot;, deprecatedVersion);</span>
        }

<span class="fc" id="L253">        constraintAnnotation.addMember(&quot;values&quot;, &quot;$L&quot;, valueAnnotation.build());</span>
<span class="fc" id="L254">      }</span>

<span class="fc" id="L256">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L258">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="fc" id="L260">      annotation.addMember(&quot;allowedValues&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L261">    }</span>
<span class="fc" id="L262">  }</span>

  private static void applyIndexHasKeyConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IIndexHasKeyConstraint&gt; constraints) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">    for (IIndexHasKeyConstraint constraint : constraints) {</span>
<span class="fc" id="L268">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(IndexHasKey.class);</span>
<span class="fc" id="L269">      buildConstraint(IndexHasKey.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L271">      constraintAnnotation.addMember(&quot;indexName&quot;, &quot;$S&quot;, constraint.getIndexName());</span>

<span class="fc" id="L273">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="fc" id="L275">      String message = constraint.getMessage();</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">      if (message != null) {</span>
<span class="nc" id="L277">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, message);</span>
      }

<span class="fc" id="L280">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L282">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L285">      annotation.addMember(&quot;indexHasKey&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L286">    }</span>
<span class="fc" id="L287">  }</span>

  private static void buildKeyFields(
      @NonNull Builder constraintAnnotation,
      @NonNull List&lt;? extends IKeyField&gt; keyFields) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">    for (IKeyField key : keyFields) {</span>
<span class="fc" id="L293">      AnnotationSpec.Builder keyAnnotation = AnnotationSpec.builder(KeyField.class);</span>

<span class="fc" id="L295">      String target = key.getTarget();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (!target.equals(getDefaultValue(KeyField.class, &quot;target&quot;))) {</span>
<span class="fc" id="L297">        keyAnnotation.addMember(&quot;target&quot;, &quot;$S&quot;, target);</span>
      }

<span class="fc" id="L300">      Pattern pattern = key.getPattern();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">      if (pattern != null) {</span>
<span class="fc" id="L302">        keyAnnotation.addMember(&quot;pattern&quot;, &quot;$S&quot;, pattern.pattern());</span>
      }

<span class="fc" id="L305">      MarkupMultiline remarks = key.getRemarks();</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L307">        keyAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L310">      constraintAnnotation.addMember(&quot;keyFields&quot;, &quot;$L&quot;, keyAnnotation.build());</span>
<span class="fc" id="L311">    }</span>
<span class="fc" id="L312">  }</span>

  private static void applyMatchesConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IMatchesConstraint&gt; constraints) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">    for (IMatchesConstraint constraint : constraints) {</span>
<span class="fc" id="L318">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Matches.class);</span>
<span class="fc" id="L319">      buildConstraint(Matches.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L321">      Pattern pattern = constraint.getPattern();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      if (pattern != null) {</span>
<span class="fc" id="L323">        constraintAnnotation.addMember(&quot;pattern&quot;, &quot;$S&quot;, pattern.pattern());</span>
      }

<span class="fc" id="L326">      IDataTypeAdapter&lt;?&gt; dataType = constraint.getDataType();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      if (dataType != null) {</span>
<span class="fc" id="L328">        constraintAnnotation.addMember(&quot;typeAdapter&quot;, &quot;$T.class&quot;, dataType.getClass());</span>
      }

<span class="fc" id="L331">      String message = constraint.getMessage();</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">      if (message != null) {</span>
<span class="nc" id="L333">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, message);</span>
      }

<span class="fc" id="L336">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L338">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="fc" id="L340">      annotation.addMember(&quot;matches&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L341">    }</span>
<span class="fc" id="L342">  }</span>

  private static void applyExpectConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IExpectConstraint&gt; constraints) {
<span class="fc bfc" id="L347" title="All 2 branches covered.">    for (IExpectConstraint constraint : constraints) {</span>
<span class="fc" id="L348">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Expect.class);</span>

<span class="fc" id="L350">      buildConstraint(Expect.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L352">      constraintAnnotation.addMember(&quot;test&quot;, &quot;$S&quot;, constraint.getTest());</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">      if (constraint.getMessage() != null) {</span>
<span class="fc" id="L355">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, constraint.getMessage());</span>
      }

<span class="fc" id="L358">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L360">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L363">      annotation.addMember(&quot;expect&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L364">    }</span>
<span class="fc" id="L365">  }</span>

  private static void applyIndexConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IIndexConstraint&gt; constraints) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">    for (IIndexConstraint constraint : constraints) {</span>
<span class="fc" id="L371">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Index.class);</span>

<span class="fc" id="L373">      buildConstraint(Index.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L375">      constraintAnnotation.addMember(&quot;name&quot;, &quot;$S&quot;, constraint.getName());</span>

<span class="fc" id="L377">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="fc" id="L379">      String message = constraint.getMessage();</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">      if (message != null) {</span>
<span class="nc" id="L381">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, message);</span>
      }

<span class="fc" id="L384">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L386">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L389">      annotation.addMember(&quot;index&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L390">    }</span>
<span class="fc" id="L391">  }</span>

  private static void applyUniqueConstraints(
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends IUniqueConstraint&gt; constraints) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">    for (IUniqueConstraint constraint : constraints) {</span>
<span class="fc" id="L397">      AnnotationSpec.Builder constraintAnnotation = ObjectUtils.notNull(AnnotationSpec.builder(IsUnique.class));</span>

<span class="fc" id="L399">      buildConstraint(IsUnique.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L401">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="fc" id="L403">      String message = constraint.getMessage();</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">      if (message != null) {</span>
<span class="nc" id="L405">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, message);</span>
      }

<span class="fc" id="L408">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L410">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="fc" id="L413">      annotation.addMember(&quot;unique&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="fc" id="L414">    }</span>
<span class="fc" id="L415">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkCardinalities(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; instanceSet,
      @NonNull LogBuilder logBuilder) {

<span class="fc" id="L426">    LogBuilder warn = LOGGER.atWarn();</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">    for (IDefinitionNodeItem&lt;?, ?&gt; item : instanceSet.getValue()) {</span>
<span class="nc" id="L428">      INamedInstance instance = item.getInstance();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (instance instanceof INamedModelInstanceAbsolute) {</span>
<span class="nc" id="L430">        INamedModelInstanceAbsolute modelInstance = (INamedModelInstanceAbsolute) instance;</span>

<span class="nc" id="L432">        checkMinOccurs(definition, constraint, modelInstance, logBuilder);</span>
<span class="nc" id="L433">        checkMaxOccurs(definition, constraint, modelInstance, logBuilder);</span>
<span class="nc" id="L434">      } else {</span>
<span class="nc" id="L435">        warn.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that is not a model instance&quot;,
<span class="nc" id="L437">            definition.getName(), constraint.getMinOccurs(), constraint.getTarget()));</span>
      }
<span class="nc" id="L439">    }</span>
<span class="fc" id="L440">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkMinOccurs(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull INamedModelInstanceAbsolute modelInstance,
      @NonNull LogBuilder logBuilder) {
<span class="nc" id="L450">    Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">    if (minOccurs != null) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">      if (minOccurs == modelInstance.getMinOccurs()) {</span>
<span class="nc" id="L453">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that is redundant with a&quot;
                + &quot; targeted instance named '%s' that requires min-occurs=%d&quot;,
<span class="nc" id="L456">            definition.getName(), minOccurs, constraint.getTarget(),</span>
<span class="nc" id="L457">            modelInstance.getName(),</span>
<span class="nc" id="L458">            modelInstance.getMinOccurs()));</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">      } else if (minOccurs &lt; modelInstance.getMinOccurs()) {</span>
<span class="nc" id="L460">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that conflicts with a&quot;
                + &quot; targeted instance named '%s' that requires min-occurs=%d&quot;,
<span class="nc" id="L463">            definition.getName(), minOccurs, constraint.getTarget(),</span>
<span class="nc" id="L464">            modelInstance.getName(),</span>
<span class="nc" id="L465">            modelInstance.getMinOccurs()));</span>
      }
    }
<span class="nc" id="L468">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkMaxOccurs(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull INamedModelInstanceAbsolute modelInstance,
      @NonNull LogBuilder logBuilder) {
<span class="nc" id="L478">    Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">    if (maxOccurs != null) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      if (maxOccurs == modelInstance.getMaxOccurs()) {</span>
<span class="nc" id="L481">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has max-occurs=%d cardinality constraint targeting '%s' that is redundant with a&quot;
                + &quot; targeted instance named '%s' that requires max-occurs=%d&quot;,
<span class="nc" id="L484">            definition.getName(), maxOccurs, constraint.getTarget(),</span>
<span class="nc" id="L485">            modelInstance.getName(),</span>
<span class="nc" id="L486">            modelInstance.getMaxOccurs()));</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      } else if (maxOccurs &lt; modelInstance.getMaxOccurs()) {</span>
<span class="nc" id="L488">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has max-occurs=%d cardinality constraint targeting '%s' that conflicts with a&quot;
                + &quot; targeted instance named '%s' that requires max-occurs=%d&quot;,
<span class="nc" id="L491">            definition.getName(), maxOccurs, constraint.getTarget(),</span>
<span class="nc" id="L492">            modelInstance.getName(),</span>
<span class="nc" id="L493">            modelInstance.getMaxOccurs()));</span>
      }
    }
<span class="nc" id="L496">  }</span>

  private static void applyHasCardinalityConstraints(
      @NonNull IAssemblyDefinition definition,
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends ICardinalityConstraint&gt; constraints) {

<span class="fc" id="L503">    DynamicContext dynamicContext = new DynamicContext();</span>
<span class="fc" id="L504">    dynamicContext.disablePredicateEvaluation();</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">    for (ICardinalityConstraint constraint : constraints) {</span>

      IAssemblyNodeItem definitionNodeItem
<span class="fc" id="L509">          = INodeItemFactory.instance().newAssemblyNodeItem(definition);</span>

<span class="fc" id="L511">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; instanceSet</span>
<span class="fc" id="L512">          = constraint.matchTargets(definitionNodeItem, dynamicContext);</span>

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">      if (LOGGER.isWarnEnabled()) {</span>
<span class="fc" id="L515">        checkCardinalities(definition, constraint, instanceSet, ObjectUtils.notNull(LOGGER.atWarn()));</span>
      }

<span class="fc" id="L518">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(HasCardinality.class);</span>

<span class="fc" id="L520">      buildConstraint(HasCardinality.class, constraintAnnotation, constraint);</span>

<span class="fc" id="L522">      Integer minOccurs = constraint.getMinOccurs();</span>
<span class="pc bpc" id="L523" title="1 of 4 branches missed.">      if (minOccurs != null &amp;&amp; !minOccurs.equals(getDefaultValue(HasCardinality.class, &quot;minOccurs&quot;))) {</span>
<span class="fc" id="L524">        constraintAnnotation.addMember(&quot;minOccurs&quot;, &quot;$L&quot;, minOccurs);</span>
      }

<span class="fc" id="L527">      Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="pc bpc" id="L528" title="1 of 4 branches missed.">      if (maxOccurs != null &amp;&amp; !maxOccurs.equals(getDefaultValue(HasCardinality.class, &quot;maxOccurs&quot;))) {</span>
<span class="fc" id="L529">        constraintAnnotation.addMember(&quot;maxOccurs&quot;, &quot;$L&quot;, maxOccurs);</span>
      }

<span class="fc" id="L532">      annotation.addMember(&quot;cardinality&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>

<span class="fc" id="L534">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">      if (remarks != null) {</span>
<span class="fc" id="L536">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="fc" id="L538">    }</span>
<span class="fc" id="L539">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>