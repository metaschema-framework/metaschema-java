<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultBindingConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.codegen.config</a> &gt; <span class="el_source">DefaultBindingConfiguration.java</span></div><h1>DefaultBindingConfiguration.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.codegen.config;

import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFieldDefinition;
import gov.nist.secauto.metaschema.core.model.IModelDefinition;
import gov.nist.secauto.metaschema.core.model.IModule;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.codegen.ClassUtils;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.JavaModelBindingType;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.JavaObjectDefinitionBindingType;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.MetaschemaBindingType;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.MetaschemaBindingsDocument;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.MetaschemaBindingsType;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.ModelBindingType;
import gov.nist.secauto.metaschema.databind.codegen.xmlbeans.ObjectDefinitionBindingType;

import org.apache.xmlbeans.XmlException;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

<span class="fc" id="L40">public class DefaultBindingConfiguration implements IBindingConfiguration {</span>
<span class="fc" id="L41">  private final Map&lt;String, String&gt; namespaceToPackageNameMap = new ConcurrentHashMap&lt;&gt;();</span>
  // metaschema location -&gt; ModelType -&gt; Definition name -&gt; IBindingConfiguration
<span class="fc" id="L43">  private final Map&lt;String, MetaschemaBindingConfiguration&gt; moduleUrlToMetaschemaBindingConfigurationMap</span>
      = new ConcurrentHashMap&lt;&gt;();

  @Override
  public String getPackageNameForModule(IModule module) {
<span class="fc" id="L48">    URI namespace = module.getXmlNamespace();</span>
<span class="fc" id="L49">    return getPackageNameForNamespace(ObjectUtils.notNull(namespace.toASCIIString()));</span>
  }

  /**
   * Retrieve the binding configuration for the provided {@code definition}.
   *
   * @param definition
   *          the definition to get the config for
   * @return the binding configuration or {@code null} if there is not
   *         configuration
   */
  @Nullable
  public IDefinitionBindingConfiguration getBindingConfigurationForDefinition(
      @NonNull IModelDefinition definition) {
<span class="fc" id="L63">    String moduleUri = ObjectUtils.notNull(definition.getContainingModule().getLocation().toASCIIString());</span>
<span class="fc" id="L64">    String definitionName = definition.getName();</span>

<span class="fc" id="L66">    MetaschemaBindingConfiguration metaschemaConfig = getMetaschemaBindingConfiguration(moduleUri);</span>

<span class="fc" id="L68">    IDefinitionBindingConfiguration retval = null;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    if (metaschemaConfig != null) {</span>
<span class="pc bpc" id="L70" title="1 of 3 branches missed.">      switch (definition.getModelType()) {</span>
      case ASSEMBLY:
<span class="fc" id="L72">        retval = metaschemaConfig.getAssemblyDefinitionBindingConfig(definitionName);</span>
<span class="fc" id="L73">        break;</span>
      case FIELD:
<span class="fc" id="L75">        retval = metaschemaConfig.getFieldDefinitionBindingConfig(definitionName);</span>
<span class="fc" id="L76">        break;</span>
      default:
<span class="nc" id="L78">        throw new UnsupportedOperationException(</span>
<span class="nc" id="L79">            String.format(&quot;Unsupported definition type '%s'&quot;, definition.getModelType()));</span>
      }
    }
<span class="fc" id="L82">    return retval;</span>
  }

  @Override
  public String getQualifiedBaseClassName(IModelDefinition definition) {
<span class="fc" id="L87">    IDefinitionBindingConfiguration config = getBindingConfigurationForDefinition(definition);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    return config == null</span>
<span class="fc" id="L89">        ? null</span>
<span class="fc" id="L90">        : config.getQualifiedBaseClassName();</span>
  }

  @Override
  public String getClassName(IModelDefinition definition) {
<span class="fc" id="L95">    IDefinitionBindingConfiguration config = getBindingConfigurationForDefinition(definition);</span>

<span class="fc" id="L97">    String retval = null;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">    if (config != null) {</span>
<span class="fc" id="L99">      retval = config.getClassName();</span>
    }

<span class="fc bfc" id="L102" title="All 2 branches covered.">    if (retval == null) {</span>
<span class="fc" id="L103">      retval = ClassUtils.toClassName(definition.getName());</span>
    }
<span class="fc" id="L105">    return retval;</span>
  }

  @Override
  public @NonNull
  String getClassName(@NonNull IModule module) {
    // TODO: make this configurable
<span class="fc" id="L112">    return ClassUtils.toClassName(module.getShortName() + &quot;Module&quot;);</span>
  }

  @Override
  public List&lt;String&gt; getQualifiedSuperinterfaceClassNames(IModelDefinition definition) {
<span class="fc" id="L117">    IDefinitionBindingConfiguration config = getBindingConfigurationForDefinition(definition);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    return config == null</span>
<span class="fc" id="L119">        ? CollectionUtil.emptyList()</span>
<span class="fc" id="L120">        : config.getInterfacesToImplement();</span>
  }

  /**
   * Binds an XML namespace, which is normally associated with one or more Module,
   * with a provided Java package name.
   *
   * @param namespace
   *          an XML namespace URI
   * @param packageName
   *          the package name to associate with the namespace
   * @throws IllegalStateException
   *           if the binding configuration is changing a previously changed
   *           namespace to package binding
   */
  public void addModelBindingConfig(String namespace, String packageName) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    if (namespaceToPackageNameMap.containsKey(namespace)) {</span>
<span class="nc" id="L137">      String oldPackageName = namespaceToPackageNameMap.get(namespace);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">      if (!oldPackageName.equals(packageName)) {</span>
<span class="nc" id="L139">        throw new IllegalStateException(</span>
<span class="nc" id="L140">            String.format(&quot;Attempt to redefine existing package name '%s' to '%s' for namespace '%s'&quot;,</span>
                oldPackageName,
                packageName,
                namespace));
      } // else the same package name, so do nothing
<span class="nc" id="L145">    } else {</span>
<span class="fc" id="L146">      namespaceToPackageNameMap.put(namespace, packageName);</span>
    }
<span class="fc" id="L148">  }</span>

  /**
   * Based on the current binding configuration, generate a Java package name for
   * the provided namespace. If the namespace is already mapped, such as through
   * the use of {@link #addModelBindingConfig(String, String)}, then the provided
   * package name will be used. If the namespace is not mapped, then the namespace
   * URI will be translated into a Java package name.
   *
   * @param namespace
   *          the namespace to generate a Java package name for
   * @return a Java package name
   */
  @NonNull
  protected String getPackageNameForNamespace(@NonNull String namespace) {
<span class="fc" id="L163">    String packageName = namespaceToPackageNameMap.get(namespace);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (packageName == null) {</span>
<span class="fc" id="L165">      packageName = ClassUtils.toPackageName(namespace);</span>
    }
<span class="fc" id="L167">    return packageName;</span>
  }

  /**
   * Get the binding configuration for the provided Module.
   *
   * @param module
   *          the Module module
   * @return the configuration for the Module or {@code null} if there is no
   *         configuration
   */
  protected MetaschemaBindingConfiguration getMetaschemaBindingConfiguration(@NonNull IModule module) {
<span class="nc" id="L179">    String moduleUri = ObjectUtils.notNull(module.getLocation().toString());</span>
<span class="nc" id="L180">    return getMetaschemaBindingConfiguration(moduleUri);</span>

  }

  /**
   * Get the binding configuration for the Module modulke located at the provided
   * {@code moduleUri}.
   *
   * @param moduleUri
   *          the location of the Module module
   * @return the configuration for the Module module or {@code null} if there is
   *         no configuration
   */
  @Nullable
  protected MetaschemaBindingConfiguration getMetaschemaBindingConfiguration(@NonNull String moduleUri) {
<span class="fc" id="L195">    return moduleUrlToMetaschemaBindingConfigurationMap.get(moduleUri);</span>
  }

  /**
   * Set the binding configuration for the Module module located at the provided
   * {@code moduleUri}.
   *
   * @param moduleUri
   *          the location of the Module module
   * @param config
   *          the Module binding configuration
   * @return the old configuration for the Module module or {@code null} if there
   *         was no previous configuration
   */
  public MetaschemaBindingConfiguration addMetaschemaBindingConfiguration(
      @NonNull String moduleUri,
      @NonNull MetaschemaBindingConfiguration config) {
<span class="fc" id="L212">    Objects.requireNonNull(moduleUri, &quot;moduleUri&quot;);</span>
<span class="fc" id="L213">    Objects.requireNonNull(config, &quot;config&quot;);</span>
<span class="fc" id="L214">    return moduleUrlToMetaschemaBindingConfigurationMap.put(moduleUri, config);</span>
  }

  /**
   * Load the binding configuration from the provided {@code file}.
   *
   * @param file
   *          the configuration resource
   * @throws IOException
   *           if an error occurred while reading the {@code file}
   */
  public void load(Path file) throws IOException {
<span class="fc" id="L226">    URL resource = file.toAbsolutePath().normalize().toUri().toURL();</span>
<span class="fc" id="L227">    load(resource);</span>
<span class="fc" id="L228">  }</span>

  /**
   * Load the binding configuration from the provided {@code file}.
   *
   * @param file
   *          the configuration resource
   * @throws IOException
   *           if an error occurred while reading the {@code file}
   */
  public void load(File file) throws IOException {
<span class="fc" id="L239">    load(file.toPath());</span>
<span class="fc" id="L240">  }</span>

  /**
   * Load the binding configuration from the provided {@code resource}.
   *
   * @param resource
   *          the configuration resource
   * @throws IOException
   *           if an error occurred while reading the {@code resource}
   */
  public void load(URL resource) throws IOException {
    MetaschemaBindingsDocument xml;
    try {
<span class="fc" id="L253">      xml = MetaschemaBindingsDocument.Factory.parse(resource);</span>
<span class="nc" id="L254">    } catch (XmlException ex) {</span>
<span class="nc" id="L255">      throw new IOException(ex);</span>
<span class="fc" id="L256">    }</span>

<span class="fc" id="L258">    MetaschemaBindingsType bindings = xml.getMetaschemaBindings();</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">    for (ModelBindingType model : bindings.getModelBindingList()) {</span>
<span class="fc" id="L261">      processModelBindingConfig(model);</span>
<span class="fc" id="L262">    }</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">    for (MetaschemaBindingType metaschema : bindings.getMetaschemaBindingList()) {</span>
      try {
<span class="fc" id="L266">        processMetaschemaBindingConfig(resource, metaschema);</span>
<span class="nc" id="L267">      } catch (MalformedURLException | URISyntaxException ex) {</span>
<span class="nc" id="L268">        throw new IOException(ex);</span>
<span class="fc" id="L269">      }</span>
<span class="fc" id="L270">    }</span>
<span class="fc" id="L271">  }</span>

  private void processModelBindingConfig(ModelBindingType model) {
<span class="fc" id="L274">    String namespace = model.getNamespace();</span>

<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    if (model.isSetJava()) {</span>
<span class="fc" id="L277">      JavaModelBindingType java = model.getJava();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">      if (java.isSetUsePackageName()) {</span>
<span class="fc" id="L279">        addModelBindingConfig(namespace, java.getUsePackageName());</span>
      }
    }
<span class="fc" id="L282">  }</span>

  private void processMetaschemaBindingConfig(URL configResource, MetaschemaBindingType metaschema)
      throws MalformedURLException, URISyntaxException {
<span class="fc" id="L286">    String href = metaschema.getHref();</span>
<span class="fc" id="L287">    URL moduleUrl = new URL(configResource, href);</span>
<span class="fc" id="L288">    String moduleUri = ObjectUtils.notNull(moduleUrl.toURI().normalize().toString());</span>

<span class="fc" id="L290">    MetaschemaBindingConfiguration metaschemaConfig = getMetaschemaBindingConfiguration(moduleUri);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (metaschemaConfig == null) {</span>
<span class="fc" id="L292">      metaschemaConfig = new MetaschemaBindingConfiguration();</span>
<span class="fc" id="L293">      addMetaschemaBindingConfiguration(moduleUri, metaschemaConfig);</span>
    }
<span class="fc bfc" id="L295" title="All 2 branches covered.">    for (ObjectDefinitionBindingType assemblyBinding : metaschema.getDefineAssemblyBindingList()) {</span>
<span class="fc" id="L296">      String name = ObjectUtils.requireNonNull(assemblyBinding.getName());</span>
<span class="fc" id="L297">      IDefinitionBindingConfiguration config = metaschemaConfig.getAssemblyDefinitionBindingConfig(name);</span>
<span class="fc" id="L298">      config = processDefinitionBindingConfiguration(config, assemblyBinding);</span>
<span class="fc" id="L299">      metaschemaConfig.addAssemblyDefinitionBindingConfig(name, config);</span>
<span class="fc" id="L300">    }</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">    for (ObjectDefinitionBindingType fieldBinding : metaschema.getDefineFieldBindingList()) {</span>
<span class="fc" id="L303">      String name = ObjectUtils.requireNonNull(fieldBinding.getName());</span>
<span class="fc" id="L304">      IDefinitionBindingConfiguration config = metaschemaConfig.getFieldDefinitionBindingConfig(name);</span>
<span class="fc" id="L305">      config = processDefinitionBindingConfiguration(config, fieldBinding);</span>
<span class="fc" id="L306">      metaschemaConfig.addFieldDefinitionBindingConfig(name, config);</span>
<span class="fc" id="L307">    }</span>
<span class="fc" id="L308">  }</span>

  @NonNull
  private static IMutableDefinitionBindingConfiguration processDefinitionBindingConfiguration(
      @Nullable IDefinitionBindingConfiguration oldConfig,
      @NonNull ObjectDefinitionBindingType objectDefinitionBinding) {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    IMutableDefinitionBindingConfiguration config = oldConfig == null</span>
<span class="fc" id="L315">        ? new DefaultDefinitionBindingConfiguration()</span>
<span class="pc" id="L316">        : new DefaultDefinitionBindingConfiguration(oldConfig);</span>

<span class="pc bpc" id="L318" title="1 of 2 branches missed.">    if (objectDefinitionBinding.isSetJava()) {</span>
<span class="fc" id="L319">      JavaObjectDefinitionBindingType java = objectDefinitionBinding.getJava();</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">      if (java.isSetUseClassName()) {</span>
<span class="fc" id="L321">        config.setClassName(ObjectUtils.notNull(java.getUseClassName()));</span>
      }

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">      if (java.isSetExtendBaseClass()) {</span>
<span class="nc" id="L325">        config.setQualifiedBaseClassName(ObjectUtils.notNull(java.getExtendBaseClass()));</span>
      }

<span class="fc bfc" id="L328" title="All 2 branches covered.">      for (String interfaceName : java.getImplementInterfaceList()) {</span>
<span class="fc" id="L329">        config.addInterfaceToImplement(ObjectUtils.notNull(interfaceName));</span>
<span class="fc" id="L330">      }</span>
    }
<span class="fc" id="L332">    return config;</span>
  }

  public static final class MetaschemaBindingConfiguration {
<span class="fc" id="L336">    private final Map&lt;String, IDefinitionBindingConfiguration&gt; assemblyBindingConfigs = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L337">    private final Map&lt;String, IDefinitionBindingConfiguration&gt; fieldBindingConfigs = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L339">    private MetaschemaBindingConfiguration() {</span>
<span class="fc" id="L340">    }</span>

    /**
     * Get the binding configuration for the {@link IAssemblyDefinition} with the
     * provided {@code name}.
     *
     * @param name
     *          the definition name
     * @return the definition's binding configuration or {@code null} if no
     *         configuration is provided
     */
    @Nullable
    public IDefinitionBindingConfiguration getAssemblyDefinitionBindingConfig(@NonNull String name) {
<span class="fc" id="L353">      return assemblyBindingConfigs.get(name);</span>
    }

    /**
     * Get the binding configuration for the {@link IFieldDefinition} with the
     * provided {@code name}.
     *
     * @param name
     *          the definition name
     * @return the definition's binding configuration or {@code null} if no
     *         configuration is provided
     */
    @Nullable
    public IDefinitionBindingConfiguration getFieldDefinitionBindingConfig(@NonNull String name) {
<span class="fc" id="L367">      return fieldBindingConfigs.get(name);</span>
    }

    /**
     * Set the binding configuration for the {@link IAssemblyDefinition} with the
     * provided {@code name}.
     *
     * @param name
     *          the definition name
     * @param config
     *          the new binding configuration for the definition
     * @return the definition's old binding configuration or {@code null} if no
     *         configuration was previously provided
     */
    @Nullable
    public IDefinitionBindingConfiguration addAssemblyDefinitionBindingConfig(@NonNull String name,
        @NonNull IDefinitionBindingConfiguration config) {
<span class="fc" id="L384">      return assemblyBindingConfigs.put(name, config);</span>
    }

    /**
     * Set the binding configuration for the {@link IFieldDefinition} with the
     * provided {@code name}.
     *
     * @param name
     *          the definition name
     * @param config
     *          the new binding configuration for the definition
     * @return the definition's old binding configuration or {@code null} if no
     *         configuration was previously provided
     */
    @Nullable
    public IDefinitionBindingConfiguration addFieldDefinitionBindingConfig(@NonNull String name,
        @NonNull IDefinitionBindingConfiguration config) {
<span class="fc" id="L401">      return fieldBindingConfigs.put(name, config);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>