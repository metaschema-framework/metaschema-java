<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaschemaJsonReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.io.json</a> &gt; <span class="el_source">MetaschemaJsonReader.java</span></div><h1>MetaschemaJsonReader.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.io.json;

import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.util.JsonUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.io.BindingException;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundDefinitionModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundFieldValue;
import gov.nist.secauto.metaschema.databind.model.IBoundInstance;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceFlag;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModel;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelChoiceGroup;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldComplex;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelFieldScalar;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedAssembly;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedField;
import gov.nist.secauto.metaschema.databind.model.IBoundInstanceModelGroupedNamed;
import gov.nist.secauto.metaschema.databind.model.IBoundProperty;
import gov.nist.secauto.metaschema.databind.model.info.AbstractModelInstanceReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IFeatureScalarItemValueHandler;
import gov.nist.secauto.metaschema.databind.model.info.IItemReadHandler;
import gov.nist.secauto.metaschema.databind.model.info.IModelInstanceCollectionInfo;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.jdt.annotation.NotOwning;

import java.io.IOException;
import java.util.Collection;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import nl.talsmasoftware.lazy4j.Lazy;

public class MetaschemaJsonReader
    implements IJsonParsingContext, IItemReadHandler {
<span class="fc" id="L60">  private static final Logger LOGGER = LogManager.getLogger(MetaschemaJsonReader.class);</span>

<span class="fc" id="L62">  @NonNull</span>
  private final Deque&lt;JsonParser&gt; parserStack = new LinkedList&lt;&gt;();
  // @NonNull
  // private final InstanceReader instanceReader = new InstanceReader();

  @NonNull
  private final IJsonProblemHandler problemHandler;
  @NonNull
  private final Lazy&lt;ObjectMapper&gt; objectMapper;

  /**
   * Construct a new Module-aware JSON parser using the default problem handler.
   *
   * @param parser
   *          the JSON parser to parse with
   * @throws IOException
   *           if an error occurred while reading the JSON
   * @see DefaultJsonProblemHandler
   */
  @SuppressFBWarnings(value = &quot;CT_CONSTRUCTOR_THROW&quot;, justification = &quot;Use of final fields&quot;)
  public MetaschemaJsonReader(
      @NonNull JsonParser parser) throws IOException {
<span class="fc" id="L84">    this(parser, new DefaultJsonProblemHandler());</span>
<span class="fc" id="L85">  }</span>

  /**
   * Construct a new Module-aware JSON parser.
   *
   * @param parser
   *          the JSON parser to parse with
   * @param problemHandler
   *          the problem handler implementation to use
   * @throws IOException
   *           if an error occurred while reading the JSON
   */
  @SuppressFBWarnings(value = &quot;CT_CONSTRUCTOR_THROW&quot;, justification = &quot;Use of final fields&quot;)
  public MetaschemaJsonReader(
      @NonNull JsonParser parser,
<span class="fc" id="L100">      @NonNull IJsonProblemHandler problemHandler) throws IOException {</span>
<span class="fc" id="L101">    this.problemHandler = problemHandler;</span>
<span class="fc" id="L102">    this.objectMapper = ObjectUtils.notNull(Lazy.lazy(ObjectMapper::new));</span>
<span class="fc" id="L103">    push(parser);</span>
<span class="fc" id="L104">  }</span>

  @SuppressWarnings(&quot;resource&quot;)
  @NotOwning
  @Override
  public JsonParser getReader() {
<span class="fc" id="L110">    return ObjectUtils.notNull(parserStack.peek());</span>
  }

  // protected void analyzeParserStack(@NonNull String action) throws IOException
  // {
  // StringBuilder builder = new StringBuilder()
  // .append(&quot;------\n&quot;);
  //
  // for (JsonParser parser : parserStack) {
  // JsonToken token = parser.getCurrentToken();
  // if (token == null) {
  // LOGGER.info(String.format(&quot;Advancing parser: %s&quot;, parser.hashCode()));
  // token = parser.nextToken();
  // }
  //
  // String name = parser.currentName();
  // builder.append(String.format(&quot;%s: %d: %s(%s)%s\n&quot;,
  // action,
  // parser.hashCode(),
  // token.name(),
  // name == null ? &quot;&quot; : name,
  // JsonUtil.generateLocationMessage(parser)));
  // }
  // LOGGER.info(builder.toString());
  // }

  @SuppressWarnings(&quot;resource&quot;)
  public final void push(JsonParser parser) throws IOException {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    assert !parser.equals(parserStack.peek());</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (parser.getCurrentToken() == null) {</span>
<span class="fc" id="L140">      parser.nextToken();</span>
    }
<span class="fc" id="L142">    parserStack.push(parser);</span>
<span class="fc" id="L143">  }</span>

  @SuppressWarnings(&quot;resource&quot;)
  @NonNull
  public final JsonParser pop(@NonNull JsonParser parser) {
<span class="nc" id="L148">    JsonParser old = parserStack.pop();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">    assert parser.equals(old);</span>
<span class="nc" id="L150">    return ObjectUtils.notNull(parserStack.peek());</span>
  }

  @Override
  public IJsonProblemHandler getProblemHandler() {
<span class="fc" id="L155">    return problemHandler;</span>
  }

  @NonNull
  protected ObjectMapper getObjectMapper() {
<span class="nc" id="L160">    return ObjectUtils.notNull(objectMapper.get());</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @NonNull
  public &lt;T&gt; T readObject(@NonNull IBoundDefinitionModelComplex definition) throws IOException {
<span class="fc" id="L166">    T value = (T) definition.readItem(null, this);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L168">      throw new IOException(String.format(&quot;Failed to read object '%s'%s.&quot;,</span>
<span class="nc" id="L169">          definition.getDefinitionQName(),</span>
<span class="nc" id="L170">          JsonUtil.generateLocationMessage(getReader())));</span>
    }
<span class="fc" id="L172">    return value;</span>
  }

  @SuppressWarnings({ &quot;unchecked&quot; })
  @NonNull
  public &lt;T&gt; T readObjectRoot(
      @NonNull IBoundDefinitionModelComplex definition,
      @NonNull String expectedFieldName) throws IOException {
<span class="fc" id="L180">    JsonParser parser = getReader();</span>

<span class="fc" id="L182">    boolean hasStartObject = JsonToken.START_OBJECT.equals(parser.currentToken());</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">    if (hasStartObject) {</span>
      // advance past the start object
<span class="fc" id="L185">      JsonUtil.assertAndAdvance(parser, JsonToken.START_OBJECT);</span>
    }

<span class="fc" id="L188">    T retval = null;</span>
    JsonToken token;
<span class="pc bpc" id="L190" title="2 of 4 branches missed.">    while (!JsonToken.END_OBJECT.equals(token = parser.currentToken()) &amp;&amp; token != null) {</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">      if (!JsonToken.FIELD_NAME.equals(token)) {</span>
<span class="nc" id="L192">        throw new IOException(String.format(&quot;Expected FIELD_NAME token, found '%s'&quot;, token.toString()));</span>
      }

<span class="fc" id="L195">      String propertyName = ObjectUtils.notNull(parser.currentName());</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">      if (expectedFieldName.equals(propertyName)) {</span>
        // process the object value, bound to the requested class
<span class="fc" id="L198">        JsonUtil.assertAndAdvance(parser, JsonToken.FIELD_NAME);</span>

        // stop now, since we found the field
<span class="fc" id="L201">        retval = (T) definition.readItem(null, this);</span>
<span class="fc" id="L202">        break;</span>
      }

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">      if (!getProblemHandler().handleUnknownProperty(</span>
          definition,
          null,
          propertyName,
<span class="fc" id="L209">          getReader())) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (LOGGER.isWarnEnabled()) {</span>
<span class="nc" id="L211">          LOGGER.warn(&quot;Skipping unhandled JSON field '{}'{}.&quot;, propertyName, JsonUtil.toString(parser));</span>
        }
<span class="nc" id="L213">        JsonUtil.skipNextValue(parser);</span>
      }
<span class="fc" id="L215">    }</span>

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if (hasStartObject) {</span>
      // advance past the end object
<span class="fc" id="L219">      JsonUtil.assertAndAdvance(parser, JsonToken.END_OBJECT);</span>
    }

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (retval == null) {</span>
<span class="nc" id="L223">      throw new IOException(String.format(&quot;Failed to find property with name '%s'%s.&quot;,</span>
          expectedFieldName,
<span class="nc" id="L225">          JsonUtil.generateLocationMessage(parser)));</span>
    }
<span class="fc" id="L227">    return retval;</span>
  }

  // ================
  // Instance readers
  // ================

  @Nullable
  private Object readInstance(
      @NonNull IBoundProperty&lt;?&gt; instance,
      @NonNull IBoundObject parent) throws IOException {
<span class="fc" id="L238">    return instance.readItem(parent, this);</span>
  }

  @Nullable
  private &lt;T&gt; Object readModelInstance(
      @NonNull IBoundInstanceModel&lt;T&gt; instance,
      @NonNull IBoundObject parent) throws IOException {
<span class="fc" id="L245">    IModelInstanceCollectionInfo&lt;T&gt; collectionInfo = instance.getCollectionInfo();</span>
<span class="fc" id="L246">    return collectionInfo.readItems(new ModelInstanceReadHandler&lt;&gt;(instance, parent));</span>
  }

  private Object readFieldValue(
      @NonNull IBoundFieldValue instance,
      @NonNull IBoundObject parent) throws IOException {
    // handle the value key name case
<span class="fc" id="L253">    return instance.readItem(parent, this);</span>
  }

  @Nullable
  private Object readObjectProperty(
      @NonNull IBoundObject parent,
      @NonNull IBoundProperty&lt;?&gt; property) throws IOException {
    Object retval;
<span class="fc bfc" id="L261" title="All 2 branches covered.">    if (property instanceof IBoundInstanceModel) {</span>
<span class="fc" id="L262">      retval = readModelInstance((IBoundInstanceModel&lt;?&gt;) property, parent);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    } else if (property instanceof IBoundInstance) {</span>
<span class="fc" id="L264">      retval = readInstance(property, parent);</span>
    } else { // IBoundFieldValue
<span class="fc" id="L266">      retval = readFieldValue((IBoundFieldValue) property, parent);</span>
    }
<span class="fc" id="L268">    return retval;</span>
  }

  @Override
  public Object readItemFlag(IBoundObject parentItem, IBoundInstanceFlag instance) throws IOException {
<span class="fc" id="L273">    return readScalarItem(instance);</span>
  }

  @Override
  public Object readItemField(IBoundObject parentItem, IBoundInstanceModelFieldScalar instance) throws IOException {
<span class="fc" id="L278">    return readScalarItem(instance);</span>
  }

  @Override
  public IBoundObject readItemField(IBoundObject parentItem, IBoundInstanceModelFieldComplex instance)
      throws IOException {
<span class="fc" id="L284">    return readFieldObject(</span>
        parentItem,
<span class="fc" id="L286">        instance.getDefinition(),</span>
<span class="fc" id="L287">        instance.getJsonProperties(),</span>
<span class="fc" id="L288">        instance.getEffectiveJsonKey(),</span>
<span class="fc" id="L289">        getProblemHandler());</span>
  }

  @Override
  public IBoundObject readItemField(IBoundObject parentItem, IBoundInstanceModelGroupedField instance)
      throws IOException {
<span class="nc" id="L295">    IJsonProblemHandler problemHandler = new GroupedInstanceProblemHandler(instance, getProblemHandler());</span>
<span class="nc" id="L296">    IBoundDefinitionModelFieldComplex definition = instance.getDefinition();</span>
<span class="nc" id="L297">    IBoundInstanceFlag jsonValueKeyFlag = definition.getJsonValueKeyFlagInstance();</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">    IJsonProblemHandler actualProblemHandler = jsonValueKeyFlag == null</span>
<span class="nc" id="L300">        ? problemHandler</span>
<span class="nc" id="L301">        : new JsomValueKeyProblemHandler(problemHandler, jsonValueKeyFlag);</span>

<span class="nc" id="L303">    return readComplexDefinitionObject(</span>
        parentItem,
        definition,
<span class="nc" id="L306">        instance.getEffectiveJsonKey(),</span>
<span class="nc" id="L307">        new PropertyBodyHandler(instance.getJsonProperties()),</span>
        actualProblemHandler);
  }

  @Override
  public IBoundObject readItemField(IBoundObject parentItem, IBoundDefinitionModelFieldComplex definition)
      throws IOException {
<span class="fc" id="L314">    return readFieldObject(</span>
        parentItem,
        definition,
<span class="fc" id="L317">        definition.getJsonProperties(),</span>
        null,
<span class="fc" id="L319">        getProblemHandler());</span>
  }

  @Override
  public Object readItemFieldValue(IBoundObject parentItem, IBoundFieldValue fieldValue) throws IOException {
    // read the field value's value
<span class="fc" id="L325">    return checkMissingFieldValue(readScalarItem(fieldValue));</span>
  }

  @Nullable
  private Object checkMissingFieldValue(Object value) throws IOException {
<span class="pc bpc" id="L330" title="3 of 4 branches missed.">    if (value == null &amp;&amp; LOGGER.isWarnEnabled()) {</span>
<span class="nc" id="L331">      LOGGER.atWarn().log(&quot;Missing property value{}&quot;,</span>
<span class="nc" id="L332">          JsonUtil.generateLocationMessage(getReader()));</span>
    }
    // TODO: change nullness annotations to be @Nullable
<span class="fc" id="L335">    return value;</span>
  }

  @Override
  public IBoundObject readItemAssembly(IBoundObject parentItem, IBoundInstanceModelAssembly instance)
      throws IOException {
<span class="fc" id="L341">    IBoundInstanceFlag jsonKey = instance.getJsonKey();</span>
<span class="fc" id="L342">    IBoundDefinitionModelComplex definition = instance.getDefinition();</span>
<span class="fc" id="L343">    return readComplexDefinitionObject(</span>
        parentItem,
        definition,
        jsonKey,
<span class="fc" id="L347">        new PropertyBodyHandler(instance.getJsonProperties()),</span>
<span class="fc" id="L348">        getProblemHandler());</span>
  }

  @Override
  public IBoundObject readItemAssembly(IBoundObject parentItem, IBoundInstanceModelGroupedAssembly instance)
      throws IOException {
<span class="nc" id="L354">    return readComplexDefinitionObject(</span>
        parentItem,
<span class="nc" id="L356">        instance.getDefinition(),</span>
<span class="nc" id="L357">        instance.getEffectiveJsonKey(),</span>
<span class="nc" id="L358">        new PropertyBodyHandler(instance.getJsonProperties()),</span>
<span class="nc" id="L359">        new GroupedInstanceProblemHandler(instance, getProblemHandler()));</span>
  }

  @Override
  public IBoundObject readItemAssembly(IBoundObject parentItem, IBoundDefinitionModelAssembly definition)
      throws IOException {
<span class="fc" id="L365">    return readComplexDefinitionObject(</span>
        parentItem,
        definition,
        null,
<span class="fc" id="L369">        new PropertyBodyHandler(definition.getJsonProperties()),</span>
<span class="fc" id="L370">        getProblemHandler());</span>
  }

  @NonNull
  private Object readScalarItem(@NonNull IFeatureScalarItemValueHandler handler)
      throws IOException {
<span class="fc" id="L376">    return handler.getJavaTypeAdapter().parse(getReader());</span>
  }

  @NonNull
  private IBoundObject readFieldObject(
      @Nullable IBoundObject parentItem,
      @NonNull IBoundDefinitionModelFieldComplex definition,
      @NonNull Map&lt;String, IBoundProperty&lt;?&gt;&gt; jsonProperties,
      @Nullable IBoundInstanceFlag jsonKey,
      @NonNull IJsonProblemHandler problemHandler) throws IOException {
<span class="fc" id="L386">    IBoundInstanceFlag jsonValueKey = definition.getJsonValueKeyFlagInstance();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    IJsonProblemHandler actualProblemHandler = jsonValueKey == null</span>
<span class="fc" id="L388">        ? problemHandler</span>
<span class="fc" id="L389">        : new JsomValueKeyProblemHandler(problemHandler, jsonValueKey);</span>

    IBoundObject retval;
<span class="fc bfc" id="L392" title="All 4 branches covered.">    if (jsonProperties.isEmpty() &amp;&amp; jsonValueKey == null) {</span>
<span class="fc" id="L393">      retval = readComplexDefinitionObject(</span>
          parentItem,
          definition,
          jsonKey,
          (def, parent, problem) -&gt; {
<span class="fc" id="L398">            IBoundFieldValue fieldValue = definition.getFieldValue();</span>
<span class="fc" id="L399">            Object item = readItemFieldValue(parent, fieldValue);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (item != null) {</span>
<span class="fc" id="L401">              fieldValue.setValue(parent, item);</span>
            }
<span class="fc" id="L403">          },</span>
          actualProblemHandler);

    } else {
<span class="fc" id="L407">      retval = readComplexDefinitionObject(</span>
          parentItem,
          definition,
          jsonKey,
          new PropertyBodyHandler(jsonProperties),
          actualProblemHandler);
    }
<span class="fc" id="L414">    return retval;</span>
  }

  @NonNull
  private IBoundObject readComplexDefinitionObject(
      @Nullable IBoundObject parentItem,
      @NonNull IBoundDefinitionModelComplex definition,
      @Nullable IBoundInstanceFlag jsonKey,
      @NonNull DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; bodyHandler,
      @NonNull IJsonProblemHandler problemHandler) throws IOException {
<span class="fc bfc" id="L424" title="All 2 branches covered.">    DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; actualBodyHandler = jsonKey == null</span>
<span class="fc" id="L425">        ? bodyHandler</span>
<span class="fc" id="L426">        : new JsonKeyBodyHandler(jsonKey, bodyHandler);</span>

    @SuppressWarnings(&quot;resource&quot;)
<span class="fc" id="L429">    JsonLocation location = getReader().currentLocation();</span>

    // construct the item
<span class="fc" id="L432">    IBoundObject item = definition.newInstance(</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        JsonLocation.NA.equals(location)</span>
<span class="nc" id="L434">            ? null</span>
<span class="fc" id="L435">            : () -&gt; new MetaschemaData(ObjectUtils.requireNonNull(location)));</span>

    try {
      // call pre-parse initialization hook
<span class="fc" id="L439">      definition.callBeforeDeserialize(item, parentItem);</span>

      // read the property values
<span class="fc" id="L442">      actualBodyHandler.accept(definition, item, problemHandler);</span>

      // call post-parse initialization hook
<span class="fc" id="L445">      definition.callAfterDeserialize(item, parentItem);</span>
<span class="nc" id="L446">    } catch (BindingException ex) {</span>
<span class="nc" id="L447">      throw new IOException(ex);</span>
<span class="fc" id="L448">    }</span>

<span class="fc" id="L450">    return item;</span>
  }

  @SuppressWarnings(&quot;resource&quot;)
  @Override
  public IBoundObject readChoiceGroupItem(IBoundObject parentItem, IBoundInstanceModelChoiceGroup instance)
      throws IOException {
<span class="nc" id="L457">    JsonParser parser = getReader();</span>
<span class="nc" id="L458">    ObjectNode node = parser.readValueAsTree();</span>

<span class="nc" id="L460">    String discriminatorProperty = instance.getJsonDiscriminatorProperty();</span>
<span class="nc" id="L461">    JsonNode discriminatorNode = node.get(discriminatorProperty);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">    if (discriminatorNode == null) {</span>
<span class="nc" id="L463">      throw new IllegalArgumentException(String.format(</span>
          &quot;Unable to find discriminator property '%s' for object at '%s'.&quot;,
          discriminatorProperty,
<span class="nc" id="L466">          JsonUtil.toString(parser)));</span>
    }
<span class="nc" id="L468">    String discriminator = ObjectUtils.requireNonNull(discriminatorNode.asText());</span>

<span class="nc" id="L470">    IBoundInstanceModelGroupedNamed actualInstance = instance.getGroupedModelInstance(discriminator);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">    assert actualInstance != null;</span>

    IBoundObject retval;
<span class="nc" id="L474">    try (JsonParser newParser = node.traverse(parser.getCodec())) {</span>
<span class="nc" id="L475">      push(newParser);</span>

      // get initial token
<span class="nc" id="L478">      retval = actualInstance.readItem(parentItem, this);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      assert newParser.currentToken() == null;</span>
<span class="nc" id="L480">      pop(newParser);</span>
    }

    // advance the original parser to the next token
<span class="nc" id="L484">    parser.nextToken();</span>

<span class="nc" id="L486">    return retval;</span>
  }

  private final class JsonKeyBodyHandler implements DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; {
    @NonNull
    private final IBoundInstanceFlag jsonKey;
    @NonNull
    private final DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; bodyHandler;

    private JsonKeyBodyHandler(
        @NonNull IBoundInstanceFlag jsonKey,
<span class="fc" id="L497">        @NonNull DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; bodyHandler) {</span>
<span class="fc" id="L498">      this.jsonKey = jsonKey;</span>
<span class="fc" id="L499">      this.bodyHandler = bodyHandler;</span>
<span class="fc" id="L500">    }</span>

    @Override
    public void accept(
        IBoundDefinitionModelComplex definition,
        IBoundObject parent,
        IJsonProblemHandler problemHandler)
        throws IOException {
      @SuppressWarnings(&quot;resource&quot;)
<span class="fc" id="L509">      JsonParser parser = getReader();</span>
<span class="fc" id="L510">      JsonUtil.assertCurrent(parser, JsonToken.FIELD_NAME);</span>

      // the field will be the JSON key
<span class="fc" id="L513">      String key = ObjectUtils.notNull(parser.currentName());</span>
      try {
<span class="fc" id="L515">        Object value = jsonKey.getDefinition().getJavaTypeAdapter().parse(key);</span>
<span class="fc" id="L516">        jsonKey.setValue(parent, ObjectUtils.notNull(value.toString()));</span>
<span class="nc" id="L517">      } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L518">        throw new IOException(</span>
<span class="nc" id="L519">            String.format(&quot;Malformed data '%s'%s. %s&quot;,</span>
                key,
<span class="nc" id="L521">                JsonUtil.generateLocationMessage(parser),</span>
<span class="nc" id="L522">                ex.getLocalizedMessage()),</span>
            ex);
<span class="fc" id="L524">      }</span>

      // skip to the next token
<span class="fc" id="L527">      parser.nextToken();</span>
      // JsonUtil.assertCurrent(parser, JsonToken.START_OBJECT);

      // // advance past the JSON key's start object
      // JsonUtil.assertAndAdvance(parser, JsonToken.START_OBJECT);

      // read the property values
<span class="fc" id="L534">      bodyHandler.accept(definition, parent, problemHandler);</span>

      // // advance past the JSON key's end object
      // JsonUtil.assertAndAdvance(parser, JsonToken.END_OBJECT);
<span class="fc" id="L538">    }</span>
  }

  private final class PropertyBodyHandler implements DefinitionBodyHandler&lt;IBoundDefinitionModelComplex&gt; {
    @NonNull
    private final Map&lt;String, IBoundProperty&lt;?&gt;&gt; jsonProperties;

<span class="fc" id="L545">    private PropertyBodyHandler(@NonNull Map&lt;String, IBoundProperty&lt;?&gt;&gt; jsonProperties) {</span>
<span class="fc" id="L546">      this.jsonProperties = jsonProperties;</span>
<span class="fc" id="L547">    }</span>

    @Override
    public void accept(
        IBoundDefinitionModelComplex definition,
        IBoundObject parent,
        IJsonProblemHandler problemHandler)
        throws IOException {
      @SuppressWarnings(&quot;resource&quot;)
<span class="fc" id="L556">      JsonParser parser = getReader();</span>

      // advance past the start object
<span class="fc" id="L559">      JsonUtil.assertAndAdvance(parser, JsonToken.START_OBJECT);</span>

      // make a copy, since we use the remaining values to initialize default values
<span class="fc" id="L562">      Map&lt;String, IBoundProperty&lt;?&gt;&gt; remainingInstances = new HashMap&lt;&gt;(jsonProperties); // NOPMD not concurrent</span>

      // handle each property
<span class="fc bfc" id="L565" title="All 2 branches covered.">      while (JsonToken.FIELD_NAME.equals(parser.currentToken())) {</span>

        // the parser's current token should be the JSON field name
<span class="fc" id="L568">        String propertyName = ObjectUtils.notNull(parser.currentName());</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L570">          LOGGER.trace(&quot;reading property {}&quot;, propertyName);</span>
        }

<span class="fc" id="L573">        IBoundProperty&lt;?&gt; property = remainingInstances.get(propertyName);</span>

<span class="fc" id="L575">        boolean handled = false;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (property != null) {</span>
          // advance past the field name
<span class="fc" id="L578">          parser.nextToken();</span>

<span class="fc" id="L580">          Object value = readObjectProperty(parent, property);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">          if (value != null) {</span>
<span class="fc" id="L582">            property.setValue(parent, value);</span>
          }

          // mark handled
<span class="fc" id="L586">          remainingInstances.remove(propertyName);</span>
<span class="fc" id="L587">          handled = true;</span>
        }

<span class="pc bpc" id="L590" title="1 of 4 branches missed.">        if (!handled &amp;&amp; !problemHandler.handleUnknownProperty(</span>
            definition,
            parent,
            propertyName,
<span class="fc" id="L594">            getReader())) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">          if (LOGGER.isWarnEnabled()) {</span>
<span class="nc" id="L596">            LOGGER.warn(&quot;Skipping unhandled JSON field '{}' {}.&quot;, propertyName, JsonUtil.toString(parser));</span>
          }
<span class="nc" id="L598">          JsonUtil.assertAndAdvance(parser, JsonToken.FIELD_NAME);</span>
<span class="nc" id="L599">          JsonUtil.skipNextValue(parser);</span>
        }

        // the current token will be either the next instance field name or the end of
        // the parent object
<span class="fc" id="L604">        JsonUtil.assertCurrent(parser, JsonToken.FIELD_NAME, JsonToken.END_OBJECT);</span>
<span class="fc" id="L605">      }</span>

<span class="fc" id="L607">      problemHandler.handleMissingInstances(</span>
          definition,
          parent,
<span class="fc" id="L610">          ObjectUtils.notNull(remainingInstances.values()));</span>

      // advance past the end object
<span class="fc" id="L613">      JsonUtil.assertAndAdvance(parser, JsonToken.END_OBJECT);</span>
<span class="fc" id="L614">    }</span>
  }

  private final class GroupedInstanceProblemHandler implements IJsonProblemHandler {
    @NonNull
    private final IBoundInstanceModelGroupedNamed instance;
    @NonNull
    private final IJsonProblemHandler delegate;

    private GroupedInstanceProblemHandler(
        @NonNull IBoundInstanceModelGroupedNamed instance,
<span class="nc" id="L625">        @NonNull IJsonProblemHandler delegate) {</span>
<span class="nc" id="L626">      this.instance = instance;</span>
<span class="nc" id="L627">      this.delegate = delegate;</span>
<span class="nc" id="L628">    }</span>

    @Override
    public void handleMissingInstances(
        IBoundDefinitionModelComplex parentDefinition,
        IBoundObject targetObject,
        Collection&lt;? extends IBoundProperty&lt;?&gt;&gt; unhandledInstances) throws IOException {
<span class="nc" id="L635">      delegate.handleMissingInstances(parentDefinition, targetObject, unhandledInstances);</span>
<span class="nc" id="L636">    }</span>

    @Override
    public boolean handleUnknownProperty(
        IBoundDefinitionModelComplex definition,
        IBoundObject parentItem,
        String fieldName,
        JsonParser parser) throws IOException {
      boolean retval;
<span class="nc bnc" id="L645" title="All 2 branches missed.">      if (instance.getParentContainer().getJsonDiscriminatorProperty().equals(fieldName)) {</span>
<span class="nc" id="L646">        JsonUtil.skipNextValue(parser);</span>
<span class="nc" id="L647">        retval = true;</span>
      } else {
<span class="nc" id="L649">        retval = delegate.handleUnknownProperty(definition, parentItem, fieldName, getReader());</span>
      }
<span class="nc" id="L651">      return retval;</span>
    }
  }

  private final class JsomValueKeyProblemHandler implements IJsonProblemHandler {
    @NonNull
    private final IJsonProblemHandler delegate;
    @NonNull
    private final IBoundInstanceFlag jsonValueKeyFlag;
    private boolean foundJsonValueKey; // false

    private JsomValueKeyProblemHandler(
        @NonNull IJsonProblemHandler delegate,
<span class="fc" id="L664">        @NonNull IBoundInstanceFlag jsonValueKeyFlag) {</span>
<span class="fc" id="L665">      this.delegate = delegate;</span>
<span class="fc" id="L666">      this.jsonValueKeyFlag = jsonValueKeyFlag;</span>
<span class="fc" id="L667">    }</span>

    @Override
    public void handleMissingInstances(
        IBoundDefinitionModelComplex parentDefinition,
        IBoundObject targetObject,
        Collection&lt;? extends IBoundProperty&lt;?&gt;&gt; unhandledInstances) throws IOException {
<span class="fc" id="L674">      delegate.handleMissingInstances(parentDefinition, targetObject, unhandledInstances);</span>
<span class="fc" id="L675">    }</span>

    @Override
    public boolean handleUnknownProperty(
        IBoundDefinitionModelComplex definition,
        IBoundObject parentItem,
        String fieldName,
        JsonParser parser) throws IOException {
      boolean retval;
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">      if (foundJsonValueKey) {</span>
<span class="nc" id="L685">        retval = delegate.handleUnknownProperty(definition, parentItem, fieldName, parser);</span>
      } else {
        // handle JSON value key
<span class="fc" id="L688">        String key = ObjectUtils.notNull(parser.currentName());</span>
        try {
<span class="fc" id="L690">          Object keyValue = jsonValueKeyFlag.getJavaTypeAdapter().parse(key);</span>
<span class="fc" id="L691">          jsonValueKeyFlag.setValue(ObjectUtils.notNull(parentItem), keyValue);</span>
<span class="nc" id="L692">        } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L693">          throw new IOException(</span>
<span class="nc" id="L694">              String.format(&quot;Malformed data '%s'%s. %s&quot;,</span>
                  key,
<span class="nc" id="L696">                  JsonUtil.generateLocationMessage(parser),</span>
<span class="nc" id="L697">                  ex.getLocalizedMessage()),</span>
              ex);
<span class="fc" id="L699">        }</span>
        // advance past the field name
<span class="fc" id="L701">        JsonUtil.assertAndAdvance(parser, JsonToken.FIELD_NAME);</span>

<span class="fc" id="L703">        IBoundFieldValue fieldValue = ((IBoundDefinitionModelFieldComplex) definition).getFieldValue();</span>
<span class="fc" id="L704">        Object value = readItemFieldValue(ObjectUtils.notNull(parentItem), fieldValue);</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L706">          fieldValue.setValue(ObjectUtils.notNull(parentItem), value);</span>
        }

<span class="fc" id="L709">        retval = foundJsonValueKey = true;</span>
      }
<span class="fc" id="L711">      return retval;</span>
    }
  }

<span class="fc" id="L715">  private class ModelInstanceReadHandler&lt;ITEM&gt;</span>
      extends AbstractModelInstanceReadHandler&lt;ITEM&gt; {

    protected ModelInstanceReadHandler(
        @NonNull IBoundInstanceModel&lt;ITEM&gt; instance,
<span class="fc" id="L720">        @NonNull IBoundObject parentItem) {</span>
<span class="fc" id="L721">      super(instance, parentItem);</span>
<span class="fc" id="L722">    }</span>

    @Override
    public List&lt;ITEM&gt; readList() throws IOException {
<span class="fc" id="L726">      JsonParser parser = getReader();</span>

<span class="fc" id="L728">      List&lt;ITEM&gt; items = new LinkedList&lt;&gt;();</span>
<span class="pc bpc" id="L729" title="1 of 3 branches missed.">      switch (parser.currentToken()) {</span>
      case START_ARRAY:
        // this is an array, we need to parse the array wrapper then each item
<span class="fc" id="L732">        JsonUtil.assertAndAdvance(parser, JsonToken.START_ARRAY);</span>

        // parse items
<span class="fc bfc" id="L735" title="All 2 branches covered.">        while (!JsonToken.END_ARRAY.equals(parser.currentToken())) {</span>
<span class="fc" id="L736">          items.add(readItem());</span>
        }

        // this is the other side of the array wrapper, advance past it
<span class="fc" id="L740">        JsonUtil.assertAndAdvance(parser, JsonToken.END_ARRAY);</span>
<span class="fc" id="L741">        break;</span>
      case VALUE_NULL:
<span class="nc" id="L743">        JsonUtil.assertAndAdvance(parser, JsonToken.VALUE_NULL);</span>
<span class="nc" id="L744">        break;</span>
      default:
        // this is a singleton, just parse the value as a single item
<span class="fc" id="L747">        items.add(readItem());</span>
        break;
      }
<span class="fc" id="L750">      return items;</span>
    }

    @Override
    public Map&lt;String, ITEM&gt; readMap() throws IOException {
<span class="fc" id="L755">      JsonParser parser = getReader();</span>

<span class="fc" id="L757">      IBoundInstanceModel&lt;?&gt; instance = getCollectionInfo().getInstance();</span>

      @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;)
<span class="fc" id="L760">      Map&lt;String, ITEM&gt; items = new LinkedHashMap&lt;&gt;();</span>

      // A map value is always wrapped in a START_OBJECT, since fields are used for
      // the keys
<span class="fc" id="L764">      JsonUtil.assertAndAdvance(parser, JsonToken.START_OBJECT);</span>

      // process all map items
<span class="fc bfc" id="L767" title="All 2 branches covered.">      while (!JsonToken.END_OBJECT.equals(parser.currentToken())) {</span>

        // a map item will always start with a FIELD_NAME, since this represents the key
<span class="fc" id="L770">        JsonUtil.assertCurrent(parser, JsonToken.FIELD_NAME);</span>

        // get the object, since it must have a JSON key
<span class="fc" id="L773">        ITEM item = readItem();</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (item == null) {</span>
<span class="nc" id="L775">          throw new IOException(String.format(&quot;Null object encountered'%s.&quot;,</span>
<span class="nc" id="L776">              JsonUtil.generateLocationMessage(parser)));</span>
        }

        // lookup the key
<span class="fc" id="L780">        IBoundInstanceFlag jsonKey = instance.getItemJsonKey(item);</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        assert jsonKey != null;</span>

<span class="fc" id="L783">        Object keyValue = jsonKey.getValue(item);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        if (keyValue == null) {</span>
<span class="nc" id="L785">          throw new IOException(String.format(&quot;Null value for json-key for definition '%s'&quot;,</span>
<span class="nc" id="L786">              jsonKey.getContainingDefinition().toCoordinates()));</span>
        }
        String key;
        try {
<span class="fc" id="L790">          key = jsonKey.getJavaTypeAdapter().asString(keyValue);</span>
<span class="nc" id="L791">        } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L792">          throw new IOException(</span>
<span class="nc" id="L793">              String.format(&quot;Malformed data '%s'%s. %s&quot;,</span>
                  keyValue,
<span class="nc" id="L795">                  JsonUtil.generateLocationMessage(parser),</span>
<span class="nc" id="L796">                  ex.getLocalizedMessage()),</span>
              ex);
<span class="fc" id="L798">        }</span>
<span class="fc" id="L799">        items.put(key, item);</span>

        // the next item will be a FIELD_NAME, or we will encounter an END_OBJECT if all
        // items have been
        // read
<span class="fc" id="L804">        JsonUtil.assertCurrent(parser, JsonToken.FIELD_NAME, JsonToken.END_OBJECT);</span>
<span class="fc" id="L805">      }</span>

      // A map value will always end with an end object, which needs to be consumed
<span class="fc" id="L808">      JsonUtil.assertAndAdvance(parser, JsonToken.END_OBJECT);</span>

<span class="fc" id="L810">      return items;</span>
    }

    @Override
    public ITEM readItem() throws IOException {
<span class="fc" id="L815">      IBoundInstanceModel&lt;ITEM&gt; instance = getCollectionInfo().getInstance();</span>
<span class="fc" id="L816">      return instance.readItem(getParentObject(), MetaschemaJsonReader.this);</span>
    }
  }

  private static class MetaschemaData implements IMetaschemaData {
    private final int line;
    private final int column;
    private final long charOffset;
    private final long byteOffset;

<span class="fc" id="L826">    public MetaschemaData(@NonNull JsonLocation location) {</span>
<span class="fc" id="L827">      this.line = location.getLineNr();</span>
<span class="fc" id="L828">      this.column = location.getColumnNr();</span>
<span class="fc" id="L829">      this.charOffset = location.getCharOffset();</span>
<span class="fc" id="L830">      this.byteOffset = location.getByteOffset();</span>
<span class="fc" id="L831">    }</span>

    @Override
    public int getLine() {
<span class="nc" id="L835">      return line;</span>
    }

    @Override
    public int getColumn() {
<span class="nc" id="L840">      return column;</span>
    }

    @Override
    public long getCharOffset() {
<span class="nc" id="L845">      return charOffset;</span>
    }

    @Override
    public long getByteOffset() {
<span class="nc" id="L850">      return byteOffset;</span>
    }
  }

  @FunctionalInterface
  private interface DefinitionBodyHandler&lt;DEF extends IBoundDefinitionModelComplex&gt; {
    void accept(
        @NonNull DEF definition,
        @NonNull IBoundObject parent,
        @NonNull IJsonProblemHandler problemHandler) throws IOException;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>