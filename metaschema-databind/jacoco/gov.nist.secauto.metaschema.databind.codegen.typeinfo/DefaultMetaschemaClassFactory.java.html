<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMetaschemaClassFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.codegen.typeinfo</a> &gt; <span class="el_source">DefaultMetaschemaClassFactory.java</span></div><h1>DefaultMetaschemaClassFactory.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.databind.codegen.typeinfo;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;

import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IBoundObject;
import gov.nist.secauto.metaschema.core.model.IDefinition;
import gov.nist.secauto.metaschema.core.model.IFieldDefinition;
import gov.nist.secauto.metaschema.core.model.IMetaschemaData;
import gov.nist.secauto.metaschema.core.model.IModelDefinition;
import gov.nist.secauto.metaschema.core.model.IModule;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.IBindingContext;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedClass;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedDefinitionClass;
import gov.nist.secauto.metaschema.databind.codegen.IGeneratedModuleClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.AnnotationGenerator;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedDefinitionClass;
import gov.nist.secauto.metaschema.databind.codegen.impl.DefaultGeneratedModuleClass;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IAssemblyDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IFieldDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.codegen.typeinfo.def.IModelDefinitionTypeInfo;
import gov.nist.secauto.metaschema.databind.model.AbstractBoundModule;
import gov.nist.secauto.metaschema.databind.model.IBoundModule;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaField;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaModule;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaPackage;
import gov.nist.secauto.metaschema.databind.model.annotations.NsBinding;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlNs;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlNsForm;
import gov.nist.secauto.metaschema.databind.model.annotations.XmlSchema;

import org.apache.commons.lang3.builder.ReflectionToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.lang.model.element.Modifier;

import edu.umd.cs.findbugs.annotations.NonNull;

<span class="fc" id="L72">@SuppressWarnings({</span>
    &quot;PMD.CouplingBetweenObjects&quot;, // ok
    &quot;PMD.GodClass&quot;, // ok
    &quot;PMD.CyclomaticComplexity&quot; // ok
})
public class DefaultMetaschemaClassFactory implements IMetaschemaClassFactory {
  @NonNull
  private final ITypeResolver typeResolver;

  /**
   * Get a new instance of the this class generation factory that uses the
   * provided {@code typeResolver}.
   *
   * @param typeResolver
   *          the resolver used to generate type information for Metasschema
   *          constructs
   * @return the new class factory
   */
  @NonNull
  public static DefaultMetaschemaClassFactory newInstance(@NonNull ITypeResolver typeResolver) {
<span class="fc" id="L92">    return new DefaultMetaschemaClassFactory(typeResolver);</span>
  }

  /**
   * Construct a new instance of the this class ganeration factory that uses the
   * provided {@code typeResolver}.
   *
   * @param typeResolver
   *          the resolver used to generate type information for Metasschema
   *          constructs
   */
<span class="fc" id="L103">  protected DefaultMetaschemaClassFactory(@NonNull ITypeResolver typeResolver) {</span>
<span class="fc" id="L104">    this.typeResolver = typeResolver;</span>
<span class="fc" id="L105">  }</span>

  @Override
  @NonNull
  public ITypeResolver getTypeResolver() {
<span class="fc" id="L110">    return typeResolver;</span>
  }

  @Override
  public IGeneratedModuleClass generateClass(
      IModule module,
      Path targetDirectory) throws IOException {

    // Generate the Module module class
<span class="fc" id="L119">    ClassName className = getTypeResolver().getClassName(module);</span>

<span class="fc" id="L121">    TypeSpec.Builder classSpec = newClassBuilder(module, className);</span>

<span class="fc" id="L123">    JavaFile javaFile = JavaFile.builder(className.packageName(), classSpec.build()).build();</span>
<span class="fc" id="L124">    Path classFile = ObjectUtils.notNull(javaFile.writeToPath(targetDirectory));</span>

    // now generate all related definition classes
<span class="fc" id="L127">    Stream&lt;? extends IModelDefinition&gt; globalDefinitions = Stream.concat(</span>
<span class="fc" id="L128">        module.getAssemblyDefinitions().stream(),</span>
<span class="fc" id="L129">        module.getFieldDefinitions().stream());</span>

<span class="fc" id="L131">    Set&lt;String&gt; classNames = new LinkedHashSet&lt;&gt;();</span>

    @SuppressWarnings(&quot;PMD.UseConcurrentHashMap&quot;) // map is unmodifiable
<span class="fc" id="L134">    Map&lt;IModelDefinition, IGeneratedDefinitionClass&gt; definitionProductions</span>
<span class="fc" id="L135">        = ObjectUtils.notNull(globalDefinitions</span>
            // Get type information for assembly and field definitions.
            // Avoid field definitions without flags that don't require a generated class
<span class="fc" id="L138">            .flatMap(definition -&gt; {</span>
<span class="fc" id="L139">              IModelDefinitionTypeInfo typeInfo = null;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">              if (definition instanceof IAssemblyDefinition) {</span>
<span class="fc" id="L141">                typeInfo = IAssemblyDefinitionTypeInfo.newTypeInfo((IAssemblyDefinition) definition, typeResolver);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">              } else if (definition instanceof IFieldDefinition</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                  &amp;&amp; !definition.getFlagInstances().isEmpty()) {</span>
<span class="fc" id="L144">                typeInfo = IFieldDefinitionTypeInfo.newTypeInfo((IFieldDefinition) definition, typeResolver);</span>
              } // otherwise field is just a simple data value, then no class is needed
<span class="fc bfc" id="L146" title="All 2 branches covered.">              return typeInfo == null ? null : Stream.of(typeInfo);</span>
            })
            // generate the class for each type information
<span class="fc" id="L149">            .map(typeInfo -&gt; {</span>
<span class="fc" id="L150">              IModelDefinition definition = typeInfo.getDefinition();</span>
              IGeneratedDefinitionClass generatedClass;
              try {
<span class="fc" id="L153">                generatedClass = generateClass(typeInfo, targetDirectory);</span>
<span class="nc" id="L154">              } catch (RuntimeException ex) { // NOPMD - intended</span>
<span class="nc" id="L155">                throw new IllegalStateException(</span>
<span class="nc" id="L156">                    String.format(&quot;Unable to generate class for definition '%s' in Module '%s'&quot;,</span>
<span class="nc" id="L157">                        definition.getName(),</span>
<span class="nc" id="L158">                        module.getLocation()),</span>
                    ex);
<span class="nc" id="L160">              } catch (IOException ex) {</span>
<span class="nc" id="L161">                throw new IllegalStateException(ex);</span>
<span class="fc" id="L162">              }</span>
<span class="fc" id="L163">              String defClassName = generatedClass.getClassName().canonicalName();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">              if (classNames.contains(defClassName)) {</span>
<span class="nc" id="L165">                throw new IllegalStateException(String.format(</span>
                    &quot;Found duplicate class '%s' in metaschema '%s'.&quot;
                        + &quot; All class names must be unique within the same namespace.&quot;,
<span class="nc" id="L168">                    defClassName, module.getLocation()));</span>
              }
<span class="fc" id="L170">              classNames.add(defClassName);</span>
<span class="fc" id="L171">              return generatedClass;</span>
            })
            // collect the generated class information
<span class="fc" id="L174">            .collect(Collectors.toUnmodifiableMap(</span>
                IGeneratedDefinitionClass::getDefinition,
<span class="fc" id="L176">                Function.identity())));</span>
<span class="fc" id="L177">    String packageName = typeResolver.getPackageName(module);</span>
<span class="fc" id="L178">    return new DefaultGeneratedModuleClass(module, className, classFile, definitionProductions, packageName);</span>
  }

  @Override
  public IGeneratedDefinitionClass generateClass(
      IModelDefinitionTypeInfo typeInfo,
      Path targetDirectory)
      throws IOException {
<span class="fc" id="L186">    ClassName className = typeInfo.getClassName();</span>

<span class="fc" id="L188">    TypeSpec.Builder classSpec = newClassBuilder(typeInfo, false);</span>

<span class="fc" id="L190">    JavaFile javaFile = JavaFile.builder(className.packageName(), classSpec.build()).build();</span>
<span class="fc" id="L191">    Path classFile = ObjectUtils.notNull(javaFile.writeToPath(targetDirectory));</span>

<span class="fc" id="L193">    return new DefaultGeneratedDefinitionClass(classFile, className, typeInfo.getDefinition());</span>
  }

  @Override
  public IGeneratedClass generatePackageInfoClass(
      String javaPackage,
      URI xmlNamespace,
      Collection&lt;IGeneratedModuleClass&gt; moduleProductions,
      Path targetDirectory) throws IOException {

<span class="fc" id="L203">    String packagePath = javaPackage.replace(&quot;.&quot;, &quot;/&quot;);</span>
<span class="fc" id="L204">    Path packageInfo = ObjectUtils.notNull(targetDirectory.resolve(packagePath + &quot;/package-info.java&quot;));</span>

<span class="fc" id="L206">    try (PrintWriter writer = new PrintWriter(</span>
<span class="fc" id="L207">        Files.newBufferedWriter(packageInfo, StandardOpenOption.CREATE, StandardOpenOption.WRITE,</span>
            StandardOpenOption.TRUNCATE_EXISTING))) {
<span class="fc" id="L209">      writer.format(&quot;@%1$s(moduleClass = {%n&quot;, MetaschemaPackage.class.getName());</span>

<span class="fc" id="L211">      boolean first = true;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      for (IGeneratedModuleClass moduleProduction : moduleProductions) {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (first) {</span>
<span class="fc" id="L214">          first = false;</span>
        } else {
<span class="fc" id="L216">          writer.format(&quot;,%n&quot;);</span>
        }
<span class="fc" id="L218">        writer.format(&quot;  %1$s.class&quot;, moduleProduction.getClassName().canonicalName());</span>
<span class="fc" id="L219">      }</span>

<span class="fc" id="L221">      writer.format(&quot;})%n&quot;);</span>

<span class="fc" id="L223">      writer.format(</span>
          &quot;@%1$s(namespace = \&quot;%2$s\&quot;, xmlns = {@%3$s(prefix = \&quot;\&quot;, namespace = \&quot;%2$s\&quot;)},&quot;
              + &quot; xmlElementFormDefault = %4$s.QUALIFIED)%n&quot;,
<span class="fc" id="L226">          XmlSchema.class.getName(), xmlNamespace.toString(), XmlNs.class.getName(), XmlNsForm.class.getName());</span>
<span class="fc" id="L227">      writer.format(&quot;package %s;%n&quot;, javaPackage);</span>
    }

<span class="fc" id="L230">    return new DefaultGeneratedClass(packageInfo, ObjectUtils.notNull(ClassName.get(javaPackage, &quot;package-info&quot;)));</span>
  }

  /**
   * Creates and configures a builder for a module that can be used to generate a
   * Java class.
   *
   * @param module
   *          a parsed Module module
   * @param className
   *          the name of the class to create for the Module module
   * @return the class builder
   */
  @NonNull
  protected TypeSpec.Builder newClassBuilder(
      @NonNull IModule module,
      @NonNull ClassName className) { // NOPMD - long, but readable

    // create the class
<span class="fc" id="L249">    TypeSpec.Builder builder = TypeSpec.classBuilder(className)</span>
<span class="fc" id="L250">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L251">        .addModifiers(Modifier.FINAL);</span>

<span class="fc" id="L253">    builder.superclass(AbstractBoundModule.class);</span>
<span class="fc" id="L254">    builder.addAnnotation(buildModuleAnnotation(module).build());</span>

<span class="fc" id="L256">    builder.addField(</span>
<span class="fc" id="L257">        FieldSpec.builder(MarkupLine.class, &quot;NAME&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L258">            .initializer(&quot;$T.fromMarkdown($S)&quot;, MarkupLine.class, module.getName().toMarkdown())</span>
<span class="fc" id="L259">            .build());</span>

<span class="fc" id="L261">    builder.addField(</span>
<span class="fc" id="L262">        FieldSpec.builder(String.class, &quot;SHORT_NAME&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L263">            .initializer(&quot;$S&quot;, module.getShortName())</span>
<span class="fc" id="L264">            .build());</span>

<span class="fc" id="L266">    builder.addField(</span>
<span class="fc" id="L267">        FieldSpec.builder(String.class, &quot;VERSION&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L268">            .initializer(&quot;$S&quot;, module.getVersion())</span>
<span class="fc" id="L269">            .build());</span>

<span class="fc" id="L271">    builder.addField(</span>
<span class="fc" id="L272">        FieldSpec.builder(URI.class, &quot;XML_NAMESPACE&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L273">            .initializer(&quot;$T.create($S)&quot;, URI.class, module.getXmlNamespace())</span>
<span class="fc" id="L274">            .build());</span>

<span class="fc" id="L276">    builder.addField(</span>
<span class="fc" id="L277">        FieldSpec.builder(URI.class, &quot;JSON_BASE_URI&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L278">            .initializer(&quot;$T.create($S)&quot;, URI.class, module.getJsonBaseUri())</span>
<span class="fc" id="L279">            .build());</span>

<span class="fc" id="L281">    MarkupMultiline remarks = module.getRemarks();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">    if (remarks != null) {</span>
<span class="fc" id="L283">      builder.addField(</span>
<span class="fc" id="L284">          FieldSpec.builder(MarkupMultiline.class, &quot;REMARKS&quot;, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)</span>
<span class="fc" id="L285">              .initializer(&quot;$T.fromMarkdown($S)&quot;, MarkupMultiline.class, remarks.toMarkdown())</span>
<span class="fc" id="L286">              .build());</span>
    }

<span class="fc" id="L289">    builder.addMethod(</span>
<span class="fc" id="L290">        MethodSpec.constructorBuilder()</span>
<span class="fc" id="L291">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L292">            .addParameter(</span>
<span class="fc" id="L293">                ParameterizedTypeName.get(ClassName.get(List.class),</span>
<span class="fc" id="L294">                    WildcardTypeName.subtypeOf(IBoundModule.class).box()),</span>
                &quot;importedModules&quot;)
<span class="fc" id="L296">            .addParameter(IBindingContext.class, &quot;bindingContext&quot;)</span>
<span class="fc" id="L297">            .addStatement(&quot;super($N, $N)&quot;, &quot;importedModules&quot;, &quot;bindingContext&quot;)</span>
<span class="fc" id="L298">            .build());</span>
<span class="fc" id="L299">    builder.addMethod(</span>
<span class="fc" id="L300">        MethodSpec.methodBuilder(&quot;getName&quot;)</span>
<span class="fc" id="L301">            .addAnnotation(Override.class)</span>
<span class="fc" id="L302">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L303">            .returns(MarkupLine.class)</span>
<span class="fc" id="L304">            .addStatement(&quot;return NAME&quot;)</span>
<span class="fc" id="L305">            .build());</span>

<span class="fc" id="L307">    builder.addMethod(</span>
<span class="fc" id="L308">        MethodSpec.methodBuilder(&quot;getShortName&quot;)</span>
<span class="fc" id="L309">            .addAnnotation(Override.class)</span>
<span class="fc" id="L310">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L311">            .returns(String.class)</span>
<span class="fc" id="L312">            .addStatement(&quot;return SHORT_NAME&quot;)</span>
<span class="fc" id="L313">            .build());</span>

<span class="fc" id="L315">    builder.addMethod(</span>
<span class="fc" id="L316">        MethodSpec.methodBuilder(&quot;getVersion&quot;)</span>
<span class="fc" id="L317">            .addAnnotation(Override.class)</span>
<span class="fc" id="L318">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L319">            .returns(String.class)</span>
<span class="fc" id="L320">            .addStatement(&quot;return VERSION&quot;)</span>
<span class="fc" id="L321">            .build());</span>

<span class="fc" id="L323">    builder.addMethod(</span>
<span class="fc" id="L324">        MethodSpec.methodBuilder(&quot;getXmlNamespace&quot;)</span>
<span class="fc" id="L325">            .addAnnotation(Override.class)</span>
<span class="fc" id="L326">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L327">            .returns(URI.class)</span>
<span class="fc" id="L328">            .addStatement(&quot;return XML_NAMESPACE&quot;)</span>
<span class="fc" id="L329">            .build());</span>

<span class="fc" id="L331">    builder.addMethod(</span>
<span class="fc" id="L332">        MethodSpec.methodBuilder(&quot;getJsonBaseUri&quot;)</span>
<span class="fc" id="L333">            .addAnnotation(Override.class)</span>
<span class="fc" id="L334">            .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L335">            .returns(URI.class)</span>
<span class="fc" id="L336">            .addStatement(&quot;return JSON_BASE_URI&quot;)</span>
<span class="fc" id="L337">            .build());</span>

<span class="fc" id="L339">    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(&quot;getRemarks&quot;)</span>
<span class="fc" id="L340">        .addAnnotation(Override.class)</span>
<span class="fc" id="L341">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L342">        .returns(MarkupMultiline.class);</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">    if (remarks == null) {</span>
<span class="fc" id="L345">      methodBuilder.addStatement(&quot;return null&quot;);</span>
    } else {
<span class="fc" id="L347">      methodBuilder.addStatement(&quot;return REMARKS&quot;);</span>
    }

<span class="fc" id="L350">    builder.addMethod(methodBuilder.build());</span>

<span class="fc" id="L352">    return builder;</span>
  }

  /**
   * Creates and configures a builder, for a Module model definition, that can be
   * used to generate a Java class.
   *
   * @param typeInfo
   *          the type information for the class to generate
   * @param isChild
   *          {@code true} if the class to be generated is a child class, or
   *          {@code false} otherwise
   * @return the class builder
   * @throws IOException
   *           if an error occurred while building the Java class
   */
  @NonNull
  protected TypeSpec.Builder newClassBuilder(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      boolean isChild) throws IOException {
    // create the class
<span class="fc" id="L373">    TypeSpec.Builder builder = TypeSpec.classBuilder(typeInfo.getClassName())</span>
<span class="fc" id="L374">        .addModifiers(Modifier.PUBLIC);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">    assert builder != null;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">    if (isChild) {</span>
<span class="fc" id="L377">      builder.addModifiers(Modifier.STATIC);</span>
    }
    // builder.addModifiers(Modifier.FINAL);

<span class="fc" id="L381">    builder.addSuperinterface(ClassName.get(IBoundObject.class));</span>

    // add field for Metaschema info
<span class="fc" id="L384">    builder.addField(FieldSpec.builder(IMetaschemaData.class, &quot;__metaschemaData&quot;, Modifier.PRIVATE, Modifier.FINAL)</span>
<span class="fc" id="L385">        .build());</span>

<span class="fc" id="L387">    builder.addMethod(MethodSpec.constructorBuilder()</span>
<span class="fc" id="L388">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L389">        .addStatement(&quot;this(null)&quot;)</span>
<span class="fc" id="L390">        .build());</span>

<span class="fc" id="L392">    builder.addMethod(MethodSpec.constructorBuilder()</span>
<span class="fc" id="L393">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L394">        .addParameter(IMetaschemaData.class, &quot;data&quot;)</span>
<span class="fc" id="L395">        .addStatement(&quot;this.$N = $N&quot;, &quot;__metaschemaData&quot;, &quot;data&quot;)</span>
<span class="fc" id="L396">        .build());</span>

    // generate a toString method that will help with debugging
<span class="fc" id="L399">    MethodSpec.Builder getMetaschemaData = MethodSpec.methodBuilder(&quot;getMetaschemaData&quot;)</span>
<span class="fc" id="L400">        .addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L401">        .returns(IMetaschemaData.class)</span>
<span class="fc" id="L402">        .addAnnotation(Override.class)</span>
<span class="fc" id="L403">        .addStatement(&quot;return __metaschemaData&quot;);</span>
<span class="fc" id="L404">    builder.addMethod(getMetaschemaData.build());</span>

<span class="fc" id="L406">    ClassName baseClassName = typeInfo.getBaseClassName();</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    if (baseClassName != null) {</span>
<span class="nc" id="L408">      builder.superclass(baseClassName);</span>
    }

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">    for (ClassName superinterface : typeInfo.getSuperinterfaces()) {</span>
<span class="nc" id="L412">      builder.addSuperinterface(superinterface);</span>
<span class="nc" id="L413">    }</span>

    Set&lt;IModelDefinition&gt; additionalChildClasses;
<span class="fc bfc" id="L416" title="All 2 branches covered.">    if (typeInfo instanceof IAssemblyDefinitionTypeInfo) {</span>
<span class="fc" id="L417">      additionalChildClasses = buildClass((IAssemblyDefinitionTypeInfo) typeInfo, builder);</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">    } else if (typeInfo instanceof IFieldDefinitionTypeInfo) {</span>
<span class="fc" id="L419">      additionalChildClasses = buildClass((IFieldDefinitionTypeInfo) typeInfo, builder);</span>
    } else {
<span class="nc" id="L421">      throw new UnsupportedOperationException(</span>
<span class="nc" id="L422">          String.format(&quot;Unsupported type: %s&quot;, typeInfo.getClass().getName()));</span>
    }

<span class="fc" id="L425">    ITypeResolver typeResolver = getTypeResolver();</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">    for (IModelDefinition definition : additionalChildClasses) {</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">      assert definition != null;</span>
<span class="fc" id="L429">      IModelDefinitionTypeInfo childTypeInfo = typeResolver.getTypeInfo(definition);</span>
<span class="fc" id="L430">      TypeSpec childClass = newClassBuilder(childTypeInfo, true).build();</span>
<span class="fc" id="L431">      builder.addType(childClass);</span>
<span class="fc" id="L432">    }</span>
<span class="fc" id="L433">    return ObjectUtils.notNull(builder);</span>
  }

  private AnnotationSpec.Builder buildModuleAnnotation(@NonNull IModule module) {
<span class="fc" id="L437">    AnnotationSpec.Builder retval = AnnotationSpec.builder(MetaschemaModule.class);</span>

<span class="fc" id="L439">    ITypeResolver typeResolver = getTypeResolver();</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">    for (IFieldDefinition definition : module.getFieldDefinitions()) {</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">      if (definition.hasChildren()) {</span>
<span class="fc" id="L442">        retval.addMember(&quot;fields&quot;, &quot;$T.class&quot;, typeResolver.getClassName(definition));</span>
      }
<span class="fc" id="L444">    }</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">    for (IAssemblyDefinition definition : module.getAssemblyDefinitions()) {</span>
<span class="fc" id="L447">      retval.addMember(</span>
          &quot;assemblies&quot;,
          &quot;$T.class&quot;,
<span class="fc" id="L450">          typeResolver.getClassName(ObjectUtils.notNull(definition)));</span>
<span class="fc" id="L451">    }</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">    for (IModule moduleImport : module.getImportedModules()) {</span>
<span class="fc" id="L454">      retval.addMember(</span>
          &quot;imports&quot;,
          &quot;$T.class&quot;,
<span class="fc" id="L457">          typeResolver.getClassName(ObjectUtils.notNull(moduleImport)));</span>
<span class="fc" id="L458">    }</span>

<span class="fc" id="L460">    Map&lt;String, String&gt; bindings = module.getNamespaceBindings();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">    if (!bindings.isEmpty()) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; binding : bindings.entrySet()) {</span>
<span class="fc" id="L463">        retval.addMember(</span>
            &quot;nsBindings&quot;,
            &quot;$L&quot;,
<span class="fc" id="L466">            AnnotationSpec.builder(NsBinding.class)</span>
<span class="fc" id="L467">                .addMember(&quot;prefix&quot;, &quot;$S&quot;, binding.getKey())</span>
<span class="fc" id="L468">                .addMember(&quot;uri&quot;, &quot;$S&quot;, binding.getValue())</span>
<span class="fc" id="L469">                .build());</span>
<span class="fc" id="L470">      }</span>
    }

<span class="fc" id="L473">    MarkupMultiline remarks = module.getRemarks();</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">    if (remarks != null) {</span>
<span class="fc" id="L475">      retval.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
    }
<span class="fc" id="L477">    return retval;</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IAssemblyDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L494">    AnnotationSpec.Builder metaschemaAssembly = ObjectUtils.notNull(AnnotationSpec.builder(MetaschemaAssembly.class));</span>

<span class="fc" id="L496">    buildCommonProperties(typeInfo, metaschemaAssembly);</span>

<span class="fc" id="L498">    IAssemblyDefinition definition = typeInfo.getDefinition();</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">    if (definition.isRoot()) {</span>
<span class="fc" id="L500">      metaschemaAssembly.addMember(&quot;rootName&quot;, &quot;$S&quot;, definition.getRootName());</span>
    }

<span class="fc" id="L503">    MarkupMultiline remarks = definition.getRemarks();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">    if (remarks != null) {</span>
<span class="fc" id="L505">      metaschemaAssembly.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
    }

<span class="fc" id="L508">    AnnotationGenerator.buildValueConstraints(metaschemaAssembly, definition);</span>
<span class="fc" id="L509">    AnnotationGenerator.buildAssemblyConstraints(metaschemaAssembly, definition);</span>

<span class="fc" id="L511">    builder.addAnnotation(metaschemaAssembly.build());</span>

<span class="fc" id="L513">    return new LinkedHashSet&lt;&gt;(buildClass((IModelDefinitionTypeInfo) typeInfo, builder));</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IFieldDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L530">    AnnotationSpec.Builder metaschemaField = ObjectUtils.notNull(AnnotationSpec.builder(MetaschemaField.class));</span>

<span class="fc" id="L532">    buildCommonProperties(typeInfo, metaschemaField);</span>

<span class="fc" id="L534">    IFieldDefinition definition = typeInfo.getDefinition();</span>
<span class="fc" id="L535">    AnnotationGenerator.buildValueConstraints(metaschemaField, definition);</span>

<span class="fc" id="L537">    builder.addAnnotation(metaschemaField.build());</span>

<span class="fc" id="L539">    return new LinkedHashSet&lt;&gt;(buildClass((IModelDefinitionTypeInfo) typeInfo, builder));</span>
  }

  /**
   * Generate the contents of the class represented by the provided
   * {@code builder}.
   *
   * @param typeInfo
   *          the type information for the class to build
   * @param builder
   *          the builder to use for generating the class content
   * @return the set of additional definitions for which child classes need to be
   *         generated
   */
  @NonNull
  protected Set&lt;IModelDefinition&gt; buildClass(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      @NonNull TypeSpec.Builder builder) {
<span class="fc" id="L557">    MarkupLine description = typeInfo.getDefinition().getDescription();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">    if (description != null) {</span>
<span class="fc" id="L559">      builder.addJavadoc(description.toHtml());</span>
    }

<span class="fc" id="L562">    Set&lt;IModelDefinition&gt; additionalChildClasses = new LinkedHashSet&lt;&gt;();</span>

    // // generate a no-arg constructor
    // builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build());

    // // generate a copy constructor
    // MethodSpec.Builder copyBuilder =
    // MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);
    // copyBuilder.addParameter(className, &quot;that&quot;, Modifier.FINAL);
    // for (IPropertyGenerator property : getPropertyGenerators()) {
    // additionalChildClasses.addAll(property.buildCopyStatements(copyBuilder,
    // getTypeResolver()));
    // }
    // builder.addMethod(copyBuilder.build());

    // generate all the properties and access methods
<span class="fc bfc" id="L578" title="All 2 branches covered.">    for (IPropertyTypeInfo property : typeInfo.getPropertyTypeInfos()) {</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">      assert property != null;</span>
<span class="fc" id="L580">      additionalChildClasses.addAll(property.build(builder));</span>
<span class="fc" id="L581">    }</span>

    // generate a toString method that will help with debugging
<span class="fc" id="L584">    MethodSpec.Builder toString = MethodSpec.methodBuilder(&quot;toString&quot;).addModifiers(Modifier.PUBLIC)</span>
<span class="fc" id="L585">        .returns(String.class).addAnnotation(Override.class);</span>
<span class="fc" id="L586">    toString.addStatement(&quot;return new $T(this, $T.MULTI_LINE_STYLE).toString()&quot;, ReflectionToStringBuilder.class,</span>
        ToStringStyle.class);
<span class="fc" id="L588">    builder.addMethod(toString.build());</span>
<span class="fc" id="L589">    return CollectionUtil.unmodifiableSet(additionalChildClasses);</span>
  }

  /**
   * Build the core property annotations that are common to all Module classes.
   *
   * @param typeInfo
   *          the type information for the Java property to build
   * @param builder
   *          the class builder
   */
  protected void buildCommonProperties(
      @NonNull IModelDefinitionTypeInfo typeInfo,
      @NonNull AnnotationSpec.Builder builder) {
<span class="fc" id="L603">    IDefinition definition = typeInfo.getDefinition();</span>

<span class="fc" id="L605">    String formalName = definition.getEffectiveFormalName();</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">    if (formalName != null) {</span>
<span class="fc" id="L607">      builder.addMember(&quot;formalName&quot;, &quot;$S&quot;, formalName);</span>
    }

<span class="fc" id="L610">    MarkupLine description = definition.getEffectiveDescription();</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">    if (description != null) {</span>
<span class="fc" id="L612">      builder.addMember(&quot;description&quot;, &quot;$S&quot;, description.toMarkdown());</span>
    }

<span class="fc" id="L615">    builder.addMember(&quot;name&quot;, &quot;$S&quot;, definition.getName());</span>
<span class="fc" id="L616">    IModule module = definition.getContainingModule();</span>
<span class="fc" id="L617">    builder.addMember(&quot;moduleClass&quot;, &quot;$T.class&quot;, getTypeResolver().getClassName(module));</span>
<span class="fc" id="L618">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>